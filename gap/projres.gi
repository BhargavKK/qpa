# GAP Implementation
# This file was generated from
# $Id: projres.gi,v 1.3 2012/02/27 12:26:34 sunnyquiver Exp $
#

InstallMethod( ProjectiveResolutionFpPathAlgebraModule,
  "for algebras",
  true,
  [ IsAlgebra,
    IsRing and HasGroebnerBasisOfIdeal,
    IsRingElementTable,
    IsPosInt ], 0,
  function(A, I, presentation_map, n)
    local i, j, N, P, R, PI, maps, gen, verts, tmpverts,
          RelementsFam, Rverts, rtG, X1, Y1, Res, el, tmp,
          f, fprime;

    # Check we're in correct category:
    if not (IsPathAlgebra(A) or IsQuotientOfPathAlgebra(A)) then
        TryNextMethod();
    fi;

    # Initialize R-projectives:
    P := [];

    # Initialize projective resolution maps:
    maps := [];

    #####
    #
    #  Verify correctness of matrix <presentation_map>:

    # Verify generators are not empty:
    if IsEmpty(presentation_map) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map>, <n> )",
              " <presentation_map> must be nonempty.");
    fi;

    # Verify all entries are left uniform:
    for gen in presentation_map do
      if not ForAll(gen, IsLeftUniform) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " entries in <presentation_map> must be left uniform.");
      fi;
    od;

    # Retrieve starting vertex of each element in first row:
    #  (These vertices will allow us to form L^0, the first right projective
    #   module in the projective resolution).
    verts := List(presentation_map[1], x -> SourceVertex(LeadingMonomial(x)));

    # Verify we really have proper presentation, while also filling in
    #  nonzero vertices in positions where first row of presentation map had zero:
    for gen in presentation_map do
      tmpverts := List(gen, x -> SourceVertex(LeadingMonomial(x)));

      for i in [1..Length(verts)] do
        if IsZeroPath(verts[i]) and not IsZeroPath(tmpverts[i]) then
          verts[i] := tmpverts[i];
        elif verts[i] <> tmpverts[i] and not IsZeroPath(tmpverts[i]) then
          Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
                " <presentation_map> contains mismatched starting vertices.");
        fi;
      od;
    od;

    # Check columns are non-zero:
    if not ForAll(verts, x -> not IsZeroPath(x)) then
      Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
            " <presentation_map> contains all zeroes in some column.");
    fi;

    #
    #####


    #####
    #
    #  Lift Module presentation:
    # Get the parent ring R for ideal I (where above A = R/I):
    R := LeftActingRingOfIdeal(I);

    # Get right groebner basis for ideal:
    rtG := RightGroebnerBasis(I);

    # Get family for ring:
    RelementsFam := ElementsFamily(FamilyObj(R));

    # Create first R-projective P[1] in R-projective resolution:
    Rverts :=  List(verts, x->x*One(R) );
    P[1] := RightProjectiveModule( R, Rverts );

    # Convert rows in presentation_map from elements in R/I to elements in R:
    X1 := [];
    i := 1;
    for i in [1..Length(presentation_map)] do
      X1[i] := List(presentation_map[i], x -> ObjByExtRep(RelementsFam,ExtRepOfObj(x))); 
    od;

    # Vectorize:
    X1 := List( X1, x -> Vectorize(P[1], x) );

    # Create set Y1 to union with X1 for the lift:
    Y1 := [];
    for i in [1..Length(verts)] do
      for el in rtG!.relations do
        if not IsZero(Rverts[i]*el) then
          tmp := List([1..Length(Rverts)], x->Zero(R));
          tmp[i] := Rverts[i]*el;
          Add(Y1,tmp);
        fi;
      od;
    od;

    # Vectorize:
    Y1 := List( Y1, x -> Vectorize(P[1], x) );

    # Tip reduce the set (X1 union Y1), i.e. find right groebner basis for
    #  submodule of P[1] generated by set (X1 union Y1):
    N := TipReduce(Concatenation(X1,Y1));

    # Tip reduce the set Y1, i.e. find right groebner basis for
    #  submodule of P[1] generated by set Y1:
    PI := TipReduce(Y1);

    # Determine f1's and f1primes:
    f := [];
    fprime := [];
    f[1] := [];
    fprime[1] := [];
    i := 1;
    j := 1;
    for el in N do
      tmp := TipReduce(PI,el);
      if IsZero(tmp) then
        fprime[1][i] := el;
        i := i + 1;
      else
        f[1][j] := el;
        j := j + 1;
      fi;
    od;

    # Set up f2's:
    f[2] := [];

    #
    #####


    #####
    #
    #  Create Projective resolution object:
    #
    Res := Objectify(NewType(ProjectiveResolutionFpPathAlgebraModuleFamily,
                             IsProjectiveResolutionFpPathAlgebraModuleDefaultRep),
                             rec());
    SetName(Res,"ProjectiveResolutionFpPathAlgebraModule");
    SetParentAlgebra(Res,A);
#    SetModule(Res,M);
#    SetProjectives(Res,L);
    SetRProjectives(Res,P);
    SetMaps(Res,maps);
    SetProjectivesFList(Res,f);

    #
    #####


    #####
    #
    #  Iterate n times to get projectives P[i], 1<=i<=n:
    #
    for i in [2..n] do
      if Length(ProjectivesFList(Res)[i-1]) > 0 then
        Print("Computing f",i,"'s.\n");
      else
        Print("Projective resolution is finite.\n");
        break;
      fi;
    od;

    #
    #####

    return Res;

  end
);


InstallMethod( ProjectiveResolutionFpPathAlgebraModule,
  "for algebras",
  true,
  [ IsAlgebra, IsRing and HasGroebnerBasisOfIdeal, IsRingElementTable ], 0,
  function(A,I,presentation_map)
    local Res, gen, len, verts, gVerts, rverts, paverts, lverts, RelementsFam, el, el2,
          f, fprime, i, j, tmp, L, P, N, M, R, X1, Y1, G, rtG, rtGBofN, maps, Mzero,
          II, rtGBofII, XSet, perm;

    # R-projectives:
    P := [];

    # R/I-projectives:
    L := [];

    maps := [presentation_map];

    if not (IsPathAlgebra(A) or IsQuotientOfPathAlgebra(A)) then
        TryNextMethod();
    fi;

    # Make sure generators are not empty
    if IsEmpty(presentation_map) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " <presentation_map> must be nonempty.");
    fi;

    # Make sure all entries are left uniform
    for gen in presentation_map do
      if not ForAll(gen, IsLeftUniform) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " entries in <presentation_map> must be left uniform.");
      fi;
    od;

    # Get the starting vertex of each element in first row:
    #  (These vertices will allow us to form L^0, the first right projective
    #   module in the projective resolution).
    verts := List(presentation_map[1], x -> SourceVertex(LeadingMonomial(x)));

    # Verify we really have proper presentation:
    for gen in presentation_map do
      gVerts := List(gen, x -> SourceVertex(LeadingMonomial(x)));

      for i in [1..Length(verts)] do
        if IsZeroPath(verts[i]) and not IsZeroPath(gVerts[i]) then
          verts[i] := gVerts[i];
        elif verts[i] <> gVerts[i] and not IsZeroPath(gVerts[i]) then
          Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
                " <presentation_map> contains mismatched starting vertices.");
        fi;
      od;
    od;

    # Check columns are non-zero:
    if not ForAll(verts, x -> not IsZeroPath(x)) then
      Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
            " <presentation_map> contains all zeroes in some column.");
    fi;

    # Get the parent ring R for ideal I (where above A = R/I):
    R := LeftActingRingOfIdeal(I);

    # Get right groebner basis for ideal:
    rtG := RightGroebnerBasis(I);
#Print("rtG: ",rtG!.relations,"\n");

    # Get family for ring:
    RelementsFam := ElementsFamily(FamilyObj(R));

    # Create vertex set (all in the path algebra) from 'verts':
    paverts := List(verts, x -> x*One(A));
#Print("paverts: ",paverts,"\n");

    # Create vertex set (all in the ring) from 'verts':
    rverts := List(verts, x -> x*One(R));
#Print("rverts: ", rverts,"\n");

    # Ok, everything is good, construct the module L^0 from vertices in first row:
    L[1] := RightProjectiveModule( A, paverts );
    P[1] := RightProjectiveModule( R, rverts );


    # Convert elements in map from elements in R/I to elements in R:
    X1 := [];
    i := 1;
    for i in [1..Length(presentation_map)] do
      X1[i] := List(presentation_map[i], x -> ObjByExtRep(RelementsFam,ExtRepOfObj(x))); 
    od;
#Print("X1 (prevectors): ",X1,"\n");

    X1 := List( X1, x -> Vectorize(P[1], x) );
#Print("X1: ",X1,"\n");

    # Create set Y1 to union with X1 for the lift:
    Y1 := [];
    for i in [1..Length(rverts)] do
      for el in rtG!.relations do
        if not IsZero(rverts[i]*el) then
          tmp := List([1..Length(rverts)], x->Zero(R));
          tmp[i] := rverts[i]*el;
          Add(Y1,tmp);
        fi;
      od;
    od;    

#Print("Y1 (prevectors): ",Y1,"\n");
    Y1 := List( Y1, x -> Vectorize(P[1], x) );
#Print("Y1: ",Y1,"\n");

#Print("X1 Union Y1: ",Concatenation(X1,Y1),"\n");
    # Determine the submodule of the algebra module P[1] generated by the elements
    #  of X1 union Y1 (which are the rows of the presentation_map).
    N := SubAlgebraModule(P[1], Concatenation(X1,Y1));

    II := SubAlgebraModule(P[1], Y1);

    rtGBofN := RightGroebnerBasisOfModule(N);
#Print("Right Groebner Basis of Module N: ",BasisVectors(rtGBofN),"\n");

    rtGBofII := RightGroebnerBasisOfModule(II);
#Print("Right Groebner Basis of Module II: ",BasisVectors(rtGBofII),"\n\n");

    # Determine f1's and f1primes:
    f := [];
    fprime := [];
    f[1] := [];
    fprime[1] := [];
    i := 1;
    j := 1;
    for el in BasisVectors(rtGBofN) do
      tmp := CompletelyReduce(rtGBofII,el);
      if IsZero(tmp) then
        fprime[1][i] := el;
        i := i + 1;
      else
        f[1][j] := el;
        j := j + 1;
      fi;
    od;

#Print( "f[1]: ", f[1], "\n");
#Print( "fprime[1]: ", fprime[1], "\n");

    # Sort the f1's, largest Tip first:
    Sort(f[1],\<);
    f[1] := Reversed(f[1]);

    # Since all f1's should be right uniform, get the vertices for the vertex projective P[2]:
    lverts := [];
    for el in f[1] do
#Print("el![1]: ",el![1],"\n");
      if IsRightUniform(el![1]) then
#Print("target vertex: ", TargetVertex(el![1]),"\n");
        Add(lverts,TargetVertex(el![1]));
      else
        Error("The f1's are not right uniform. \n");
      fi;
    od;

#Print("lverts: ",lverts,"\n");

    # Convert vertex set (all in the path algebra) from 'lverts', create L^2:
    lverts := List(lverts, x -> x*One(A)); 
#    rverts := List(lverts, x -> x*One(R)); 
    L[2] := RightProjectiveModule( A, lverts );
#    P[2] := RightProjectiveModule( R, rverts );


    # create f2's:
    f[2] := [];
    i := 1;

    # Determine the OSet and NSet for our f1's:
    for el in f[1] do
Print("el: ",el,"\n");
#Print(IsRing(I), " ",HasGroebnerBasisOfIdeal(I),"\n");
#Print("el IsPathAlgebraVector: ",IsPathAlgebraVector(el),"\n");
#Print("el![1] IsPathAlgebraVector: ",IsPathAlgebraVector(el![1]),"\n");
      XSet := XSetOfPathAlgebraVector(P[1], I, el![1]);
Print("XSet: ",XSet,"\n");
      for el2 in XSet[1] do
Print("el2: ",el2,"\n");
#Print("el2 IsPathAlgebraVector: ",IsPathAlgebraVector(el2),"\n");
#Print("el2![1] IsPathAlgebraVector: ",IsPathAlgebraVector(el2![1]),"\n");
#        if not IsZero(el2[1]) then
#          tmp := el![1]^el2[2] - TipReduce(List(f[1],x -> x![1]), el2[1]![1]); 
          tmp := el![1]^el2[2] - el2[1]![1]; 
Print("firstpart: ",FirstPart(f[1],tmp),"\n");
Print("\ttmp: ",el![1]^el2[2],"  ",tmp,"\n");
#        fi;
      od;
    od;


    # Form quotient module:
#    M :=  P[1]/N;

    # Create the (initial) resolution:
    Res := Objectify(NewType(ProjectiveResolutionFpPathAlgebraModuleFamily,
                             IsProjectiveResolutionFpPathAlgebraModuleDefaultRep),
                             rec());
    SetName(Res,"ProjectiveResolutionFpPathAlgebraModule");
    SetParentAlgebra(Res,A);
#    SetModule(Res,M);
    SetProjectives(Res,L);
    SetRProjectives(Res,P);
    SetMaps(Res,maps);
    SetProjectivesFList(Res,f);

    return Res;

  end
);


# Two lists returned, list 1 is OSet, list 2 is NSet.
# OSet is a list of elements, each of which is a list of the form:
#   [ ??? ]
InstallMethod( XSetOfPathAlgebraVector,
  "for path algebra vectors",
  true, 
  [ IsVertexProjectiveModule,
    IsRing and HasGroebnerBasisOfIdeal,
    IsPathAlgebraVector ],
  0,
  function( P, I, el )
    local a, path, fam, t, OSet, NSet, XSet, outarrows, nonzeroflag, tippath, tippathlen,
          tipcoeff, gbel, tmpel,
          gbeltip, gbeltipcoeff, productwalk, gbtipwalk, YSet, Yflag, GB, p, pwalk, qwalk,
          qprime, gbellen, qprimewalk, qlen;

    # Initialize our N and O sets:
    OSet := [];
    NSet := [];
    XSet := [];
    YSet := [];
    outarrows := [];

    # tippath of el:
    tippath := TipMonomial(el![1][el![2]]);
    tipcoeff := TipCoefficient(el![1][el![2]]);
    tippathlen := Length(ExtRepOfObj(tippath));
# Print("tipext: ",ExtRepOfObj(tippath),"\n");
    XSet := [ tippath ];

    # Get Groebner basis:
    GB := GroebnerBasisOfIdeal(I);
#Print("tippath: ", tippath,"\n");

# Print("GB: ", GB!.relations,"\n");

    fam := FamilyObj(el![1][el![2]]);

    # create a tuple that should work in the module:
#    elzero := List([1..Length(el![1])], x -> Zero(el![1][el![2]]));

    # calculate all paths starting with el until all successive are nonzero:
    nonzeroflag := true;

    while nonzeroflag do

      nonzeroflag := false;

      for path in XSet do

        # Get target vertex, then outgoing arrows, of tippath of given pa module vector:
        t := TargetOfPath(path); 
        outarrows := OutgoingArrowsOfVertex(t);
        # translate arrows to paths:
        outarrows := List(outarrows, x->ElementOfMagmaRing(fam,fam!.zeroRing,[One(fam!.zeroRing)],[x]));

        # We only examine paths that are properly larger than el: 
        for a in outarrows do 

          Yflag := true;

          # Assert: all products path*a should be nonzero here since
          #         using only outgoing arrows from path.
          for gbel in GB!.relations do
              gbeltip := TipMonomial(gbel);
              gbeltipcoeff := TipCoefficient(gbel);
              gbtipwalk := WalkOfPath(gbeltip);
              productwalk := WalkOfPath(TipMonomial(path*a));
#Print("productwalk: ", productwalk, ", gbtipwalk: ", gbtipwalk, "\n");
#Print("product: ", path, " * ", a, " = ", path*a, "\n");
              if (PositionSublist(Reversed(productwalk),Reversed(gbtipwalk)) = 1) then

#Print("\t gbeltip ", gbeltip, " right divides ", path*a, "\n");
#Print("\t\tlength of ",tippath, " = ", Length(WalkOfPath(tippath)),"\n");
#Print("\t\tlength of ",gbeltip, " = ", Length(WalkOfPath(gbeltip)),"\n");
#Print("\t\tlength of ",path*a, " = ", Length(WalkOfPath(path))+1,"\n");

                # Determine if OSet element or NSet:
                if (tippathlen + Length(WalkOfPath(gbeltip))) <= (Length(WalkOfPath(path))+1) then
                  if (tippathlen+Length(WalkOfPath(gbeltip))) = (Length(WalkOfPath(path))+1) then
                    Add(NSet, [path*a, One(path*a), gbel]);
                  else
                    qwalk := ExtRepOfObj(path*a);
                    qlen := Length(qwalk[2][1]);
                    gbellen := Length(gbtipwalk);
                    qwalk := [qwalk[1],[ qwalk[2][1]{[tippathlen+1..(qlen-gbellen)]}, qwalk[2][2]]];

                    Add(NSet, [path*a, One(path*a), gbel]);
                  fi;
                else

                  # create external rep of, and then element that is subpath in path*a after tippath.
                  qwalk := ExtRepOfObj(path*a);
                  qlen := Length(qwalk[2][1]);
                  pwalk := [qwalk[1],[ qwalk[2][1]{[tippathlen+1..qlen]}, qwalk[2][2]]];
                  p := ObjByExtRep(fam,pwalk);

# Print("\t\t\tpwalk: ",pwalk,"\n");
# Print("\t\t\tp: ",p,"\n");

                  # create external rep of, and then element that is subpath in path*a before gbeltip.
                  gbellen := Length(gbtipwalk);

                  # If tip gbel is equal to path*a, no (prefix) subpath qprime:
                  if gbellen = qlen then

                    # create element in module to use for the module 'syzygy':
                    tmpel := ShallowCopy(Zero(P)![1]![1]);
                    tmpel[el![2]] := (tipcoeff/gbeltipcoeff)*gbel;

                    Add(OSet, [Vectorize(P,el![1]*p-tmpel),p]);

                  else

                    qprimewalk := [qwalk[1],[ qwalk[2][1]{[1..(qlen-gbellen)]}, qwalk[2][2]]];
                    qprime := ObjByExtRep(fam,qprimewalk);
#Print("\t\t\tqprimewalk: ",qprimewalk,"\n");
#Print("\t\t\tqprime: ",qprime,"\n");
                    # create element in module to use for the module 'syzygy':
                    tmpel := ShallowCopy(Zero(P)![1]![1]);
#Print("\t\t\ttmpel[el![2]]: ",tmpel[el![2]],"\n");
#Print("\t\t\tqprime: ",qprime,"\n");
                    tmpel[el![2]] := (tipcoeff/gbeltipcoeff)*qprime*gbel;

                    # Only include nonzero elements:
                    if not IsZero(el![1]*p-tmpel) then
                      Add(OSet, [Vectorize(P,el![1]*p-tmpel),p]);
                    fi;
                  fi;

                fi;
              
                Yflag := false;
                break;
              fi;
          od;

          if Yflag then
            Add(YSet, TipMonomial(path*a));
          fi;

        od;   # outgoing arrows loop.

      od;     # paths in XSet loop.

      if (Length(YSet) > 0) then
        nonzeroflag := true;
        XSet := ShallowCopy(YSet);
        YSet := [];
      fi;

    od;

#Print("YSet: ", YSet,"\n");

    return [OSet,NSet];

  end
);


InstallMethod( TipReduce,
  "tip reduce set of elements from path algebra module",
  true, 
  [IsHomogeneousList], 0,
  function( M )
    local i, j, H, Hlen, reducible, redset;

    if ( not IsRightAlgebraModuleElementCollection(M) ) then
      TryNextMethod();
    fi;

    H := List(M, ExtRepOfObj );

    # Tip reduce H to create a Right Groebner Basis:
    reducible := true;
    while reducible do

      # remove zeros:
      H := Filtered(H, x -> not IsZero(x));

      reducible := false;

      Hlen := Length(H);

      for i in [1..Hlen] do
        redset := Difference([1..Hlen],[i]);
        for j in redset do
          # if H[j] divides H[i]:
          if IsLeftDivisible(H[i], H[j]) then
            H[i] := ReduceRightModuleElement( H[i], H[j] );
            reducible := true;
            break;
          fi;
        od;
        if reducible then
          break;
        fi;
      od;

    od;

    return H;

  end
);


InstallMethod( TipReduce,
  "tip reduce path algebra vector by set of path algebra vectors",
  true, 
  [IsHomogeneousList, IsPathAlgebraVector], 0,
  function( H, el )
    local i, reducible, rlen, redset;

    # Tip reduce el to by set redset:
    reducible := true;

    # Convert reducing set to pathalgebavectors
    redset := List(H, ExtRepOfObj );

    while reducible and (not IsZero(el)) do

      reducible := false;

      i := 1;
      rlen := Length(redset);
      while i <= rlen do

#Print("\t",i," el:", el,"\n");
        # if redset[i] divides el:
        if IsLeftDivisible(el, redset[i]) then
#Print("\t\thit\n");
          el := ReduceRightModuleElement( el, redset[i] );
          reducible := true;
          break;
        else
          i := i + 1;    
        fi;
      od;
    od;

    return el;

  end
);



# ORDER IS GOING TO MATTER HERE:

# returns a list of algebra elements:
InstallMethod( FirstPart,
  "writes a module element as a finite sum of given module elements",
  true, 
  [IsHomogeneousList, IsPathAlgebraVector], 0,
  function( f, v )
    local i, retvec, fam, flen, tmp, div;

    flen := Length(f);
    fam := FamilyObj(v![1][v![2]]);
    retvec := ListWithIdenticalEntries( flen, Zero(v![1][v![2]]) );

    tmp := ShallowCopy(v);

    for i in [1..flen] do
      # Tip divide tmp by element f[i]:
#Print("tmp : ",tmp,"\n");
#Print("f[i] : ",f[i],"\n");
#Print("f[i] IsPathAlgebraVector: ",IsPathAlgebraVector(f[i]),"\n");
#Print("f[i]![1] IsPathAlgebraVector: ",IsPathAlgebraVector(f[i]![1]),"\n");
#Print("v IsPathAlgebraVector: ",IsPathAlgebraVector(v),"\n");
#Print("v![1] IsPathAlgebraVector: ",IsPathAlgebraVector(v),"\n");
#Print("v : ",v,"\n");
#Print("v![1] : ",v![1],"\n");
      div := LeftDivision(tmp, f[i]![1]); 
      if (not (div = false)) then
        retvec[i] := div;
        tmp := tmp - f[i]![1]^div;
      fi;
    od;

Print("retvec: ",retvec,"\n");
    return retvec;
  end
);


# operation that returns right factor if y divides x.
InstallMethod( LeftDivision,
  "for path algebra vectors",
  true,
  [ IsPathAlgebraVector,
    IsPathAlgebraVector], 0,
  function( x, y )
    local xTipPos, xLeadingTerm, xCoeff, xMon, xWalk,
          yTipPos, yLeadingTerm, yCoeff, yMon, yWalk,
          fam, rightfactor, rfrep, xrep;

    if (IsZero(x) or IsZero(y)) then
      Error("don't send me zeroes, please.\n");
    else
      fam := FamilyObj(x![1][x![2]]);
      rightfactor := One(x![1][x![2]]);

      # Word to be divided:
      xTipPos := x![2];
#Print("tipcoord: ",x![2],"\n");
#Print("LeadingTerm: ",LeadingTerm(x),"\n");
      xLeadingTerm := LeadingTerm(x)![1][xTipPos];
      xMon := TipMonomial(xLeadingTerm);
      xCoeff := TipCoefficient(xLeadingTerm);
#Print("xMon: ",xMon,"\n");
      xWalk := WalkOfPath(xMon);

      # Dividing word:
      yTipPos := y![2];
      yLeadingTerm := LeadingTerm(y)![1][yTipPos];
      yMon := TipMonomial(yLeadingTerm);
      yCoeff := TipCoefficient(yLeadingTerm);
      yWalk := WalkOfPath(yMon);

      if ((xTipPos = yTipPos) and (PositionSublist(xWalk, yWalk) = 1)) then
        # Create right factor:
        if ( Length(yWalk) <> Length(xWalk) ) then
          xrep := ExtRepOfObj(xLeadingTerm);
Print("xrep: ",xrep,"\n");
Print("xCoeff: ",xCoeff,"\n");
Print("yCoeff: ",yCoeff,"\n");

          # Note: creating the external rep of object here, complete with
          #       appropriate coefficient:
          #          xCoeff == (xCoeff/yCoeff)*yCoeff.
          rfrep := [xrep[1],[ xrep[2][1]{[(Length(yWalk)+1)..Length(xWalk)]}, xCoeff]];
          rightfactor := ObjByExtRep(fam,rfrep);
#          rightfactor := (xCoeff/yCoeff)*rightfactor;
        else
          rightfactor := (xCoeff/yCoeff)*rightfactor;
        fi;

      else
        return false;
      fi;

Print("rightfactor: ",rightfactor,"\n");
      return rightfactor;
    fi;

  end
);


