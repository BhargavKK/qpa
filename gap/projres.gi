# GAP Implementation
# This file was generated from
# $Id: projres.gi,v 1.4 2012/09/03 07:06:45 sunnyquiver Exp $
#


InstallMethod( ProjectiveResolutionFpPathAlgebraModule,
  "for algebras",
  true,
  [ IsAlgebra, IsRing and HasGroebnerBasisOfIdeal, IsRingElementTable, IsPosInt ], 0,
  function(A,I,presentation_map, termint)
    local Res, gen, len, verts, gVerts, rverts, paverts, lverts, RelementsFam, el, el2,
          f, fprime, i, j, k, tmp, L, P, N, M, R, X1, Y1, G, rtG, rtGBofN, maps,
          II, rtGBofII, XSet, perm, mapstmp;

    # R-projectives:
    P := [];

    # R/I-projectives:
    L := [];

    # f list:
    f := [];

    # resolution maps:
    maps := [];

    if not (IsPathAlgebra(A) or IsQuotientOfPathAlgebra(A)) then
        TryNextMethod();
    fi;

    # Make sure generators are not empty
    if IsEmpty(presentation_map) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " <presentation_map> must be nonempty.");
    fi;

    # Make sure all entries are left uniform
    for gen in presentation_map do
      if not ForAll(gen, IsLeftUniform) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " entries in <presentation_map> must be left uniform.");
      fi;
    od;

    # Get the starting vertex of each element in first row:
    #  (These vertices will allow us to form L^0, the first right projective
    #   module in the projective resolution).
    verts := List(presentation_map[1], x -> SourceVertex(LeadingMonomial(x)));


    # Verify we really have proper presentation:
    for gen in presentation_map do 
      gVerts := List(gen, x -> SourceVertex(LeadingMonomial(x)));
      
      for i in [1..Length(verts)] do
        if IsZeroPath(verts[i]) and not IsZeroPath(gVerts[i]) then
          verts[i] := gVerts[i];
        elif verts[i] <> gVerts[i] and not IsZeroPath(gVerts[i]) then
          Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
                " <presentation_map> contains mismatched starting vertices.");
        fi;     
      od;
    od;
    
    # Check columns are non-zero:
    if not ForAll(verts, x -> not IsZeroPath(x)) then
      Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
            " <presentation_map> contains all zeroes in some column.");
    fi;

    # Get the parent ring R for ideal I (where above A = R/I):
    R := LeftActingRingOfIdeal(I);

    # Get right groebner basis for ideal:
    rtG := RightGroebnerBasis(I);
#Print("rtG: ",rtG!.relations,"\n");

    # Get family for ring:
    RelementsFam := ElementsFamily(FamilyObj(R));

    # Create vertex set (all in the path algebra) from 'verts':
#Print("verts: ",verts,"\n");
    paverts := List(verts, x -> x*One(A));
#Print("paverts: ",paverts,"\n");

    # Create vertex set (all in the ring) from 'verts':
    rverts := List(verts, x -> x*One(R));
#Print("rverts: ", rverts,"\n");

    # Ok, everything is good, construct the module L^0 from vertices in first row:
    L[1] := RightProjectiveModule( A, paverts );
    P[1] := RightProjectiveModule( R, rverts );

    # Convert elements in map from elements in R/I to elements in R:
    X1 := [];
    i := 1;
    for i in [1..Length(presentation_map)] do
      X1[i] := List(presentation_map[i], x -> ObjByExtRep(RelementsFam,ExtRepOfObj(x)));
    od;
#Print("X1 (prevectors): ",X1,"\n");

    # first map:
    maps[1] := ShallowCopy(X1);

    X1 := List( X1, x -> Vectorize(P[1], x) );
#Print("X1: ",X1,"\n");

    # Create set Y1 to union with X1 for the lift:
    Y1 := [];
    for i in [1..Length(rverts)] do
      for el in rtG!.relations do
        if not IsZero(rverts[i]*el) then
          tmp := List([1..Length(rverts)], x->Zero(R));
          tmp[i] := rverts[i]*el;
          Add(Y1,tmp);
        fi;
      od;
    od;   

#Print("Y1 (prevectors): ",Y1,"\n");
    Y1 := List( Y1, x -> Vectorize(P[1], x) );
#Print("Y1: ",Y1,"\n");

#Print("X1 Union Y1: ",Concatenation(X1,Y1),"\n");

    # Determine the submodule of the algebra module P[1] generated by the elements
    #  of X1 union Y1 (which are the rows of the presentation_map).
    N := SubAlgebraModule(P[1], Concatenation(X1,Y1));

    II := SubAlgebraModule(P[1], Y1);

    rtGBofN := RightGroebnerBasisOfModule(N);
#    rtGBofN := RightGroebnerBasisOfModule(R, Concatenation(X1,Y1));
#Print("Right Groebner Basis of Module N: ",BasisVectors(rtGBofN),"\n");

    rtGBofII := RightGroebnerBasisOfModule(II);

    # Determine f1's and f1primes:
    f := [];
    fprime := [];
    f[1] := [];
    fprime[1] := [];
    i := 1;
    j := 1;
    for el in BasisVectors(rtGBofN) do
      tmp := CompletelyReduce(rtGBofII,el);
      if IsZero(tmp) then
        fprime[1][i] := el;
        i := i + 1;
      else
        f[1][j] := el;
        j := j + 1;
      fi;
    od;

#Print( "f[1]: ", f[1], "\n");
#Print( "fprime[1]: ", fprime[1], "\n");

    # Sort the f1's, largest Tip first:
    Sort(f[1],\<);
    f[1] := Reversed(f[1]);

    # Since all f1's should be right uniform, get the vertices for the vertex projective P[2]:
    lverts := [];
    for el in f[1] do
      if IsRightUniform(el![1]) then
        Add(lverts,TargetVertex(el![1]));
      else
        Error("The f1's are not right uniform. \n");
      fi;
    od;

    # Convert vertex set from 'lverts', create P^2 and L^2:
    rverts := List(lverts, x -> x*One(R));
    P[2] := RightProjectiveModule( R, rverts );

    lverts := List(lverts, x -> x*One(A));
    L[2] := RightProjectiveModule( A, lverts );


## form f2's if necessary:  NEED TO CHECK FOR NONEMPTY SET

    # create f2's:
    f[2] := [];
    maps[2] := [];
    i := 1;

    # Determine the OSet and NSet for our f2's:
    for el in f[1] do
      XSet := XSetOfPathAlgebraVector(P[1], I, el![1]);
#Print("XSet: ",XSet,"\n");
      for el2 in XSet[1] do
        tmp := el![1]^el2[2] - el2[1]![1];

        # we can build the map here:

        if not IsZero(tmp) then
#Print("firstpart: ",FirstPart(f[1],tmp),"\n");
#Print("\ttmp: ",tmp,"\n");
          maps[2][i] := FirstPart(f[1],tmp);
          f[2][i] := tmp;
          i := i + 1;
        fi;
      od;
    od;


    # Since all f2's should be right uniform, get the vertices for the vertex projective P[3]:
    lverts := [];
    for el in f[2] do
      if IsRightUniform(el) then
        Add(lverts,TargetVertex(el));
      else
        Error("The f1's are not right uniform. \n");
      fi;
    od;

    # Convert vertex set from 'lverts', create P^3:
    rverts := List(lverts, x -> x*One(R));
    P[3] := RightProjectiveModule( R, rverts );

    # Hmmm...
    lverts := List(lverts, x -> x*One(A));
    L[3] := RightProjectiveModule( A, lverts );


## START REPEATING HERE

    for k in [3..termint] do
      f[k] := [];
      maps[k] := [];
      i := 1;

      ###  NEED to Vectorize elements in maps[k-1]:
      mapstmp := List( maps[k-1], x -> Vectorize(P[k-1], x) );

      for el in maps[k-1] do
        XSet := XSetOfPathAlgebraVector(P[k-1], I,Vectorize(P[k-1], el)![1]);
#        Print("XSet: ",XSet,"\n"); 

        for el2 in XSet[1] do
          tmp := Vectorize(P[k-1],el)![1]^el2[2] - el2[1]![1];
#          Print("\ttmp: ",tmp,"\n");
          if not IsZero(tmp) then
#            Print("firstpart: ",FirstPart(mapstmp,tmp),"\n");
            maps[k][i] := FirstPart(mapstmp,tmp);
            f[k][i] := tmp;
            i := i + 1;
          fi;
        od;
      od;

      if Length(maps[k]) < 1 then
        Print("finite at projective: ",k,"\n");
        break;
      else
        # create vertex projectives

        # Since all f2's should be right uniform, get the vertices for the vertex projective P[3]:
        lverts := [];
        for el in f[k] do
          if IsRightUniform(el) then
            Add(lverts,TargetVertex(el));
          else
            Error("The f",k,"'s are not right uniform. \n");
          fi;
        od;

        # Convert vertex set from 'lverts', create P^(k+1):
        rverts := List(lverts, x -> x*One(R));
        P[k+1] := RightProjectiveModule( R, rverts );

        lverts := List(lverts, x -> x*One(A));
        L[k+1] := RightProjectiveModule( A, lverts );
      fi;
    od;

#   
#   
#    # Form quotient module:
##    M :=  P[1]/N;
#   
#   Create the (initial) resolution:

    Res := Objectify(NewType(ProjectiveResolutionFpPathAlgebraModuleFamily,
                             IsProjectiveResolutionFpPathAlgebraModuleDefaultRep),
                             rec());
    SetName(Res,"ProjectiveResolutionFpPathAlgebraModule");
    SetParentAlgebra(Res,A);
##    SetModule(Res,M);
    SetProjectives(Res,L);
    SetRProjectives(Res,P);
    SetMaps(Res,maps);
    SetProjectivesFList(Res,f);
    SetRingIdeal(Res,I);

    return Res;
          
  end     
);   


InstallMethod( ProjectiveResolutionFpPathAlgebraModule,
  "for algebras",
  true,
  [ IsAlgebra, IsRing and HasGroebnerBasisOfIdeal, IsRingElementTable ], 0,
  function(A,I,presentation_map)
    local Res, gen, len, verts, gVerts, rverts, paverts, lverts, RelementsFam, el, el2,
          f, fprime, i, j, tmp, L, P, N, M, R, X1, Y1, G, rtG, rtGBofN, maps, Mzero,
          II, rtGBofII, XSet, perm, mapstmp;

    # R-projectives:
    P := [];

    # R/I-projectives:
    L := [];

    # f list:
    f := [];

    # resolution maps:
    maps := [];

    if not (IsPathAlgebra(A) or IsQuotientOfPathAlgebra(A)) then
        TryNextMethod();
    fi;

    # Make sure generators are not empty
    if IsEmpty(presentation_map) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " <presentation_map> must be nonempty.");
    fi;

    # Make sure all entries are left uniform
    for gen in presentation_map do
      if not ForAll(gen, IsLeftUniform) then
        Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
              " entries in <presentation_map> must be left uniform.");
      fi;
    od;

    # Get the starting vertex of each element in first row:
    #  (These vertices will allow us to form L^0, the first right projective
    #   module in the projective resolution).
    verts := List(presentation_map[1], x -> SourceVertex(LeadingMonomial(x)));

    # Verify we really have proper presentation:
    for gen in presentation_map do
      gVerts := List(gen, x -> SourceVertex(LeadingMonomial(x)));

      for i in [1..Length(verts)] do
        if IsZeroPath(verts[i]) and not IsZeroPath(gVerts[i]) then
          verts[i] := gVerts[i];
        elif verts[i] <> gVerts[i] and not IsZeroPath(gVerts[i]) then
          Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
                " <presentation_map> contains mismatched starting vertices.");
        fi;
      od;
    od;

    # Check columns are non-zero:
    if not ForAll(verts, x -> not IsZeroPath(x)) then
      Error("Usage: ProjectiveResolutionFpPathAlgebraModule( <A>, <I>, <presentation_map> )",
            " <presentation_map> contains all zeroes in some column.");
    fi;

    # Get the parent ring R for ideal I (where above A = R/I):
    R := LeftActingRingOfIdeal(I);

    # Get right groebner basis for ideal:
    rtG := RightGroebnerBasis(I);
#Print("rtG: ",rtG!.relations,"\n");

    # Get family for ring:
    RelementsFam := ElementsFamily(FamilyObj(R));

    # Create vertex set (all in the path algebra) from 'verts':
#Print("verts: ",verts,"\n");
    paverts := List(verts, x -> x*One(A));
#Print("paverts: ",paverts,"\n");

    # Create vertex set (all in the ring) from 'verts':
    rverts := List(verts, x -> x*One(R));
#Print("rverts: ", rverts,"\n");

    # Ok, everything is good, construct the module L^0 from vertices in first row:
#    L[1] := RightProjectiveModule( A, paverts );
    P[1] := RightProjectiveModule( R, rverts );


    # Convert elements in map from elements in R/I to elements in R:
    X1 := [];
    i := 1;
    for i in [1..Length(presentation_map)] do
      X1[i] := List(presentation_map[i], x -> ObjByExtRep(RelementsFam,ExtRepOfObj(x))); 
    od;
#Print("X1 (prevectors): ",X1,"\n");

    # first map:
    maps[1] := ShallowCopy(X1);

    X1 := List( X1, x -> Vectorize(P[1], x) );
#Print("X1: ",X1,"\n");

    # Create set Y1 to union with X1 for the lift:
    Y1 := [];
    for i in [1..Length(rverts)] do
      for el in rtG!.relations do
        if not IsZero(rverts[i]*el) then
          tmp := List([1..Length(rverts)], x->Zero(R));
          tmp[i] := rverts[i]*el;
          Add(Y1,tmp);
        fi;
      od;
    od;    

#Print("Y1 (prevectors): ",Y1,"\n");
# We no longer want to vectorize:
    Y1 := List( Y1, x -> Vectorize(P[1], x) );
#Print("Y1: ",Y1,"\n");

#Print("X1 Union Y1: ",Concatenation(X1,Y1),"\n");

# At this point we need two things:
#  1) Possibly a new list object with ordering and operations (like module stuff)
#  2) right groebner basis (reduction) of such list objects (under an order?)

    # Determine the submodule of the algebra module P[1] generated by the elements
    #  of X1 union Y1 (which are the rows of the presentation_map).
    N := SubAlgebraModule(P[1], Concatenation(X1,Y1));

    II := SubAlgebraModule(P[1], Y1);

    rtGBofN := RightGroebnerBasisOfModule(N);
#    rtGBofN := RightGroebnerBasisOfModule(R, Concatenation(X1,Y1));
#Print("Right Groebner Basis of Module N: ",BasisVectors(rtGBofN),"\n");

    rtGBofII := RightGroebnerBasisOfModule(II);
#Print("Right Groebner Basis of Module II: ",BasisVectors(rtGBofII),"\n\n");

    # Determine f1's and f1primes:
    f := [];
    fprime := [];
    f[1] := [];
    fprime[1] := [];
    i := 1;
    j := 1;
    for el in BasisVectors(rtGBofN) do
      tmp := CompletelyReduce(rtGBofII,el);
      if IsZero(tmp) then
        fprime[1][i] := el;
        i := i + 1;
      else
        f[1][j] := el;
        j := j + 1;
      fi;
    od;

#Print( "f[1]: ", f[1], "\n");
#Print( "fprime[1]: ", fprime[1], "\n");

    # Sort the f1's, largest Tip first:
    Sort(f[1],\<);
    f[1] := Reversed(f[1]);

    # Since all f1's should be right uniform, get the vertices for the vertex projective P[2]:
    lverts := [];
    for el in f[1] do
#Print("el![1]: ",el![1],"\n");
      if IsRightUniform(el![1]) then
#Print("target vertex: ", TargetVertex(el![1]),"\n");
        Add(lverts,TargetVertex(el![1]));
      else
        Error("The f1's are not right uniform. \n");
      fi;
    od;

#Print("lverts: ",lverts,"\n");

    # Convert vertex set from 'lverts', create P^2:
    rverts := List(lverts, x -> x*One(R)); 
    P[2] := RightProjectiveModule( R, rverts );

    # Hmmm...
    lverts := List(lverts, x -> x*One(A)); 
    L[2] := RightProjectiveModule( A, lverts );


    # create f2's:
    f[2] := [];
    maps[2] := [];
    i := 1;

#    # Determine the OSet and NSet for our f1's:
    for el in f[1] do
#Print("el: ",el,"\n");
##Print(IsRing(I), " ",HasGroebnerBasisOfIdeal(I),"\n");
##Print("el IsPathAlgebraVector: ",IsPathAlgebraVector(el),"\n");
##Print("el![1] IsPathAlgebraVector: ",IsPathAlgebraVector(el![1]),"\n");
      XSet := XSetOfPathAlgebraVector(P[1], I, el![1]);
#Print("XSet: ",XSet,"\n");
      for el2 in XSet[1] do
#Print("el2: ",el2,"\n");
##Print("el2 IsPathAlgebraVector: ",IsPathAlgebraVector(el2),"\n");
##Print("el2![1] IsPathAlgebraVector: ",IsPathAlgebraVector(el2![1]),"\n");
##        if not IsZero(el2[1]) then
##          tmp := el![1]^el2[2] - TipReduce(List(f[1],x -> x![1]), el2[1]![1]); 
        tmp := el![1]^el2[2] - el2[1]![1]; 

        # we can build the map here:
        
        if not IsZero(tmp) then
#Print("firstpart: ",FirstPart(f[1],tmp),"\n");
#Print("\ttmp: ",tmp,"\n");
          maps[2][i] := FirstPart(f[1],tmp);
          f[2][i] := tmp;
          i := i + 1;
        fi; 
##        fi;
      od;
    od;


    # Since all f1's should be right uniform, get the vertices for the vertex projective P[3]:
    lverts := [];
    for el in f[2] do
#Print("el![1]: ",el![1],"\n");
      if IsRightUniform(el) then
#Print("target vertex: ", TargetVertex(el![1]),"\n");
        Add(lverts,TargetVertex(el));
      else
        Error("The f1's are not right uniform. \n");
      fi;
    od;

#Print("lverts: ",lverts,"\n");

    # Convert vertex set from 'lverts', create P^3:
    rverts := List(lverts, x -> x*One(R)); 
    P[3] := RightProjectiveModule( R, rverts );

    # Hmmm...
    lverts := List(lverts, x -> x*One(A)); 
    L[3] := RightProjectiveModule( A, lverts );



    # Now, do it all again, create f3's:
    f[3] := [];
    maps[3] := [];
    i := 1;

    ###  NEED to Vectorize elements in maps[2]:
    mapstmp := List( maps[2], x -> Vectorize(P[2], x) );

    for el in maps[2] do
      XSet := XSetOfPathAlgebraVector(P[2], I,Vectorize(P[2], el)![1]);

Print("XSet: ",XSet,"\n");

      for el2 in XSet[1] do
        tmp := Vectorize(P[2],el)![1]^el2[2] - el2[1]![1]; 
#Print("\ttmp: ",tmp,"\n");
        if not IsZero(tmp) then
#Print("firstpart: ",FirstPart(mapstmp,tmp),"\n");

          maps[3][i] := FirstPart(mapstmp,tmp);
          f[3][i] := tmp;
          i := i + 1;
        fi; 
      od;
    od;


    # create f4's:
    f[4] := [];
    maps[4] := [];
    i := 1;

    ###  NEED to Vectorize elements in maps[3]:
    mapstmp := List( maps[3], x -> Vectorize(P[3], x) );

   for el in maps[3] do
      XSet := XSetOfPathAlgebraVector(P[3], I,Vectorize(P[3], el)![1]);

Print("XSet: ",XSet,"\n");

      for el2 in XSet[1] do
        tmp := Vectorize(P[3],el)![1]^el2[2] - el2[1]![1]; 
Print("\ttmp: ",tmp,"\n");
        if not IsZero(tmp) then
Print("firstpart: ",FirstPart(mapstmp,tmp),"\n");

          maps[4][i] := FirstPart(mapstmp,tmp);
          f[4][i] := tmp;
          i := i + 1;
        fi; 
      od;
    od;


#
#
#    # Form quotient module:
##    M :=  P[1]/N;
#
#    # Create the (initial) resolution:
    Res := Objectify(NewType(ProjectiveResolutionFpPathAlgebraModuleFamily,
                             IsProjectiveResolutionFpPathAlgebraModuleDefaultRep),
                             rec());
    SetName(Res,"ProjectiveResolutionFpPathAlgebraModule");
    SetParentAlgebra(Res,A);
##    SetModule(Res,M);
    SetProjectives(Res,L);
    SetRProjectives(Res,P);
    SetMaps(Res,maps);
    SetProjectivesFList(Res,f);
    SetRingIdeal(Res,I);

    return Res;

  end
);


# Two lists returned, list 1 is OSet, list 2 is NSet.
# OSet is a list of elements, each of which is a list of the form:
#   [ ??? ]
InstallMethod( XSetOfPathAlgebraVector,
  "for path algebra vectors",
  true, 
  [ IsVertexProjectiveModule,
    IsRing and HasGroebnerBasisOfIdeal,
    IsPathAlgebraVector ],
  0,
  function( P, I, el )
    local a, path, fam, t, OSet, NSet, XSet, outarrows, nonzeroflag, tippath, tippathlen,
          tipcoeff, gbel, tmpel,
          gbeltip, gbeltipcoeff, productwalk, gbtipwalk, YSet, Yflag, GB, p, pwalk, qwalk,
          qprime, gbellen, qprimewalk, qlen;

    # Initialize our N and O sets:
    OSet := [];
    NSet := [];
    XSet := [];
    YSet := [];
    outarrows := [];

    # tippath of el:
    tippath := TipMonomial(el![1][el![2]]);
    tipcoeff := TipCoefficient(el![1][el![2]]);
    tippathlen := Length(ExtRepOfObj(tippath));
# Print("tipext: ",ExtRepOfObj(tippath),"\n");
    XSet := [ tippath ];

    # Get Groebner basis:
    GB := GroebnerBasisOfIdeal(I);
#Print("tippath: ", tippath,"\n");

# Print("GB: ", GB!.relations,"\n");

    fam := FamilyObj(el![1][el![2]]);

    # create a tuple that should work in the module:
#    elzero := List([1..Length(el![1])], x -> Zero(el![1][el![2]]));

    # calculate all paths starting with el until all successive are nonzero:
    nonzeroflag := true;

    while nonzeroflag do

      nonzeroflag := false;

      for path in XSet do

        # Get target vertex, then outgoing arrows, of tippath of given pa module vector:
        t := TargetOfPath(path); 
        outarrows := OutgoingArrowsOfVertex(t);
        # translate arrows to paths:
        outarrows := List(outarrows, x->ElementOfMagmaRing(fam,fam!.zeroRing,[One(fam!.zeroRing)],[x]));

        # We only examine paths that are properly larger than el: 
        for a in outarrows do 

          Yflag := true;

          # Assert: all products path*a should be nonzero here since
          #         using only outgoing arrows from path.
          for gbel in GB!.relations do
              gbeltip := TipMonomial(gbel);
              gbeltipcoeff := TipCoefficient(gbel);
              gbtipwalk := WalkOfPath(gbeltip);
              productwalk := WalkOfPath(TipMonomial(path*a));
#Print("productwalk: ", productwalk, ", gbtipwalk: ", gbtipwalk, "\n");
#Print("product: ", path, " * ", a, " = ", path*a, "\n");
              if (PositionSublist(Reversed(productwalk),Reversed(gbtipwalk)) = 1) then

#Print("\t gbeltip ", gbeltip, " right divides ", path*a, "\n");
#Print("\t\tlength of ",tippath, " = ", Length(WalkOfPath(tippath)),"\n");
#Print("\t\tlength of ",gbeltip, " = ", Length(WalkOfPath(gbeltip)),"\n");
#Print("\t\tlength of ",path*a, " = ", Length(WalkOfPath(path))+1,"\n");

                # Determine if OSet element or NSet:
                if (tippathlen + Length(WalkOfPath(gbeltip))) <= (Length(WalkOfPath(path))+1) then
                  if (tippathlen+Length(WalkOfPath(gbeltip))) = (Length(WalkOfPath(path))+1) then
                    Add(NSet, [path*a, One(path*a), gbel]);
                  else
                    qwalk := ExtRepOfObj(path*a);
                    qlen := Length(qwalk[2][1]);
                    gbellen := Length(gbtipwalk);
                    qwalk := [qwalk[1],[ qwalk[2][1]{[tippathlen+1..(qlen-gbellen)]}, qwalk[2][2]]];

                    Add(NSet, [path*a, One(path*a), gbel]);
                  fi;
                else

                  # create external rep of, and then element that is subpath in path*a after tippath.
                  qwalk := ExtRepOfObj(path*a);
                  qlen := Length(qwalk[2][1]);
                  pwalk := [qwalk[1],[ qwalk[2][1]{[tippathlen+1..qlen]}, qwalk[2][2]]];
                  p := ObjByExtRep(fam,pwalk);

# Print("\t\t\tpwalk: ",pwalk,"\n");
# Print("\t\t\tp: ",p,"\n");

                  # create external rep of, and then element that is subpath in path*a before gbeltip.
                  gbellen := Length(gbtipwalk);

                  # If tip gbel is equal to path*a, no (prefix) subpath qprime:
                  if gbellen = qlen then

                    # create element in module to use for the module 'syzygy':
                    tmpel := ShallowCopy(Zero(P)![1]![1]);
                    tmpel[el![2]] := (tipcoeff/gbeltipcoeff)*gbel;

#Print("\t\t\tsyzygy: ",el![1]*p-tmpel,"\n");
                    Add(OSet, [Vectorize(P,el![1]*p-tmpel),p]);

                  else

                    qprimewalk := [qwalk[1],[ qwalk[2][1]{[1..(qlen-gbellen)]}, qwalk[2][2]]];
                    qprime := ObjByExtRep(fam,qprimewalk);
#Print("\t\t\tqprimewalk: ",qprimewalk,"\n");
#Print("\t\t\tqprime: ",qprime,"\n");
                    # create element in module to use for the module 'syzygy':
                    tmpel := ShallowCopy(Zero(P)![1]![1]);
#Print("\t\t\ttmpel[el![2]]: ",tmpel[el![2]],"\n");
#Print("\t\t\tqprime: ",qprime,"\n");
                    tmpel[el![2]] := (tipcoeff/gbeltipcoeff)*qprime*gbel;

#Print("\t\t\tsyzygy: ",el![1]*p-tmpel,"\n");
                    # Only include nonzero elements:
                    if not IsZero(el![1]*p-tmpel) then
                      Add(OSet, [Vectorize(P,el![1]*p-tmpel),p]);
                    fi;
                  fi;

                fi;
              
                Yflag := false;
                break;
              fi;
          od;

          if Yflag then
            Add(YSet, TipMonomial(path*a));
          fi;

        od;   # outgoing arrows loop.

      od;     # paths in XSet loop.

      if (Length(YSet) > 0) then
        nonzeroflag := true;
        XSet := ShallowCopy(YSet);
        YSet := [];
      fi;

    od;

#Print("YSet: ", YSet,"\n");

    return [OSet,NSet];

  end
);


InstallMethod( TipReduce,
  "tip reduce set of elements from path algebra module",
  true, 
  [IsHomogeneousList], 0,
  function( M )
    local i, j, H, Hlen, reducible, redset;

    if ( not IsRightAlgebraModuleElementCollection(M) ) then
      TryNextMethod();
    fi;

    H := List(M, ExtRepOfObj );

    # Tip reduce H to create a Right Groebner Basis:
    reducible := true;
    while reducible do

      # remove zeros:
      H := Filtered(H, x -> not IsZero(x));

      reducible := false;

      Hlen := Length(H);

      for i in [1..Hlen] do
        redset := Difference([1..Hlen],[i]);
        for j in redset do
          # if H[j] divides H[i]:
          if IsLeftDivisible(H[i], H[j]) then
            H[i] := ReduceRightModuleElement( H[i], H[j] );
            reducible := true;
            break;
          fi;
        od;
        if reducible then
          break;
        fi;
      od;

    od;

    return H;

  end
);


InstallMethod( TipReduce,
  "tip reduce path algebra vector by set of path algebra vectors",
  true, 
  [IsHomogeneousList, IsPathAlgebraVector], 0,
  function( H, el )
    local i, reducible, rlen, redset;

    # Tip reduce el to by set redset:
    reducible := true;

    # Convert reducing set to pathalgebavectors
    redset := List(H, ExtRepOfObj );
 
    while reducible and (not IsZero(el)) do

      reducible := false;

      i := 1;
      rlen := Length(redset);
      while i <= rlen do

#Print("\t",i," el:", el,"\n");
        # if redset[i] divides el:
        if IsLeftDivisible(el, redset[i]) then
#Print("\t\thit\n");
          el := ReduceRightModuleElement( el, redset[i] );
          reducible := true;
          break;
        else
          i := i + 1;    
        fi;
      od;
    od;

    return el;

  end
);



# ORDER IS GOING TO MATTER HERE:

# returns a list of algebra elements:
InstallMethod( FirstPart,
  "writes a module element as a finite sum of given module elements",
  true, 
  [IsHomogeneousList, IsPathAlgebraVector], 0,
  function( f, v )
    local i, retvec, fam, flen, tmp, div;

    flen := Length(f);
    fam := FamilyObj(v![1][v![2]]);
    retvec := ListWithIdenticalEntries( flen, Zero(v![1][v![2]]) );

#Print("v: ",v,"\n");

    tmp := ShallowCopy(v);

    for i in [1..flen] do
      # Tip divide tmp by element f[i]:
#Print("f[i]![1]: ",f[i]![1],"\n");
#Print("tmp: ",tmp,"\n");
      if (not IsZero(tmp)) and (not IsZero(f[i]![1])) then
        div := LeftDivision(tmp, f[i]![1]); 
        if (not (div = false)) then
          retvec[i] := div;
          tmp := tmp - f[i]![1]^div;
        fi;
      fi;
    od;

#Print("retvec: ",retvec,"\n");
    return retvec;
  end
);


# operation that returns right factor if y divides x.
InstallMethod( LeftDivision,
  "for path algebra vectors",
  true,
  [ IsPathAlgebraVector,
    IsPathAlgebraVector], 0,
  function( x, y )
    local xTipPos, xLeadingTerm, xCoeff, xMon, xWalk,
          yTipPos, yLeadingTerm, yCoeff, yMon, yWalk,
          fam, rightfactor, rfrep, xrep;

    if (IsZero(x) or IsZero(y)) then
      Error("don't send me zeroes, please.\n");
    else
      fam := FamilyObj(x![1][x![2]]);


      rightfactor := One(x![1][x![2]]);

      # Word to be divided:
      xTipPos := x![2];
#Print("tipcoord: ",x![2],"\n");
#Print("LeadingTerm: ",LeadingTerm(x),"\n");
      xLeadingTerm := LeadingTerm(x)![1][xTipPos];
      xMon := TipMonomial(xLeadingTerm);
      xCoeff := TipCoefficient(xLeadingTerm);
#Print("xMon: ",xMon,"\n");
      xWalk := WalkOfPath(xMon);

      # Dividing word:
      yTipPos := y![2];
      yLeadingTerm := LeadingTerm(y)![1][yTipPos];
      yMon := TipMonomial(yLeadingTerm);
      yCoeff := TipCoefficient(yLeadingTerm);
      yWalk := WalkOfPath(yMon);

      if ((xTipPos = yTipPos) and (PositionSublist(xWalk, yWalk) = 1)) then
        # Create right factor:
        if ( Length(yWalk) <> Length(xWalk) ) then
          xrep := ExtRepOfObj(xLeadingTerm);
#Print("xrep: ",xrep,"\n");
#Print("xCoeff: ",xCoeff,"\n");
#Print("yCoeff: ",yCoeff,"\n");

          # Note: creating the external rep of object here, complete with
          #       appropriate coefficient:
          #          xCoeff == (xCoeff/yCoeff)*yCoeff.
          rfrep := [xrep[1],[ xrep[2][1]{[(Length(yWalk)+1)..Length(xWalk)]}, xCoeff]];
          rightfactor := ObjByExtRep(fam,rfrep);
#          rightfactor := (xCoeff/yCoeff)*rightfactor;
        else
#Print(TargetVertex(xMon),"\n");
          rightfactor := (xCoeff/yCoeff)*One(x![1][x![2]])*TargetVertex(xMon);
#          rightfactor := (xCoeff/yCoeff)*rightfactor;
        fi;

      else
        return false;
      fi;

#Print("rightfactor: ",rightfactor,"\n");
      return rightfactor;
    fi;

  end
);


