# Examples in QPA.

# Example 0:
q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],["v","u","c"],["v","v","d"]]);
f := Rationals;
fq := PathAlgebra(f,q);
quiv := QuiverOfPathAlgebra(fq);
g := GeneratorsOfQuiver(quiv);

# Notice that elements in the quiver are *NOT* elements
#  in the path algebra:
g[1] in fq;

# So, we need to count vertices (or arrows) in order to
#  determine what's what in the generator list for
#  the path algebra.

# Get number vertices in quiver:
OrderOfQuiver(q);
# Get number arrows in quiver:
SizeOfQuiver(q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
a := gens[3];
b := gens[4];
c := gens[5];
d := gens[6];

# Get ordering on algebra:
OrderingOfAlgebra(fq);

# Glue practice:
polys := [a*b*c-c,a*b];
GBNPGroebnerBasis(polys,fq);


# Change ordering on same quiver, and create new algebra:
q2 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],["v","u","c"],["v","v","d"]]);
a := ArrowsOfQuiver(q2)[1];
b := ArrowsOfQuiver(q2)[2];
f := FiniteField(23);
fq2 := PathAlgebra(f,q2);
leftlex := LeftLexicographicOrdering(q2,[b,a]);
OrderingOfAlgebra(fq2);
LessThanByOrdering(leftlex,a,b);
leftlex2 := LeftLexicographicOrdering(q2,[a,b]);
LessThanByOrdering(leftlex2,a,b);

IsFiniteDimensional(fq2);

# Doesn't work:
weight := WeightOrdering(q,[[a,2],[b,3]],leftlex);
LessThanByOrdering(weight,a,b);

I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);
igens := GeneratorsOfIdeal(I);
quot := fq/I;


#####
#
# Example 1:  Free Algebra:
#
# (Example 9 from GBNP-0.9.3:)
# # Input is {aba-b,bab-b}
# # The answer should be {bb-ab,ba-ab,aab-b}

q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
g := GeneratorsOfAlgebra(pa);
u := g[1];
a := g[2];
b := g[3];
id := One(pa);

polys := [a*b*a-b,b*a*b-b];
I := Ideal(pa,polys);

gbgens := GBNPGroebnerBasis(polys,pa);
gb := GroebnerBasis(I,gbgens);

# (*) Exploring properties here:
HasIsCompleteGroebnerBasis(gb);
SetIsCompleteGroebnerBasis(gb,true);
IsCompleteGroebnerBasis(gb);
HasIsCompleteGroebnerBasis(gb);
IsGroebnerBasis(gb);

# (**) Note: the following is dependent on (*) above:
HasIsTipReducedGroebnerBasis(gb);
TipReduceGroebnerBasis(gb);
IsTipReducedGroebnerBasis(gb);
HasIsTipReducedGroebnerBasis(gb);

# Note: the following is dependent on (*),(**) above:
HasIsCompletelyReducedGroebnerBasis(gb);
CompletelyReduceGroebnerBasis(gb);
IsCompletelyReducedGroebnerBasis(gb);
HasIsCompletelyReducedGroebnerBasis(gb);

quot := pa/I;

res := QPA_Path2Cohen(polys);
res2 := QPA_Cohen2Path(res,pa);
#
#####


#####
#
# Example from p. 26 Keller's thesis:
#
q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];
v := gens[2];
c := gens[3];
b := gens[4];
a := gens[5];
id := One(pa);

polys := [a*b*c+b*a*b+a+c];
gb := GBNPGroebnerBasis(polys,pa);
#
#####


#####
#
# Keller, p. 50
# example, mesh algebra:
q := Quiver(["t","u","v","w"], [
            ["u","t","a"],["t","u","b"],
            ["v","t","c"],["t","v","d"],
            ["w","t","e"],["t","w","f"]   ]);
pa := PathAlgebra(Rationals,q);

gens := GeneratorsOfAlgebra(pa);
t := gens[1];; u := gens[2];;
v := gens[3];; w := gens[4];;
a := gens[5];; b := gens[6];;
c := gens[7];; d := gens[8];;
e := gens[9];; f := gens[10];;
id := One(pa);;
polys := [ a*b + c*d + e*f, b*a, d*c, f*e ];
gb := GBNPGroebnerBasis(polys,pa);

polys2 := [a*d*c*f+u,c*f*e*b-v];
gb := GBNPGroebnerBasis(polys2,pa);
gb := GBNPGroebnerBasisNC(polys2,pa);

# Show our created relations for:
PrintNPList(QPA_RelationsForPathAlgebra(pa));
#
#####


#####
#
# Example 1 from GBNP-0.9.3:
# Run the commutative example {xy-yx,x^2y-1,xy^2-1}
# The answer should be {x^3-1,x-y}
#
q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
f := Rationals;
fq := PathAlgebra(f,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
u := gens[1];
x := gens[2];
y := gens[3];
id := One(fq);

polys := [x*y-y*x,x^2*y-id,x*y^2-id];

res := QPA_Path2Cohen(polys);
# This is format conversion routine that is used
# in our special free algebra case:
res := QPA_Path2CohenFree(polys);

res2 := QPA_Cohen2Path(res,fq);
gb := GBNPGroebnerBasis(polys,fq);
gb := GBNPGroebnerBasisNC(polys,fq);

# Cohen's results:
KI := [ [[[1,2],[2,1]],[1,-1]]   ];
x2y := [[[1,1,2],[]],[1,-1]];
  AddSet(KI,x2y);
xy2 := [[[1,2,2],[]],[1,-1]];
  AddSet(KI,xy2);
PrintNPList(KI);
GB := SGrobner(KI);

# NOTE: the results from this make sense (u == One(fq)):
QPA_Cohen2Path(GB,fq);
#
#####


#####
#
#
# # Example 6 from GBNP-0.9.3:
# a commutative example from Tapas book, page 339
# reference: Some Tapas of Computer Algebra
# #eds. A.M. Cohen, H. Cuypers, H. Sterk
# #Springer, 1999
# #the result should be {a,b} union {6 relations forcing commuting between
# c,d,e,f}
#
q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
                   ["u","u","d"],["u","u","e"],["u","u","f"]]);
fq := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
d := gens[5];; e := gens[6];; f := gens[7];;

polys := [ e*a, a^3 + f*a, a^9 + c*a^3, a^81 + c*a^9 + d*a^3,
           a^27 + d*a^81 + e*a^9 + f*a^3, b + c*a^27 + e*a^81 + f*a^9,
           c*b + d*a^27 + f*a^81, a + d*b + e*a^27, c*a + e*b + f*a^27,
           d*a + f*b, b^3 - b, a*b - b*a, a*c - c*a,
           a*d - d*a, a*e - e*a, a*f - f*a, b*c - c*b,
           b*d - d*b, b*e - e*b, b*f - f*b, c*d - d*c,
           c*e - e*c, c*f - f*c, d*e - e*d, d*f - f*d, e*f - f*e 
];;
gb := GBNPGroebnerBasis(polys,fq);
#
#####


#####
#
# Example 7 from GBNP-0.9.3:
#
q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
                   ["u","u","d"],["u","u","e"],["u","u","f"]]);
fq := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
d := gens[5];; e := gens[6];; f := gens[7];; id := One(fq);
polys := [
d - (11/7)*a^2 - 11*a + 11/7*id,
e - (11/7)*b^2 - 11*b + 11/7*id,
f - (11/7)*c^2 - 11*c + 11/7*id,
a*b*a - b*a*b, b*c*b - c*b*c, a*c - c*a,
a*d - (1/11)*d, b*e - (1/11)*e, c*f - (1/11)*f,
d*b*d - 11*d, e*a*e - 11*e, e*c*e - 11*e, f*b*f - 11*f,
d*e*d - d, e*d*e - e, e*f*e - e, f*e*f - f
];;

gb := GBNPGroebnerBasis(polys,fq);
gb := GBNPGroebnerBasisNC(polys,fq);
#
#####


#####
#
# Example 8 from GBNP-0.8.3:
#
q := Quiver(["u"],[["u","u","a"],["u","u","b"],
                   ["u","u","c"],["u","u","d"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
d := gens[5];; id := One(pa);

polys := [
c - (3/2)*a^2 - 3*a + (3/2)*id, d - (3/2)*b^2 - 3*b + (3/2)*id,
a*b*a - b*a*b, a*c - (1/3)*c, b*d - (1/3)*d, c*b*c - 3*c,
d*a*d - 3*d, c*d*c - c, d*c*d - d,
];;
gb := GBNPGroebnerBasis(polys,pa);
gb := GBNPGroebnerBasisNC(polys,pa);
#
#
#####



#####
#
# Example 10 from GBNP-0.9.3:
#
q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
                   ["u","u","d"],["u","u","e"],["u","u","f"],
		   ["u","u","g"]]);
pa := PathAlgebra(GF(23),q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
d := gens[5];; e := gens[6];; f := gens[7];; g := gens[8];;

polys := [
a^3 + f*a, a^9 + c*a^3 + g*a, a^81 + c*a^9 + d*a^3,
c*a^81 + d*a^9 + e*a^3, a^27 + d*a^81 + e*a^9 + f*a^3,
b + c*a^27 + e*a^81 + f*a^9 + g*a^3, c*b + d*a^27 + f*a^81 + g*a^9,
a + d*b + e*a^27 + g*a^81, c*a + e*b + f*a^27, d*a + f*b + g*a^27,
e*a + g*b, b^3 - b, a*b - b*a, a*c - c*a, a*d - d*a,
a*e - e*a, a*f - f*a, a*g - g*a, b*c - c*b, b*d - d*b,
b*e - e*b, b*f - f*b, b*g - g*b, c*d - d*c, c*e - e*c,
c*f - f*c, c*g - g*c, d*e - e*d, d*f - f*d, d*g - g*d,
e*f - f*e, e*g - g*e, f*g - g*f
];;
gb := GBNPGroebnerBasis(polys,pa);
gb := GBNPGroebnerBasisNC(polys,pa);
#
#
#####


#####
#
# Dr. Green's NC Groebner Paper(ex. 2.7):
#
q := Quiver(["u"],[["u","u","a"],["u","u","b"],
                   ["u","u","c"],["u","u","d"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
d := gens[5];; id := One(pa);

polys := [c*d*a*b-c*b,b*c-d*a];

# Run standard GBNP, (implied left length-lex ordering, a<b<c<d):
# (Answer should be:  { da - bc, cbcb - cb }
gb := GBNPGroebnerBasis(polys,pa);

# Run patched GBNP with same ordering (forced):
ml := NCMonomialLeftLengthLexOrdering(pa);
PatchGBNP(ml);
gb := GBNPGroebnerBasis(polys,pa);

# Change ordering on generators, patch GBNP, try for answer:
ml2 := NCMonomialLeftLengthLexOrdering(pa,1,5,4,3,2);
PatchGBNP(ml2);
gb2 := GBNPGroebnerBasis(polys,pa);

# Answer should be:
#  bc - da 
#  cdab - cb 
#  dadab - dab 
#  cdada - cda 
#  dadada - dada 

# Now, unpatch GBNP and see if things are okay:
UnpatchGBNP();
gb := GBNPGroebnerBasis(polys,pa);
#
#####


#####
#
# Example taken from pp. 178-9 of Klaus G. Fischer's "Computational Algebra"
#
# (Two vertices u,v; one loop at u, one arrow in each direction connecting
#  u and v).
#
q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
                       ["v","u","c"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; v := gens[2];; a := gens[3];; b := gens[4];;
c := gens[5];; id := One(pa);

polys := [a^3-b*c,b*c*a^2];

# Run standard GBNP, (implied left length-lex ordering, a<b<c):
# (Answer should be:  {a^3-bc, bca-abc, a^2bc, bcbc }
gb := GBNPGroebnerBasis(polys,pa);

# Run patched GBNP with same ordering (forced):
ml := NCMonomialLeftLengthLexOrdering(pa);
PatchGBNP(ml);
gb := GBNPGroebnerBasis(polys,pa);

#
#####


#####
#
# Example from minimal projective resolutions, E. Green, p. 2922, Example 2.1
#
q := Quiver(["u","v","x","y","z"],[["u","v","a"],["v","y","b"],
                                   ["u","x","c"],["x","y","d"],
                                   ["y","z","e"],["y","z","f"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; v := gens[2];; x := gens[3];; y := gens[4];;
z := gens[5];; a := gens[6];; b := gens[7];; c := gens[8];;
d := gens[9];; e := gens[10];; f:= gens[11];; id := One(pa);

polys := [a*b-c*d,b*f,d*e];

# Run standard GBNP, (implied left length-lex ordering, a<b<c):
# (Answer should be:  { }
gb := GBNPGroebnerBasis(polys,pa);

#
#####


#####
##
## Example from Green's "An Algorithmic Approach to Resolutions",
##   Example 2, p. 5
##
##
q := Quiver(["u","v","x","y","z"],[["u","v","a"],["v","y","b"],
                                   ["u","x","c"],["x","y","d"],
                                   ["y","z","e"]]);
pa := PathAlgebra(Rationals,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];; v := gens[2];; x := gens[3];; y := gens[4];;
z := gens[5];; a := gens[6];; b := gens[7];; c := gens[8];;
d := gens[9];; e := gens[10];; id := One(pa);

polys := [a*b-c*d,b*e];

# Run standard GBNP, (implied left length-lex ordering, a<b<c<d<e):
# (Answer should be:  { cd-ab, be }
gb := GBNPGroebnerBasis(polys,pa);

# reorder generators e<d<c<b<a:
# (Answer should be:  { cd-ab, be, cde }
ml := NCMonomialLeftLengthLexOrdering(pa,[10,9,8,7,6,5,4,3,2,1]);
PatchGBNP(ml);

gb2 := GBNPGroebnerBasis(polys,pa);
#
#####




#################################################################
#
#   Important results:
#
###

q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);;
f := Rationals;;
fq := PathAlgebra(f,q);;

# Get generators of path algebra:
# gens := GeneratorsOfAlgebra(fq);
u := gens[1];;
x := gens[2];;
y := gens[3];;

# NOTE: this come out to be the same here:
ExtRepOfObj(u);
ExtRepOfObj(One(fq));

polys := [Zero(fq)];
res := QPA_Path2Cohen(polys);
polys := [One(fq)];
res := QPA_Path2Cohen(polys);
res := QPA_Path2Cohen([u]);

# Answers:
#
# gap> polys := [Zero(fq)];                    
# [ <zero> of ... ]
# gap> res := QPA_Path2Cohen(polys);          
# [ [ [  ], [  ] ] ]
# gap> polys := [One(fq)];           
# [ (1)*u ]
# gap> res := QPA_Path2Cohen(polys);
# [ [ [ [ 1 ] ], [ 1 ] ] ]
# gap> res := QPA_Path2Cohen([u]);
# [ [ [ [ 1 ] ], [ 1 ] ] ]


# Quiver in non-free algebra:
q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],["v","u","c"],["v","v","d"]]);
f := Rationals;
fq := PathAlgebra(f,q);
quiv := QuiverOfPathAlgebra(fq);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
u := gens[1];
v := gens[2];
a := gens[3];
b := gens[4];
c := gens[5];
d := gens[6];
id := One(fq);

ExtRepOfObj(u);
ExtRepOfObj(id);

# Division trials:
w1 := a*a*b*c*b*c;
w2 := c*b;

ExtRepOfObj(w1);


# Finite dimensional example:
q := Quiver(["u","v","w"],[["u","v","a"],["v","w","b"]]);
f := GF(23);
fq := PathAlgebra(f,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(fq);
u := gens[1];
v := gens[2];
w := gens[3];
a := gens[4];
b := gens[5];
id := One(fq);

ExtRepOfObj(u);
ExtRepOfObj(id);

w1 := u*a*v*b*w;
w2 := b;
p  := w1+w2;

# Get some information about the elements:
IsElementOfMagmaRingModuloRelations(w1);
CoefficientsAndMagmaElements(p);
LeadingMonomial(p);
LeadingCoefficient(p);
LeadingTerm(p);

# Get uniformity info:
IsLeftUniform(w1);
IsLeftUniform(p); 
IsRightUniform(w1);
IsRightUniform(p); 
IsUniform(w1);
IsUniform(p); 

# Let's make p into an array of its uniform
#  components:
MakeUniform(w1);
MakeUniform(p);
MakeUniform(p+a);
MakeUniform(p+a+id);

# Try same idea for list of elements (get list of
#  uniform "components" back):
MakeUniform([p+a,id]);                             
MakeUniform([p+a,a,id]);


# Get some information about the path algebra:
Dimension(fq);
IsFiniteDimensional(fq);
basis := Basis(fq);
cbasis := CanonicalBasis(fq);
IsMagmaRingModuloRelations(fq);

# find coefficients for basis rep of element:
p2 := p + u;
Coefficients(cbasis,p2);

# Should be false, since fq not quotient algebra:
IsElementOfFpPathAlgebra(p2);

# Check uniformity of identity element:
#  (Shouldn't be uniform).
p3 := w1 + id;
IsUniform(p); 


# Example for creating path algebra relations to
#  send to GBNP:
q := Quiver(["u","v","w"],[["u","v","a"],["v","w","b"]]);
f := Rationals;
pa := PathAlgebra(f,q);

# Show our created relations for:
PrintNPList(QPA_RelationsForPathAlgebra(pa));


# Another Example for creating path algebra relations to
#  send to GBNP:
q := Quiver(["u","v"],[["u","u","a"],["u","v","b"]]);
f := Rationals;
pa := PathAlgebra(f,q);

# Get generators of path algebra:
gens := GeneratorsOfAlgebra(pa);
u := gens[1];
v := gens[2];
a := gens[3];
b := gens[4];

polys := [a^2-a];

gb := GBNPGroebnerBasis(polys,pa);
gb := GBNPGroebnerBasisNC(polys,pa);

# Show our created relations for:
PrintNPList(QPA_RelationsForPathAlgebra(pa));



#####
#
# RightProjectiveModule example:
#

F:=GF(11);
Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A:=PathAlgebra(F,Q);
P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
Dimension(P);

# fixed... (was) Not working
#####


#####
#
# LeftUniform list
#
Q:=Quiver(["v","w","x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A:=PathAlgebra(Rationals,Q);
l := [A.b+A.a,A.a];
l2 := [A.b,A.c+A.a];
l3 := [A.c,A.c+A.a*A.c,A.a*A.c+A.b*A.c+A.c];
IsRightUniform(l,A.w);
IsRightUniform(l2,A.w);
IsRightUniform(l3,A.x);
IsRightUniform([],A.x);

#
#####


#####
#
# Module over Path Algebra
#

F:=GF(13);
Q:=Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]);
P:=PathAlgebra(F, Q);
matrices:=[["a", RandomMat(2,3,F)], ["b", RandomMat(3,2,F)], ["c", RandomMat(2,2,F)]];
M:=RightModuleOverPathAlgebra(P,matrices);

#
#####


#####
#
# ProjectivePresentation
#
F:=GF(11);
Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A:=PathAlgebra(F,Q);
PS:=VertexProjectivePresentation(A, [[A.b*A.c, A.a*A.c, A.c], [A.a, A.b, A.w]]);
er:=End(A,PS);


#PS:=ProjectivePresentation(A, [[A.b*A.c, A.a], [A.a*A.c,A.b], [A.c,A.w]]);
PS!.ParentAlgebra;
PS!.MatrixRepresentation;
PS!.MatrixNumRows;
PS!.MatrixNumCols;
PS!.P0VertexList;
ParentAlgebra(PS);
MatrixRepresentation(PS);
MatrixNumRows(PS);
MatrixNumCols(PS);
P0VertexList(PS);

IsElementOfPathRing(A.a);
IsElementOfFpPathAlgebra(A.a);
IsElementOfMagmaRingModuloRelations(A.a);

FamilyObj(A.a);
FamilyObj(Q.a);

er:=End(A,PS);
#Basis(PS);

# Not working
#####

# Quotient work:
F := GF(11);
Q := Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[A.b*A.c]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
B := A/I;
B.a*B.b;
PS:=VertexProjectivePresentation(B, [[B.b*B.c, B.a*B.c, B.c], [B.a, B.b, B.w]]);



###################################################
# Projective Resolutions:
F := GF(11);
Q := Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[A.b*A.c]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
rtG := RightGroebnerBasis(I);
B := A/I;
PS:=ProjectiveResolutionFpPathAlgebraModule(B, I, [[B.b*B.c, B.a*B.c, B.c], [B.a, B.b, B.w]]);

RelatorsOfFpAlgebra(B);
IsPathAlgebraModule(Module(PS));
Basis(Module(PS));
IsVertexProjectiveModule(Module(PS));
IsFreeLeftModule(Module(PS));
IsPathModuleElemCollection(Module(PS));


Example 2 (and 9) from Green's Paper:
F := Rationals;
Q := Quiver(["v1","v2","v3","v4","v5"],[["v4","v5","e"],["v3","v4","d"],["v1","v3","c"],
              ["v2","v4","b"],["v1","v2","a"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[A.a*A.b-A.c*A.d,A.b*A.e]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
rtG := RightGroebnerBasis(I);
B := A/I;
PS:=ProjectiveResolutionFpPathAlgebraModule(B, I, [[B.a], [B.c]]);
yy := ProjectivesFList(PS)[1];
Sortex(yy, \<);
xx := Basis(Projectives(PS)[2])[1] + Basis(Projectives(PS)[2])[3];
yy[1] in RProjectives(PS)[1];


#Example 7, on tip reduction:
F := Rationals;
Q := Quiver(["v1","v2"],[["v1","v2","a"],["v1","v2","b"],["v2","v1","c"],["v2","v1","d"]]);
A := PathAlgebra(F,Q);
P := RightProjectiveModule(A,[A.v1,A.v1,A.v2,A.v2]);
a := A.a; b := A.b; c := A.c; d := A.d;
f1 := Vectorize(P,[a*c,b*c*a*c+a*c*a*c,Zero(A),c*a*c]);
f2 := Vectorize(P,[A.v1,b*c+a*c,d,Zero(A)]);
f3 := Vectorize(P,[a,b,d*a+c*b,d*a]);
f4 := Vectorize(P,[Zero(A),b*c*a*c+a*c*a*c,Zero(A),Zero(A)]);

Tip(f1![1]);
Tip(f2![1]);
Tip(f3![1]);

N := SubAlgebraModule(P,[f1,f2,f3]);
rtGBofN := RightGroebnerBasisOfModule(N);
#
###################################################


####
#
# example of qpa native orderings, as well as building the set X(p) for
#   a path p:

# Note: if we change generators for ideal in I to include e^3 instead of e^2,
#       the basis is infinite.

#F := Rationals;
F := GF(11);
Q := Quiver(["v1","v2"],[["v1","v2","a"],["v1","v2","b"],["v2","v1","c"],["v2","v1","d"],
                         ["v2","v2","e"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[(A.e)^2,A.a*A.c,A.a*A.d,A.b*A.c,A.b*A.d,A.a*A.e*A.c,
               A.a*A.e*A.d, A.b*A.e*A.c, A.b*A.e*A.d]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
rtG := RightGroebnerBasis(I);
B := A/I;
IsFiniteDimensional(B);

a := Q.a; b := Q.b; c := Q.c; d := Q.d; e := Q.e; v1 := Q.v1; v2 := Q.v2;
OrderingOfQuiver(Q);
ord := OrderingOfAlgebra(A);
lt := ComparisonFunction(ord);
lt(a,b);
lt(a,a);
lt(b,a);
lt(e,e*e);

w := A.a*A.c;
vv := TargetOfPath(w);
OutgoingArrowsOfVertex(vv);

w := a*c;
vv := TargetOfPath(w);
OutgoingArrowsOfVertex(vv);

# another related example:
F := GF(11);
Q := Quiver(["v1","v2"],[["v1","v2","a"],["v2","v1","b"],["v2","v2","c"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[(A.c)^2, A.a*A.b, A.a*A.c*A.b]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
rtG := RightGroebnerBasis(I);
B := A/I;
IsFiniteDimensional(B);

#
####


####
#
#  Creating an XSet
#

F := GF(11);
Q := Quiver(["v1","v2"],[["v1","v2","a"],["v2","v1","b"],["v2","v2","c"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[(A.c)^2, A.a*A.b, A.a*A.c*A.b]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
GB := GroebnerBasisOfIdeal(I);
GB!.relations;
rtG := RightGroebnerBasis(I);
B := A/I;

P := RightProjectiveModule(A,[A.v1,A.v1,A.v2,A.v2]);
a := A.a; b := A.b; c := A.c;
f1 := Vectorize(P,[a*c,a*c*b*a+a*c*a,c*b*a-c,c]);
f2 := Vectorize(P,[A.v1,a*c+a*c*b,b,Zero(A)]);
f3 := Vectorize(P,[a,a,b*a+c*b,c]);

Tip(f1![1]);
Tip(f2![1]);
Tip(f3![1]);

TipReduce([f1,f2,f3]);

IsFiniteDimensional(B);
xx := XSetOfPathAlgebraVector(I, f1![1]);

#
####

####
#
#  Algebra experiments:
#

F := GF(11); 
Q := Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
A := PathAlgebra(F,Q);
I := Ideal(A,[A.b*A.c]);
gb := GBNPGroebnerBasis(I);
GroebnerBasis(I,gb);
rtG := RightGroebnerBasis(I);
B := A/I;
PS:=ProjectiveResolutionFpPathAlgebraModule(B, I, [[B.b*B.c, B.a*B.c, B.c], [B.a, B.b, B.w]]);
a := A.a; b := A.b; c := A.c;
Basis(B);
B.2*a;

###################################################
#
# Questions:
#
# 1. Why are overloaded multiplication functions
#    on line 115-... in algpath.gi such that
#    they return non-zero values?
#
# 2. Line 287, algpath.gi; how is it used?
#
###################################################
