<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (QPA documentation) - Chapter 6: Right Modules over Path
Algebras</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap5.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap7.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X87EFC38F7BC77B27" name="X87EFC38F7BC77B27"></a></p>
<div class="ChapSects"><a href="chap6.html#X87EFC38F7BC77B27">6 <span class="Heading">Right Modules over Path
Algebras</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X7D4882837C7EE06C">6.1 <span class="Heading">Matrix Modules</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82DAF2167E65C4A8">6.1-1 RightModuleOverPathAlgebra</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X869F4DD2877A99BA">6.2 <span class="Heading">Categories Of Matrix Modules</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82A8398478788A5A">6.2-1 IsPathAlgebraModule</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X862F510485ADBC67">6.3 <span class="Heading">Acting on Module Elements</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8123456781234567">6.3-1 ^</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X7E5B84B1832D839E">6.4 <span class="Heading">Operations on representations</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8687EC4878E755CC">6.4-1 CommonDirectSummand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B5EA4B0820DE28C">6.4-2 DimensionVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E6926C6850E7C4E">6.4-3 Dimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E24DCE07E98E50D">6.4-4 IsDirectSummand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X879541298181840D">6.4-5 DirectSumOfModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A50C15B87236111">6.4-6 IsDirectSumOfModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X857807CF8560B3C4">6.4-7 DirectSumInclusions</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X80CFB7E47A785E12">6.4-8 DirectSumProjections</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EC01D588141BB96">6.4-9 1stSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E5246D4831DB250">6.4-10 IsInAdditiveClosure</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7BE6A5B586463067">6.4-11 IsOmegaPeriodic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X803C2799861FFBC5">6.4-12 IsInjectiveModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8359AC9585777CA1">6.4-13 IsProjectiveModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7A8BC26E866E44DD">6.4-14 IsSemisimpleModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7FB82B3184287362">6.4-15 IsSimpleModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7BEA44FB819910B6">6.4-16 LoewyLength</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7B480767836D0764">6.4-17 MaximalCommonDirectSummand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7D198BB5808D38F2">6.4-18 IsomorphicModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7EB51A487B5B239D">6.4-19 NthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X870531C67C402A64">6.4-20 NthSyzygyNC</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7E44920683157DE2">6.4-21 RadicalOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7929281B848A9FBE">6.4-22 RadicalSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X84A724267E6F136D">6.4-23 SocleSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79DF34618798E866">6.4-24 SocleOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X858AC23C83AC843E">6.4-25 SubRepresentation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X856EA09A83A5A636">6.4-26 SupportModuleElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87F571327E43AFB4">6.4-27 TopOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X821FA104861FF19B">6.4-28 MinimalGeneratingSetOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X81BB198380631A9B">6.4-29 MatricesOfPathAlgebraModule</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X7919F94382D9B38B">6.5 <span class="Heading">Special representations</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8048CD27796253CA">6.5-1 BasisOfProjectives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X85EDCFE27F66093F">6.5-2 IndecProjectiveModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X87741234871B1F5C">6.5-3 IndecInjectiveModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7C61261F7C5E53B8">6.5-4 SimpleModules</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7CCE2D12807AA35A">6.5-5 ZeroModule</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X7D99BF5A87DDC099">6.6 <span class="Heading">Functors on representations</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82D7B50A7ACA47BF">6.6-1 DualOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X847DDC417BFB8515">6.6-2 DualOfModuleHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X82D31F887C14E921">6.6-3 DTr</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X7939949279208FA3">6.6-4 TrD</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79C0B620842128AF">6.6-5 TransposeOfModule</a></span>
</div></div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap6.html#X8097F19E8228B68C">6.7 <span class="Heading">Vertex Projective Presentations</span></a>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X79175B097A0718FE">6.7-1 RightProjectiveModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X78E05C8F7ADE2BCD">6.7-2 Vectorize</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8123456781234567">6.7-3 ^</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X871A3B1D871A3B1D">6.7-4 &lt;</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6.html#X8123456781234567">6.7-5 /</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Right Modules over Path
Algebras</span></h3>

<p>There are two implementations of right modules over path algebras. The first type are matrix modules that are defined by vector spaces and linear transformations. The second type are presentations defined by vertex projective modules.</p>

<p><a id="X7D4882837C7EE06C" name="X7D4882837C7EE06C"></a></p>

<h4>6.1 <span class="Heading">Matrix Modules</span></h4>

<p>The first implementation of right modules over path algebras views them as a collection of vector spaces and linear transformations. Each vertex in the path algebra is associated with a vector space over the field of the algebra. For each vertex $v$ of the algebra there is a vector space $V$. Arrows of the algebra are then associated with linear transformations which map the vector space of the source vertex to the vector space of the target vertex. For example, if $a$ is an arrow from $v$ to $w$ then there is a transformation from vector space $V$ to $W$. In practice when creating the modules all we need to know is the transformations and we can create the vector spaces of the correct dimension, and check to make sure the dimensions all agree. We can create a module in this way as follows.</p>

<p><a id="X82DAF2167E65C4A8" name="X82DAF2167E65C4A8"></a></p>

<h5>6.1-1 RightModuleOverPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RightModuleOverPathAlgebra</code>( <var class="Arg">A, mats</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RightModuleOverPathAlgebra</code>( <var class="Arg">A, dim_vector, gens</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a (quotient of a) path algebra, <var class="Arg">mats</var> -- a list of matrices, <var class="Arg">dim_vector</var> -- the dimension vector of the module, <var class="Arg">gens</var> -- a list of elements (generators). For further explanations, see below. <br /></p>

<p><b>Returns: </b>a module over a path algebra or over a qoutient of a path algebra in the second variant.</p>

<p>In the first function call, the list of matrices <var class="Arg">mats</var> can take on three different forms.</p>

<p>1) The argument <var class="Arg">mats</var> can be a list of blocks of matrices where each block is of the form, `["name of arrow",matrix]'. So if you named your arrows when you created the quiver, then you can associate a matrix with that arrow explicitly.</p>

<p>2) The argument <var class="Arg">mats</var> is just a list of matrices, and the matrices will be associated to the arrows in the order of arrow creation. If when creating the quiver, the arrow $a$ was created first, then $a$ would be associated with the first matrix.</p>

<p>3) The method is very much the same as the second method. If <var class="Arg">arrows</var> is a list of the arrows of the quiver (obtained for instance through <code class="code">arrows := ArrowsOfQuiver(Q);</code>), the argument <var class="Arg">mats</var> can have the format <code class="code">[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].</code></p>

<p>If you would like the trivial vector space at any vertex, then for each incoming arrow "a", associate it with a list of the form <code class="code">["a",[n,0]]</code> where n is the dimension of the vector space at the source vertex of the arrow. Likewise for all outgoing arrows "b", associate them to a block of form <code class="code">["b",[0,n]]</code> where n is the dimension of the vector space at the target vertex of the arrow.</p>

<p>A warning though, the function assumes that you do not mix the styles of inputting the matrices/linear transformations associated to the arrows in the quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise an error will be returned. The function verifies that the dimensions of the matrices and vector spaces are correct and match, and that each arrow has only one matrix assigned to it.</p>

<p>In the second function call, the second argument <var class="Arg">dim_vector</var> is the dimension vector of the module, and the last argument <var class="Arg">gens</var> (maybe an empty list []) is a list of elements of the form ["label",matrix]. This function constructs a right module over a (quotient of a) path algebra <var class="Arg">A</var> with dimension vector <var class="Arg">dim_vector</var>, and where the generators/arrows with a non-zero action is given in the list <var class="Arg">gens</var>. The format of the list <var class="Arg">gens</var> is [["a",[matrix_a]],["b",[matrix_b]],...], where "a" and "b" are labels of arrows used when the underlying quiver was created and matrix_? is the action of the algebra element corresponding to the arrow with label "?". The action of the arrows can be entered in any order. The function checks if the algebra <var class="Arg">A</var> is a (quotient of a) path algebra and if the matrices of the action of the arrows have the correct size according to the dimension vector entered and also whether or not the relations of the algebra are satisfied.</p>


<table class="example">
<tr><td><pre>
gap&amp;gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); 
&amp;lt;quiver with 2 vertices and 3 arrows&amp;gt;
gap&amp;gt; P := PathAlgebra(Rationals, Q);
&amp;lt;algebra-with-one over Rationals, with 5 generators&amp;gt;
gap&amp;gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&amp;gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&amp;gt; M := RightModuleOverPathAlgebra(P,matrices);
&amp;lt;right-module over &amp;lt;algebra-with-one over Rationals, with 5
generators&amp;gt;&amp;gt; 
gap&amp;gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; 
gap&amp;gt; N := RightModuleOverPathAlgebra(P,mats); 
&amp;lt;right-module over &amp;lt;algebra-with-one over Rationals, with 5
generators&amp;gt;&amp;gt; 
gap&amp;gt; arrows := ArrowsOfQuiver(Q);
[ a, b, c ]
gap&amp;gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], 
&amp;gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;
gap&amp;gt; N := RightModuleOverPathAlgebra(P,mats); 
&amp;lt;right-module over &amp;lt;algebra-with-one over Rationals, with 5
generators&amp;gt;&amp;gt;
gap&amp;gt; # Next we give the vertex simple associate to vertex 1. 
gap&amp;gt; M :=
RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);
&amp;lt;right-module over &amp;lt;algebra-with-one over Rationals, with 5
					generators&amp;gt;&amp;gt; 
gap&amp;gt; # Finally, the next defines the zero representation of the quiver.
gap&amp;gt; M :=
RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);
&amp;lt;right-module over &amp;lt;algebra-with-one over Rationals, with 5
					generators&amp;gt;&amp;gt; 
gap&amp;gt; Dimension(M);
0
gap&amp;gt; Basis(M);
Basis( &amp;lt;
0-dimensional right-module over &amp;lt;algebra-with-one over Rationals, with 
5 generators&amp;gt;&amp;gt;, [  ] )
gap&gt; # Using the above example.  
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b",
[[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,[2,3],matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5 generators&gt;&gt;
gap&gt; M := RightModuleOverPathAlgebra(P,[2,3],[]);      
&lt;right-module over &lt;algebra-with-one over Rationals, with 5 generators&gt;&gt;

</pre></td></tr></table>

<p><a id="X869F4DD2877A99BA" name="X869F4DD2877A99BA"></a></p>

<h4>6.2 <span class="Heading">Categories Of Matrix Modules</span></h4>

<p><a id="X82A8398478788A5A" name="X82A8398478788A5A"></a></p>

<h5>6.2-1 IsPathAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsPathAlgebraModule</code>( <var class="Arg">object</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<p><b>Returns: </b>true or false depending on whether <var class="Arg">object</var> belongs to the category <code class="code">IsPathAlgebraModule</code>.</p>

<p>These matrix modules fall under the category `IsAlgebraModule' with the added filter of `IsPathAlgebraModule'. Operations available for algebra modules can be applied to path algebra modules. See "ref:representations of algebras" for more details. These modules are also vector spaces over the field of the path algebra. So refer to "ref:vector spaces" for descriptions of the basis and elementwise operations available.</p>

<p><a id="X862F510485ADBC67" name="X862F510485ADBC67"></a></p>

<h4>6.3 <span class="Heading">Acting on Module Elements</span></h4>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>6.3-1 ^</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ^</code>( <var class="Arg">m, p</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">m</var> -- an element in a module, <var class="Arg">p</var> -- a path in a path algebra. <br /></p>

<p><b>Returns: </b>the element <var class="Arg">m</var> multiplied with <var class="Arg">p</var>.</p>

<p>When you act on an module element $m$ by an arrow $a$ from $v$ to $w$, the component of $m$ from $V$ is acted on by $L$ the transformation associated to $a$ and placed in the component $W$. All other components are given the value $0$.</p>


<table class="example">
<tr><td><pre>
gap&gt; # Using the path algebra P from the above example. 
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; B:=BasisVectors(Basis(M));
[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
gap&gt; B[1]+B[3];
[ [ 1, 0 ], [ 1, 0, 0 ] ]
gap&gt; 4*B[2];
[ [ 0, 4 ], [ 0, 0, 0 ] ]
gap&gt; m:=5*B[1]+2*B[4]+B[5];
[ [ 5, 0 ], [ 0, 2, 1 ] ]
gap&gt; m^(P.a*P.b-P.c);
[ [ 0, 5 ], [ 0, 0, 0 ] ]
gap&gt; B[1]^P.a;
[ [ 0, 0 ], [ 1, 0, 0 ] ]
gap&gt; B[2]^P.b;
[ [ 0, 0 ], [ 0, 0, 0 ] ]
gap&gt; B[4]^(P.b*P.c);
[ [ 0, 0 ], [ 0, 0, 0 ] ]
</pre></td></tr></table>

<p><a id="X7E5B84B1832D839E" name="X7E5B84B1832D839E"></a></p>

<h4>6.4 <span class="Heading">Operations on representations</span></h4>


<table class="example">
<tr><td><pre>
gap&gt; Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);
&lt;quiver with 3 vertices and 5 arrows&gt;
gap&gt; KQ := PathAlgebra(Rationals, Q);
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; gens := GeneratorsOfAlgebra(KQ);
[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ]
gap&gt; u := gens[1];; v := gens[2];;
gap&gt; w := gens[3];; a := gens[4];;
gap&gt; b := gens[5];; c := gens[6];;
gap&gt; d := gens[7];; e := gens[8];;
gap&gt; rels := [d*e,c^2,a*c*d-b*d,e*a];;
gap&gt; I:= Ideal(KQ,rels);;
gap&gt; gb:= GBNPGroebnerBasis(rels,KQ);;
gap&gt; gbb:= GroebnerBasis(I,gb);;
gap&gt; A:= KQ/I;
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],
["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap&gt; N:= RightModuleOverPathAlgebra(A,mat);                         
&lt;right-module over &lt;algebra-with-one over Rationals, with 8 generators&gt;&gt;
</pre></td></tr></table>

<p><a id="X8687EC4878E755CC" name="X8687EC4878E755CC"></a></p>

<h5>6.4-1 CommonDirectSummand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CommonDirectSummand</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> and <var class="Arg">N</var> -- two path algebra modules. <br /></p>

<p><b>Returns: </b>a list of four modules [<var class="Arg">X</var>,<var class="Arg">U</var>,<var class="Arg">X</var>, <var class="Arg">V</var>], where <var class="Arg">X</var> is one common non-zero direct summand of <var class="Arg">M</var> and <var class="Arg">N</var>, the sum of <var class="Arg">X</var> and <var class="Arg">U</var> is <var class="Arg">M</var> and the sum of <var class="Arg">X</var> and <var class="Arg">V</var> is <var class="Arg">N</var>, if such a non-zero direct summand exists. Otherwise it returns false.</p>

<p>The function checks if <var class="Arg">M</var> and <var class="Arg">N</var> are <code class="code">PathAlgebraMatModule</code>s over the same (quotient of a) path algebra.</p>

<p><a id="X7B5EA4B0820DE28C" name="X7B5EA4B0820DE28C"></a></p>

<h5>6.4-2 DimensionVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DimensionVector</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the dimension vector of the representation <var class="Arg">M</var>.</p>

<p>A shortcoming of this that it is not defined for modules of quotients of path algebras.</p>

<p><a id="X7E6926C6850E7C4E" name="X7E6926C6850E7C4E"></a></p>

<h5>6.4-3 Dimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Dimension</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the dimension of the representation <var class="Arg">M</var>.</p>

<p><a id="X7E24DCE07E98E50D" name="X7E24DCE07E98E50D"></a></p>

<h5>6.4-4 IsDirectSummand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsDirectSummand</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M, N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>s). <br /></p>

<p><b>Returns: </b>true if <var class="Arg">M</var> is isomorphic to a direct summand of <var class="Arg">N</var>, otherwise false.</p>

<p>The function checks if <var class="Arg">M</var> and <var class="Arg">N</var> are <code class="code">PathAlgebraMatModule</code>s over the same (quotient of a) path algebra.</p>

<p><a id="X879541298181840D" name="X879541298181840D"></a></p>

<h5>6.4-5 DirectSumOfModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectSumOfModules</code>( <var class="Arg">L</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">L</var> -- a list of <code class="code">PathAlgebraMatModule</code>s over the same (quotient of a) path algebra. <br /></p>

<p><b>Returns: </b>the direct sum of the representations contained in the list <var class="Arg">L</var>.</p>

<p>In addition three attributes are attached to the result, <code class="code">IsDirectSumOfModules, DirectSumProjections</code> and <code class="code">DirectSumInclusions</code>.</p>

<p><a id="X7A50C15B87236111" name="X7A50C15B87236111"></a></p>

<h5>6.4-6 IsDirectSumOfModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsDirectSumOfModules</code>( <var class="Arg">M</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>true if <var class="Arg">M</var> is constructed via the command <code class="code">DirectSumOfModules</code>.</p>

<p><a id="X857807CF8560B3C4" name="X857807CF8560B3C4"></a></p>

<h5>6.4-7 DirectSumInclusions</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectSumInclusions</code>( <var class="Arg">M</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the list of inclusions from the individual modules to their direct sum, when a direct sum has been constructed using <code class="code">DirectSumOfModules</code>.</p>

<p><a id="X80CFB7E47A785E12" name="X80CFB7E47A785E12"></a></p>

<h5>6.4-8 DirectSumProjections</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DirectSumProjections</code>( <var class="Arg">M</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the list of projections from the direct sum to the individual modules used to construct direct sum, when a direct sum has been constructed using <code class="code">DirectSumOfModules</code>.</p>

<p>Using the example above.</p>


<table class="example">
<tr><td><pre>
gap&gt; N2:=DirectSumOfModules([N,N]);
&lt;14-dimensional right-module over &lt;algebra-with-one of dimension 
17 over Rationals&gt;&gt;
gap&gt; proj:=DirectSumProjections(N2);
[ &lt;mapping: &lt;14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; -&gt; &lt;
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; &gt;, 
  &lt;mapping: &lt;14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; -&gt; &lt;
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; &gt; ]
gap&gt; inc:=DirectSumInclusions(N2);  
[ &lt;mapping: &lt;7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; -&gt; &lt;
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; &gt;, 
  &lt;mapping: &lt;7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; -&gt; &lt;
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )&gt; &gt; ]
</pre></td></tr></table>

<p><a id="X7EC01D588141BB96" name="X7EC01D588141BB96"></a></p>

<h5>6.4-9 1stSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; 1stSyzygy</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the first syzygy of the representation <var class="Arg">M</var> as a representation.</p>

<p><a id="X7E5246D4831DB250" name="X7E5246D4831DB250"></a></p>

<h5>6.4-10 IsInAdditiveClosure</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsInAdditiveClosure</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M, N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>s). <br /></p>

<p><b>Returns: </b>true if <var class="Arg">M</var> is in the additive closure of the module <var class="Arg">N</var>, otherwise false.</p>

<p>The function checks if <var class="Arg">M</var> and <var class="Arg">N</var> are <code class="code">PathAlgebraMatModule</code>s over the same (quotient of a) path algebra.</p>

<p><a id="X7BE6A5B586463067" name="X7BE6A5B586463067"></a></p>

<h5>6.4-11 IsOmegaPeriodic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsOmegaPeriodic</code>( <var class="Arg">M, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- be a positive integer. <br /></p>

<p><b>Returns: </b><code class="code">i</code>, where <code class="code">i</code> is the smallest positive integer less or equal <code class="code">n</code> such that the representation <var class="Arg">M</var> is isomorphic to the <code class="code">i</code>-th syzygy of <var class="Arg">M</var>, and false otherwise.</p>

<p><a id="X803C2799861FFBC5" name="X803C2799861FFBC5"></a></p>

<h5>6.4-12 IsInjectiveModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsInjectiveModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>true if the representation <var class="Arg">M</var> is injective.</p>

<p><a id="X8359AC9585777CA1" name="X8359AC9585777CA1"></a></p>

<h5>6.4-13 IsProjectiveModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsProjectiveModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>true if the representation <var class="Arg">M</var> is projective.</p>

<p><a id="X7A8BC26E866E44DD" name="X7A8BC26E866E44DD"></a></p>

<h5>6.4-14 IsSemisimpleModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSemisimpleModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>true if the representation <var class="Arg">M</var> is semisimple.</p>

<p><a id="X7FB82B3184287362" name="X7FB82B3184287362"></a></p>

<h5>6.4-15 IsSimpleModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSimpleModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>true if the representation <var class="Arg">M</var> is simple.</p>

<p><a id="X7BEA44FB819910B6" name="X7BEA44FB819910B6"></a></p>

<h5>6.4-16 LoewyLength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LoewyLength</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the Loewy length of the module <var class="Arg">M</var>.</p>

<p>The function checks that the module <var class="Arg">M</var> is a module over a finite dimensional quotient of a path algebra, and returns fail otherwise (This is not implemented yet).</p>

<p><a id="X7B480767836D0764" name="X7B480767836D0764"></a></p>

<h5>6.4-17 MaximalCommonDirectSummand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MaximalCommonDirectSummand</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M, N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>s). <br /></p>

<p><b>Returns: </b>a list of three modules [<var class="Arg">X</var>,<var class="Arg">U</var>,<var class="Arg">V</var>], where <var class="Arg">X</var> is a maximal common non-zero direct summand of <var class="Arg">M</var> and <var class="Arg">N</var>, the sum of <var class="Arg">X</var> and <var class="Arg">U</var> is <var class="Arg">M</var> and the sum of <var class="Arg">X</var> and <var class="Arg">V</var> is <var class="Arg">N</var>, if such a non-zero maximal direct summand exists. Otherwise it returns false.</p>

<p>The function checks if <var class="Arg">M</var> and <var class="Arg">N</var> are <code class="code">PathAlgebraMatModule</code>s over the same (quotient of a) path algebra.</p>

<p><a id="X7D198BB5808D38F2" name="X7D198BB5808D38F2"></a></p>

<h5>6.4-18 IsomorphicModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsomorphicModules</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M, N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>s). <br /></p>

<p><b>Returns: </b>true or false depending on whether <var class="Arg">M</var> and <var class="Arg">N</var> are isomorphic or not.</p>

<p>The function first checks if the modules <var class="Arg">M</var> and <var class="Arg">N</var> are modules over the same algebra, and returns fail if not. The function returns true if the modules are isomorphic, otherwise false.</p>

<p><a id="X7EB51A487B5B239D" name="X7EB51A487B5B239D"></a></p>

<h5>6.4-19 NthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NthSyzygy</code>( <var class="Arg">M, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- a positive integer. <br /></p>

<p><b>Returns: </b>the top of the syzygies until a syzygy is projective or the <var class="Arg">n</var>-th syzygy has been computed.</p>

<p><a id="X870531C67C402A64" name="X870531C67C402A64"></a></p>

<h5>6.4-20 NthSyzygyNC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NthSyzygyNC</code>( <var class="Arg">M, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- a positive integer. <br /></p>

<p><b>Returns: </b>the <code class="code">n</code>-th syzygy of the module <var class="Arg">M</var>, unless the projective dimension of <var class="Arg">M</var> is less or equal to <code class="code">n-1</code>, in which case it returns the projective dimension of <var class="Arg">M</var>. It does not check if the <code class="code">n</code>-th syzygy is projective or not.</p>

<p><a id="X7E44920683157DE2" name="X7E44920683157DE2"></a></p>

<h5>6.4-21 RadicalOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RadicalOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the radical of the module <var class="Arg">M</var>.</p>

<p>This returns only the representation given by the radical of the module <var class="Arg">M</var>. The operation <code class="func">RadicalOfModuleInclusion</code> (<a href="chap7.html#X7BF04DAE78E98D9C"><b>7.3-17</b></a>) computes the inclusion of the radical of <var class="Arg">M</var> into <var class="Arg">M</var>.</p>

<p><a id="X7929281B848A9FBE" name="X7929281B848A9FBE"></a></p>

<h5>6.4-22 RadicalSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RadicalSeries</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the radical series of the module <var class="Arg">M</var>.</p>

<p>The function gives the radical series as a list of vectors <code class="code">[n_1,...,n_s]</code>, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of each simple. The first vector listed corresponds to the top layer, and so on.</p>

<p><a id="X84A724267E6F136D" name="X84A724267E6F136D"></a></p>

<h5>6.4-23 SocleSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SocleSeries</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the socle series of the module <var class="Arg">M</var>.</p>

<p>The function gives the socle series as a list of vectors <code class="code">[n_1,...,n_s]</code>, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of each simple. The last vector listed corresponds to the socle layer, and so on backwards.</p>

<p><a id="X79DF34618798E866" name="X79DF34618798E866"></a></p>

<h5>6.4-24 SocleOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SocleOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the socle of the module <var class="Arg">M</var>.</p>

<p>This operation only return the representation given by the socle of the module <var class="Arg">M</var>. The inclusion the socle of <var class="Arg">M</var> into <var class="Arg">M</var> can be computed using <code class="func">SocleOfModuleInclusion</code> (<a href="chap7.html#X82EB23337C5F4DBB"><b>7.3-18</b></a>).</p>

<p><a id="X858AC23C83AC843E" name="X858AC23C83AC843E"></a></p>

<h5>6.4-25 SubRepresentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SubRepresentation</code>( <var class="Arg">M, gens</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">gens</var> -- elements in <var class="Arg">M</var>. <br /></p>

<p><b>Returns: </b>the submodule of the module <var class="Arg">M</var> generated by the elements <var class="Arg">gens</var>.</p>

<p>The function checks if <var class="Arg">gens</var> are elements in <var class="Arg">M</var>, and returns an error message otherwise. The inclusion of the submodule generated by the elements <var class="Arg">gens</var> into <var class="Arg">M</var> can be computed using <code class="func">SubRepresentationInclusion</code> (<a href="chap7.html#X7E9BF05587D4A86A"><b>7.3-19</b></a>).</p>

<p><a id="X856EA09A83A5A636" name="X856EA09A83A5A636"></a></p>

<h5>6.4-26 SupportModuleElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SupportModuleElement</code>( <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">m</var> -- an element of a path algebra module. <br /></p>

<p><b>Returns: </b>the primitive idempotents <var class="Arg">v</var> in the algebra over which the module containing the element <var class="Arg">m</var> is a module, such that <var class="Arg">m^v</var> is non-zero.</p>

<p>The function checks if <var class="Arg">m</var> is an element in a module over a (quotient of a) path algebra, and returns fail otherwise.</p>

<p><a id="X87F571327E43AFB4" name="X87F571327E43AFB4"></a></p>

<h5>6.4-27 TopOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TopOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>the top of the module <var class="Arg">M</var>.</p>

<p>This returns only the representation given by the top of the module <var class="Arg">M</var>. The operation <code class="func">TopOfModuleProjection</code> (<a href="chap7.html#X804BD7CD804E63C4"><b>7.3-20</b></a>) computes the projection of the module <var class="Arg">M</var> onto the top of the module <var class="Arg">M</var>.</p>

<p><a id="X821FA104861FF19B" name="X821FA104861FF19B"></a></p>

<h5>6.4-28 MinimalGeneratingSetOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MinimalGeneratingSetOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>a minimal generator set of the module <var class="Arg">M</var> as a module of the path algebra it is defined over.</p>

<p><a id="X81BB198380631A9B" name="X81BB198380631A9B"></a></p>

<h5>6.4-29 MatricesOfPathAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MatricesOfPathAlgebraModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p><b>Returns: </b>a list of the matrices that defines the representation <var class="Arg">M</var> as a right module of the acting path algebra.</p>

<p>The list of matrices that are returned are not the same identical to the matrices entered to define the representation if there is zero vector space in at least one vertex. Then zero matrices of the appropriate size are returned. A shortcoming of this that it is not defined for modules of quotients of path algebras.</p>

<p><a id="X7919F94382D9B38B" name="X7919F94382D9B38B"></a></p>

<h4>6.5 <span class="Heading">Special representations</span></h4>

<p>Here we collect the predefined representations/modules over a finite dimensional quotient of a path algebra.</p>

<p><a id="X8048CD27796253CA" name="X8048CD27796253CA"></a></p>

<h5>6.5-1 BasisOfProjectives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BasisOfProjectives</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a finite dimensional (quotient of a) path algebra. <br /></p>

<p><b>Returns: </b>a list of bases for all the indecomposable projective representations over <var class="Arg">A</var>. The basis for each indecomposable projective is given a list of elements in nontips in <var class="Arg">A</var>.</p>

<p>The function checks if the algebra <var class="Arg">A</var> is a finite dimensional (quotient of a) path algebra, and returns an error message otherwise.</p>

<p><a id="X85EDCFE27F66093F" name="X85EDCFE27F66093F"></a></p>

<h5>6.5-2 IndecProjectiveModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IndecProjectiveModules</code>( <var class="Arg">A[, list]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a finite dimensional (quotient of a) path algebra, (optional) <var class="Arg">list</var> -- a list of integers. <br /></p>

<p><b>Returns: </b>a list of all the indecomposable projective representations over <var class="Arg">A</var>, when only one argument is supplied. The second argument should be a list of integers, for example [1, 3, 4], which will return the indecomposable projective corresponding to vertex 1, 3 and 4, in this order.</p>

<p>The function checks if the algebra <var class="Arg">A</var> is a finite dimensional (quotient of a) path algebra, and returns an error message otherwise.</p>

<p><a id="X87741234871B1F5C" name="X87741234871B1F5C"></a></p>

<h5>6.5-3 IndecInjectiveModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IndecInjectiveModules</code>( <var class="Arg">A[, list]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a finite dimensional (quotient of a) path algebra, (optional) <var class="Arg">list</var> -- a list of integers. <br /></p>

<p><b>Returns: </b>a list of all the indecomposable injective representations over <var class="Arg">A</var>, when only one argument is supplied. The second argument should be a list of integers, for example [1, 3, 4], which will return the indecomposable injective corresponding to vertex 1, 3 and 4, in this order.</p>

<p>The function checks if the algebra <var class="Arg">A</var> is a finite dimensional (quotient of a) path algebra, and returns an error message otherwise.</p>

<p><a id="X7C61261F7C5E53B8" name="X7C61261F7C5E53B8"></a></p>

<h5>6.5-4 SimpleModules</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleModules</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a finite dimensional (quotient of a) path algebra. <br /></p>

<p><b>Returns: </b>a list of all the simple representations over <var class="Arg">A</var> .</p>

<p>The function checks if the algebra <var class="Arg">A</var> is a finite dimensional (quotient of a) path algebra, and returns an error message otherwise.</p>

<p><a id="X7CCE2D12807AA35A" name="X7CCE2D12807AA35A"></a></p>

<h5>6.5-5 ZeroModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ZeroModule</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a finite dimensional (quotient of a) path algebra. <br /></p>

<p><b>Returns: </b>the zero representation over <var class="Arg">A</var> .</p>

<p>The function checks if the algebra <var class="Arg">A</var> is a finite dimensional (quotient of a) path algebra, and returns an error message otherwise.</p>

<p><a id="X7D99BF5A87DDC099" name="X7D99BF5A87DDC099"></a></p>

<h4>6.6 <span class="Heading">Functors on representations</span></h4>

<p><a id="X82D7B50A7ACA47BF" name="X82D7B50A7ACA47BF"></a></p>

<h5>6.6-1 DualOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a representation of a path algebra $KQ$. <br /></p>

<p><b>Returns: </b>the dual of <var class="Arg">M</var> over the opposite path algebra <var class="Arg">KQ_op</var>.</p>

<p><a id="X847DDC417BFB8515" name="X847DDC417BFB8515"></a></p>

<h5>6.6-2 DualOfModuleHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualOfModuleHomomorphism</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var> -- a map between two representations <var class="Arg">M</var> and <var class="Arg">N</var> over a path algebra $A$. <br /></p>

<p><b>Returns: </b>the dual of this map over the opposite path algebra <var class="Arg">A^op</var>.</p>

<p><a id="X82D31F887C14E921" name="X82D31F887C14E921"></a></p>

<h5>6.6-3 DTr</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DTr</code>( <var class="Arg">M[, n]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DualOfTranspose</code>( <var class="Arg">M[, n]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module, (optional) <var class="Arg">n</var> -- an integer. <br /></p>

<p><b>Returns: </b>the dual of the transpose of <var class="Arg">M</var> when called with only one argument, while it returns the dual of the transpose applied to <var class="Arg">M</var> <var class="Arg">n</var> times otherwise. If <var class="Arg">n</var> is negative, then powers of <code class="code">TrD</code> are computed. <code class="func">DualOfTranspose</code> is a synonym for <code class="func">DTr</code>.</p>

<p><a id="X7939949279208FA3" name="X7939949279208FA3"></a></p>

<h5>6.6-4 TrD</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TrD</code>( <var class="Arg">M[, n]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TransposeOfDual</code>( <var class="Arg">M[, n]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module, (optional) <var class="Arg">n</var> -- an integer. <br /></p>

<p><b>Returns: </b>the transpose of the dual of <var class="Arg">M</var> when called with only one argument, while it returns the transpose of the dual applied to <var class="Arg">M</var> <var class="Arg">n</var> times otherwise. If <var class="Arg">n</var> is negative, then powers of <code class="code">TrD</code> are computed. <code class="func">TransposeOfDual</code> is a synonym for <code class="func">TrD</code>.</p>

<p><a id="X79C0B620842128AF" name="X79C0B620842128AF"></a></p>

<h5>6.6-5 TransposeOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TransposeOfModule</code>( <var class="Arg">M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module. <br /></p>

<p><b>Returns: </b>the transpose of the module <var class="Arg">M</var>.</p>

<p><a id="X8097F19E8228B68C" name="X8097F19E8228B68C"></a></p>

<h4>6.7 <span class="Heading">Vertex Projective Presentations</span></h4>

<p>In general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a projective module of $R$. Then we can form a direct sum of these projective modules together to form larger projective module. One can construct more general modules by providing a <var class="Arg">vertex projective presentation</var>. In this case, $M$ is the cokernel as given by the following exact sequence: $\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R \rightarrow{M} \rightarrow 0$ for some map between $\oplus_{j=1}^{r} w(j)R$ and $\oplus_{i=1}^{g} v(i)R$. The maps $w$ and $v$ map the integers to some idempotent in $R$.</p>

<p><a id="X79175B097A0718FE" name="X79175B097A0718FE"></a></p>

<h5>6.7-1 RightProjectiveModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RightProjectiveModule</code>( <var class="Arg">A, verts</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> -- a (quotient of a) path algebra, <var class="Arg">verts</var> -- a list of vertices. <br /></p>

<p><b>Returns: </b>the right projective module over <var class="Arg">A</var> which is the direct sum of projective modules of the form <var class="Arg">vA</var> where the vertices are taken from <var class="Arg">verts</var>.</p>

<p>In this implementation the algebra can be a quotient of a path algebra. So if the list was $[v,w]$ then the module created will be the direct sum $vA \oplus wA$, in that order. Elements of the modules are vectors of algebra elements, and in each component, each path begins with the vertex in that position in the list of vertices. Right projective modules are implementated as algebra modules (see "ref:Representations of Algebras") and all operations for algebra modules are applicable to right projective modules. In particular, one can construct submodules using `SubAlgebraModule'.</p>

<p>Here we create the right projective module $P = vA \oplus vA \oplus wA$.</p>


<table class="example">
<tr><td><pre>
gap&gt; F:=GF(11);
GF(11)
gap&gt; Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
&lt;quiver with 3 vertices and 3 arrows&gt;
gap&gt; A:=PathAlgebra(F,Q);
&lt;algebra-with-one over GF(11), with 6 generators&gt;
gap&gt; P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
&lt;right-module over &lt;algebra-with-one over GF(11), with 6 generators&gt;&gt;
gap&gt; Dimension(P);
12
</pre></td></tr></table>

<p><a id="X78E05C8F7ADE2BCD" name="X78E05C8F7ADE2BCD"></a></p>

<h5>6.7-2 Vectorize</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Vectorize</code>( <var class="Arg">M, components</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a module over a path algebra, <var class="Arg">components</var> -- a list of elements of <var class="Arg">M</var>. <br /></p>

<p><b>Returns: </b>a vector in <var class="Arg">M</var> from a list of path algebra elements <var class="Arg">components</var>, which defines the components in the resulting vector.</p>

<p>The returned vector is normalized, so the vector's components may not match the input components.</p>

<p>In the following example, we create two elements in $P$, perform some elementwise operations, and then construct a submodule using the two elements as generators.</p>


<table class="example">
<tr><td><pre>
gap&gt; p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
gap&gt; p2:=Vectorize(P,[A.a,A.b,A.w]);
[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
gap&gt; 2*p1 + p2;
[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ]
gap&gt; S:=SubAlgebraModule(P,[p1,p2]);
&lt;right-module over &lt;algebra-with-one of dimension 8 over GF(11)&gt;&gt;
gap&gt; Dimension(S);
3
</pre></td></tr></table>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>6.7-3 ^</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ^</code>( <var class="Arg">m, a</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">m</var> -- an element of a path algebra module, <var class="Arg">a</var> -- an element of a path algebra. <br /></p>

<p><b>Returns: </b>the element <var class="Arg">m</var> multiplied with <var class="Arg">a</var>.</p>

<p>This action is defined by multiplying each component in <var class="Arg">m</var> by <var class="Arg">a</var> on the right.</p>


<table class="example">
<tr><td><pre>
gap&gt; p2^(A.c - A.w);
[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
  (Z(11)^5)*w+(Z(11)^0)*c ]
</pre></td></tr></table>

<p><a id="X871A3B1D871A3B1D" name="X871A3B1D871A3B1D"></a></p>

<h5>6.7-4 &lt;</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; &lt;</code>( <var class="Arg">m1, m2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">m1, m2</var> -- two elements of a module over a path algebra (?). <br /></p>

<p><b>Returns: </b>`true' if <var class="Arg">m1</var> is less than <var class="Arg">m2</var> and false otherwise.</p>

<p>Elements are compared componentwise from left to right using the ordering of the underlying algebra. The element <var class="Arg">m1</var> is less than <var class="Arg">m2</var> if the first time components are not equal, the component of <var class="Arg">m1</var> is less than the corresponding component of <var class="Arg">m2</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; p1 &lt; p2;
false
</pre></td></tr></table>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>6.7-5 /</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; /</code>( <var class="Arg">M, N</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Arguments: <var class="Arg">M, N</var> -- two finite dimensional modules over a path algebra (?). <br /></p>

<p><b>Returns: </b>the factor module $M/N$.</p>

<p>This module is again a right algebra module, and all applicable methods and operations are available for the resulting factor module. Furthermore, the resulting module is a vector space, so operations for computing bases and dimensions are also available.</p>

<p>This</p>


<table class="example">
<tr><td><pre>
gap&gt; PS := P/S;
&lt;9-dimensional right-module over &lt;algebra-with-one of dimension
8 over GF(11)&gt;&gt; 
gap&gt; Basis(PS);
Basis( &lt;9-dimensional right-module over &lt;algebra-with-one of dimension 
8 over GF(11)&gt;&gt;, [ [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ...,
(Z(11)^0)*w ] ],  
  [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ..., (Z(11)^0)*c ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*v, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a*c, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b*c, &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*v, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*b, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ] ] )
</pre></td></tr></table>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap5.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap7.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
