% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}


\usepackage{amsmath}
\usepackage[all]{xy}
\newcommand{\tensor}{\otimes}
\newcommand{\quiverproduct}{\times}
\newcommand{\Hom}{\operatorname{Hom}\nolimits}
\newcommand{\End}{\operatorname{End}\nolimits}
\newcommand{\Ext}{\operatorname{Ext}\nolimits}
\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages


\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{QPA\mbox{}}}\\[1cm]
\hypersetup{pdftitle=QPA}
\markright{\scriptsize \mbox{}\hfill QPA \hfill\mbox{}}
{\Large \textbf{Quivers and Path Algebras\mbox{}}}\\[1cm]
{Version version 1.07 \mbox{}}\\[1cm]
{September 2010\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{The QPA-team\\
 \href{http://sourceforge.net/projects/quiverspathalg/} {\texttt{http://sourceforge.net/projects/quiverspathalg/}}\\
 (See also \href{http://www.math.ntnu.no/~oyvinso/QPA/} {\texttt{http://www.math.ntnu.no/\texttt{\symbol{126}}oyvinso/QPA/}}) \mbox{}}}\\
\hypersetup{pdfauthor=The QPA-team\\
 \href{http://sourceforge.net/projects/quiverspathalg/} {\texttt{http://sourceforge.net/projects/quiverspathalg/}}\\
 (See also \href{http://www.math.ntnu.no/~oyvinso/QPA/} {\texttt{http://www.math.ntnu.no/\texttt{\symbol{126}}oyvinso/QPA/}}) }
\mbox{}\\[2cm]
\begin{minipage}{12cm}\noindent
 We can add a comment here. \end{minipage}

\end{center}\vfill

\mbox{}\\

\noindent \textbf{Address: }\begin{minipage}[t]{8cm}\noindent
 Virginia Tech, Blacksburg, USA\\
 NTNU, Trondheim, Norway\\
 \end{minipage}
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
{\copyright} 2010-2020 The QPA-team. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
The system design of \textsf{QPA} was initiated by Edward L. Green, Lenwood S. Heath, and Craig A. Struble. It
was continued and completed by Randall Cone and Edward Green. We would like to
thank the following people for their contributions: \begin{center}
\begin{tabular}{ll}Gerard Brunick&
Quivers, path algebras\\
Randall Cone&
Code modernization and cleanup, GBNP interface (for Groebner bases),\\
 &
projective resolutions, user documentation\\
George Yuhasz&
User documentation, matrix representations of path algebras\\
\end{tabular}\\[2mm]
\end{center}

 \mbox{}}\\[1cm]
{\small 
\section*{Colophon}
\logpage{[ 0, 0, 4 ]}
This is the Colophon page. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 5 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction/Quick Start}}\label{Introduction/Quickstart}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7D7CD01E7DAFA776}{}
{
 This chapter is intended for those who would like to get started with \textsf{QPA} right away by playing with a few examples. An important feature to be aware of
concerning using the software is how to display the results one is obtaining.
Here there are three basic ways of doing this, through \texttt{View}, \texttt{Print} or \texttt{Display}. The command \texttt{View(M)} prints a short information about the object \texttt{M}, the command \texttt{Print(M)} prints a longer information about the object \texttt{M}, and finally The command \texttt{Display(M)} prints an even fuller information about the object \texttt{M}, in general. However, for some objects these may all coincide. First we
present a simple example:  
\section{\textcolor{Chapter }{Example 1}}\label{Example 1}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8388E29680F31ABD}{}
{
 We construct a quiver $q$, i.e. a finite directed graph, with one vertex and two loops: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
  <quiver with 1 vertices and 2 arrows>
\end{Verbatim}
 We can request the list of vertices and the list of arrows for $q$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> VerticesOfQuiver(q);
  [ u ]
  gap> ArrowsOfQuiver(q);
  [ a, b ]
\end{Verbatim}
 Next we create the path algebra $pa$ from $q$ over the rational numbers: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> pa := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 3 generators>
\end{Verbatim}
 In this case it is interesting to note that we've created an algebra
isomorphic to the free algebra on two generators. We now retrieve and label
the generators and multiplicative identity for $pa$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gens := GeneratorsOfAlgebra(pa);
  [ (1)*u, (1)*a, (1)*b ]
  gap> u := gens[1];
  (1)*u
  gap> a := gens[2];
  (1)*a
  gap> b := gens[3];
  (1)*b
  gap> id := One(pa);
  (1)*u
\end{Verbatim}
 As we expect, in this case, the multiplicative identity for $pa$ and the single vertex $u$ are one in the same: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> u = id;
  true
\end{Verbatim}
 We now create a list of generators for an ideal and ask for its Groebner
basis: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> polys := [a*b*a-b,b*a*b-b];
  [ (-1)*b+(1)*a*b*a, (-1)*b+(1)*b*a*b ]
  gap> gb := GBNPGroebnerBasis(polys,pa);
  [ (-1)*a*b+(1)*b*a, (-1)*a*b+(1)*b^2, (-1)*b+(1)*a^2*b ]
\end{Verbatim}
 Next, we create an ideal $I$ in \texttt{\symbol{123}}\texttt{\symbol{92}}GAP\texttt{\symbol{125}} using the
Groebner basis $gb$ found above, and then the quotient $pa/I$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> I := Ideal(pa,gb);
  <two-sided ideal in <algebra-with-one over Rationals, with 3
  generators>, 
   (3 generators)>
\end{Verbatim}
 Once we have the generators for a Groebner basis, we set the appropriate
property for the ideal $I$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> grb := GroebnerBasis(I,gb);    
  <partial two-sided Groebner basis containing 3 elements>
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 2}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7A18778D836BC971}{}
{
 In this next example we create another path algebra that is essentially the
free algebra on six generators. We then find the Groebner basis for a
commutative example from (create bibliographic reference here) the book "Some
Tapas of Computer Algebra" by A.M. Cohen, H. Cuypers, H. Sterk. We create the
underlying quiver, and from it the path algebra over the rational numbers: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
  >                    ["u","u","d"],["u","u","e"],["u","u","f"]]);
  <quiver with 1 vertices and 6 arrows>
  gap> fq := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 7 generators>
\end{Verbatim}
 Next, the generators are labeled and the list of polynomials is entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gens := GeneratorsOfAlgebra(fq);
  [ (1)*u, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e, (1)*f ]
  gap> u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
  gap> d := gens[5];; e := gens[6];; f := gens[7];;
  gap> polys := [ e*a,
  >            a^3 + f*a,
  >            a^9 + c*a^3,
  >            a^81 + c*a^9 + d*a^3,
  >            a^27 + d*a^81 + e*a^9 + f*a^3,
  >            b + c*a^27 + e*a^81 + f*a^9,
  >            c*b + d*a^27 + f*a^81,
  >            a + d*b + e*a^27,
  >            c*a + e*b + f*a^27,
  >            d*a + f*b,
  >            b^3 - b,
  >            a*b - b*a, a*c - c*a,
  >            a*d - d*a, a*e - e*a,
  >            a*f - f*a, b*c - c*b,
  >            b*d - d*b, b*e - e*b,
  >            b*f - f*b, c*d - d*c,
  >            c*e - e*c, c*f - f*c,
  >            d*e - e*d, d*f - f*d,
  >            e*f - f*e
  > ];;
\end{Verbatim}
 Finally, the Groebner basis is found: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gb := GBNPGroebnerBasis(polys,fq);
  [ (1)*a, (1)*b, (-1)*c*d+(1)*d*c, (-1)*c*e+(1)*e*c, (-1)*d*e+(1)*e*d,
    (-1)*c*f+(1)*f*c, (-1)*d*f+(1)*f*d, (-1)*e*f+(1)*f*e ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 3}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7D680484821C7835}{}
{
 The next example is from B. Keller's PhD thesis, p. 26: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
  <quiver with 2 vertices and 3 arrows>
  gap> pa := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 5 generators>
  gap> 
  gap> # Get generators of path algebra:
  gap> gens := GeneratorsOfAlgebra(pa);
  [ (1)*u, (1)*v, (1)*c, (1)*b, (1)*a ]
  gap> u := gens[1];; v := gens[2];; c := gens[3];;
  gap> b := gens[4];; a := gens[5];; id := One(pa);;
  gap> 
  gap> polys := [a*b*c+b*a*b+a+c];
  [ (1)*c+(1)*a+(1)*b*a*b+(1)*a*b*c ]
  gap> gb := GBNPGroebnerBasis(polys,pa);
  [ (-1)*b*c+(1)*a*c, (1)*a+(1)*b*a*b, (1)*c+(1)*a*b*c, (-1)*b*a^2+(1)*a^2*b ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 4}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X848E4DDE845A6EE9}{}
{
 Here's an example that doesn't meet our necessary criteria that all elements
in a generating set have monomials in the arrow ideal. Since the given path
algebra is isomorphic to a free algebra, the single vertex is sent to the
identity and there are no complications. First, we set up the algebra and
generating set: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
  <quiver with 1 vertices and 2 arrows>
  gap> f := Rationals;
  Rationals
  gap> fq := PathAlgebra(f,q);
  <algebra-with-one over Rationals, with 3 generators>
  gap> 
  gap> # Get generators of path algebra:
  gap> gens := GeneratorsOfAlgebra(fq);
  [ (1)*u, (1)*x, (1)*y ]
  gap> u := gens[1];; x := gens[2];; y := gens[3];; id := One(fq);;
  gap> polys := [x*y-y*x,x^2*y-id,x*y^2-id];
  [ (1)*x*y+(-1)*y*x, (-1)*u+(1)*x^2*y, (-1)*u+(1)*x*y^2 ]
\end{Verbatim}
 Then we ask GBNP for its Groebner basis: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gb := GBNPGroebnerBasisNC(polys,fq);
  The given path algebra is isomorphic to a free algebra.
  [ (-1)*x+(1)*y, (-1)*u+(1)*x^3 ]
\end{Verbatim}
 NOTE: It is important to realize that we've used the routine
`GBNPGroebnerBasisNC' which doesn't check that all elements in a given list
have non-vertex monomials. So, if we run the standard \textsf{QPA} Groebner basis routine on this example, we get the following: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GBNPGroebnerBasis(polys,pa);
  Please make sure all elements are in the given path algebra, 
  and each summand of each element is not (only) a vertex.
  false
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Quivers}}\label{Quivers}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7FA7E6B581D41A94}{}
{
 
\section{\textcolor{Chapter }{Information class, Quivers}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7C14F4617F7E9F09}{}
{
 A quiver $Q$ is a set derived from a labeled directed multigraph with loops $\Gamma$. An element of $Q$ is called a *path*, and falls into one of three classes. The first class is
the set of *vertices* of $\Gamma$. The second class is the set of *walks* in $\Gamma$ of length at least one, each of which is represented by the corresponding
sequence of *arrows* in $\Gamma$. The third class is the singleton set containing the distinguished *zero
path*, usually denoted $0$. An associative multiplication is defined on $Q$.

 This chapter describes the functions in \textsf{QPA} that deal with paths and quivers. The functions for constructing paths in
Section \ref{Constructing Paths} are normally not useful in isolation; typically, they are invoked by the
functions for constructing quivers in Section \ref{Constructing Quivers}. 

\subsection{\textcolor{Chapter }{InfoQuiver}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X786A65F07FA1BB78}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoQuiver\index{InfoQuiver@\texttt{InfoQuiver}}
\label{InfoQuiver}
}\hfill{\scriptsize (info class)}}\\


 is the info class for functions dealing with quivers. }

  }

 
\section{\textcolor{Chapter }{Constructing Quivers}}\label{Constructing Quivers}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X860B15D57EAB46D7}{}
{
 

\subsection{\textcolor{Chapter }{Quiver}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X871563F685BE93A2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape N, arrows})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape vertices, arrows})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape adjacencymatrix})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\


Arguments: First construction: \mbox{\texttt{\slshape N}} -- number of vertices, \mbox{\texttt{\slshape arrows}} -- a list of arrows to specify the graph $\Gamma$. Second construction: \mbox{\texttt{\slshape vertices}} -- a list of vertex names, \mbox{\texttt{\slshape arrows}} -- a list of arrows. Third construction: takes an adjacency matrix for the
graph $\Gamma$. \\
\textbf{\indent Returns:\ }
a quiver, which satisfies the property \texttt{IsQuiver} (\ref{IsQuiver}).



 In the first and third constructions, the vertices are named `v1, v2, ...'. In
the second construction, unique vertex names are given as strings in the list
that is the first parameter. Each arrow is a list consisting of a source
vertex and a target vertex, followed optionally by an arrow name as a string.

 Vertices and arrows are referenced as record components using the dot (`.')
operator. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> VerticesOfQuiver(q1);
  [ u, v ]
  gap> ArrowsOfQuiver(q1);
  [ a, b, c, d ]
  gap> q2 := Quiver(2,[[1,1],[2,1],[1,2]]);
  <quiver with 2 vertices and 3 arrows>
  gap> ArrowsOfQuiver(q2);
  [ a1, a2, a3 ]
  gap> VerticesOfQuiver(q2);
  [ v1, v2 ]
  gap> q3 := Quiver(2,[[1,1,"a"],[2,1,"b"],[1,2,"c"]]);
  <quiver with 2 vertices and 3 arrows>
  gap> ArrowsOfQuiver(q3);
  [ a, b, c ]
  gap> q4 := Quiver([[1,1],[2,1]]);
  <quiver with 2 vertices and 5 arrows>
  gap> VerticesOfQuiver(q4);
  [ v1, v2 ]
  gap> ArrowsOfQuiver(q4);
  [ a1, a2, a3, a4, a5 ]
  gap> SourceOfPath(q4.a2);
  v1
  gap> TargetOfPath(q4.a2);
  v2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{OrderedBy}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X83E498008233E2DD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderedBy({\slshape quiver, ordering})\index{OrderedBy@\texttt{OrderedBy}}
\label{OrderedBy}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a copy of \mbox{\texttt{\slshape quiver}} whose elements are ordered by \mbox{\texttt{\slshape ordering}}. The default ordering of a quiver is length left lexicographic. See Section \ref{qpa:Orderings} for more information.



 }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Quivers}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X80BB6B6183134D88}{}
{
 

\subsection{\textcolor{Chapter }{IsQuiver}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X7E9C03497FD7778B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsQuiver({\slshape object})\index{IsQuiver@\texttt{IsQuiver}}
\label{IsQuiver}
}\hfill{\scriptsize (property)}}\\
\textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape object}} is a quiver. 

}

 

\subsection{\textcolor{Chapter }{IsAcyclicQuiver}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X82E99C5F8624BD86}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsAcyclicQuiver({\slshape quiver})\index{IsAcyclicQuiver@\texttt{IsAcyclicQuiver}}
\label{IsAcyclicQuiver}
}\hfill{\scriptsize (property)}}\\
\textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape quiver}} is a quiver with no oriented cycles. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> quiver1 := Quiver(2,[[1,2]]);
  <quiver with 2 vertices and 1 arrows>
  gap> IsQuiver("v1");
  false
  gap> IsQuiver(quiver1);
  true
  gap> IsAcyclicQuiver(quiver1);
  true
  gap> quiver2 := Quiver(["u","v"],[["u","v"],["v","u"]]);
  <quiver with 2 vertices and 2 arrows>
  gap> IsAcyclicQuiver(quiver2);
  false
  gap> IsFinite(quiver1);
  true
  gap> IsFinite(quiver2);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Orderings of paths in a quiver}}\label{qpa:Orderings}
\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X78BBB63B828EB9FB}{}
{
 To be written. }

 
\section{\textcolor{Chapter }{Attributes and Operations for Quivers}}\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X80CF69E37B54F3C1}{}
{
 

\subsection{\textcolor{Chapter }{.}}
\logpage{[ 2, 5, 1 ]}\nobreak
\hyperdef{L}{X7821AC097821AC09}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{.({\slshape Q, element})\index{.@\texttt{.}}
\label{.}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape Q}} -- a quiver, and \mbox{\texttt{\slshape element}} -- a vertex or an arrow. 

 The operation \texttt{.} allows access to generators of the quiver. If you have named your vertices and
arrows then the access looks like `\mbox{\texttt{\slshape Q}}.\mbox{\texttt{\slshape name of element}}'. If you have not named the elements of the quiver then the default names are
v1, v2, ... and a1, a2, ... in the order they are created. }

 

\subsection{\textcolor{Chapter }{VerticesOfQuiver}}
\logpage{[ 2, 5, 2 ]}\nobreak
\hyperdef{L}{X7C82A4BC7FB329D8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VerticesOfQuiver({\slshape quiver})\index{VerticesOfQuiver@\texttt{VerticesOfQuiver}}
\label{VerticesOfQuiver}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of paths that are vertices in \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{ArrowsOfQuiver}}
\logpage{[ 2, 5, 3 ]}\nobreak
\hyperdef{L}{X82C42D7D820D5F9B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ArrowsOfQuiver({\slshape quiver})\index{ArrowsOfQuiver@\texttt{ArrowsOfQuiver}}
\label{ArrowsOfQuiver}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of paths that are arrows in \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{AdjacencyMatrixOfQuiver}}
\logpage{[ 2, 5, 4 ]}\nobreak
\hyperdef{L}{X7AF572F081AEFE98}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AdjacencyMatrixOfQuiver({\slshape quiver})\index{AdjacencyMatrixOfQuiver@\texttt{AdjacencyMatrixOfQuiver}}
\label{AdjacencyMatrixOfQuiver}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the adjacency matrix of \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{GeneratorsOfQuiver}}
\logpage{[ 2, 5, 5 ]}\nobreak
\hyperdef{L}{X7B4A7F0F813E63FC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorsOfQuiver({\slshape quiver})\index{GeneratorsOfQuiver@\texttt{GeneratorsOfQuiver}}
\label{GeneratorsOfQuiver}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of the vertices and the arrows in \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{NumberOfVertices}}
\logpage{[ 2, 5, 6 ]}\nobreak
\hyperdef{L}{X822BD7F37F8AF016}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumberOfVertices({\slshape quiver})\index{NumberOfVertices@\texttt{NumberOfVertices}}
\label{NumberOfVertices}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the number of vertices in \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{NumberOfArrows}}
\logpage{[ 2, 5, 7 ]}\nobreak
\hyperdef{L}{X7AC77C9C7D069663}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumberOfArrows({\slshape quiver})\index{NumberOfArrows@\texttt{NumberOfArrows}}
\label{NumberOfArrows}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the number of arrows in \mbox{\texttt{\slshape quiver}}. 

}

 

\subsection{\textcolor{Chapter }{OrderingOfQuiver}}
\logpage{[ 2, 5, 8 ]}\nobreak
\hyperdef{L}{X84D1D1AA82689B03}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderingOfQuiver({\slshape quiver})\index{OrderingOfQuiver@\texttt{OrderingOfQuiver}}
\label{OrderingOfQuiver}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the ordering used to order elements in \mbox{\texttt{\slshape quiver}}. See Section \ref{qpa:Orderings} for more information. 

}

 

\subsection{\textcolor{Chapter }{OppositeOfQuiver}}
\logpage{[ 2, 5, 9 ]}\nobreak
\hyperdef{L}{X825050BA7DCC6D43}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OppositeOfQuiver({\slshape quiver})\index{OppositeOfQuiver@\texttt{OppositeOfQuiver}}
\label{OppositeOfQuiver}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
 the opposite quiver of \mbox{\texttt{\slshape quiver}}, where the vertices are labelled "name in original quiver" +
"{\textunderscore}op" and the arrows are labelled "name in orginal quiver" +
"{\textunderscore}op". 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> q1.a;
  a
  gap> q1.v;
  v
  gap> VerticesOfQuiver(q1);
  [ u, v ]
  gap> ArrowsOfQuiver(q1);
  [ a, b, c, d ]
  gap> AdjacencyMatrixOfQuiver(q1);
  [ [ 1, 1 ], [ 1, 1 ] ]
  gap> GeneratorsOfQuiver(q1);
  [ u, v, a, b, c, d ]
  gap> NumberOfVertices(q1);
  2
  gap> NumberOfArrows(q1);
  4
  gap> OrderingOfQuiver(q1);
  <length left lexicographic ordering>
  gap> q1_op := OppositeOfQuiver(q1);
  <quiver with 2 vertices and 4 arrows>
  gap> VerticesOfQuiver(q1);
  [ u_op, v_op ]
  gap> ArrowsOfQuiver(q1);
  [ a_op, b_op, c_op, d_op ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Categories and Properties of Paths}}\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X862A804B80C5A47D}{}
{
 

\subsection{\textcolor{Chapter }{IsPath}}
\logpage{[ 2, 6, 1 ]}\nobreak
\hyperdef{L}{X78B503DB83F2B6DE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPath({\slshape object})\index{IsPath@\texttt{IsPath}}
\label{IsPath}
}\hfill{\scriptsize (category)}}\\


 All path objects are in this category. }

 

\subsection{\textcolor{Chapter }{IsVertex}}
\logpage{[ 2, 6, 2 ]}\nobreak
\hyperdef{L}{X7F06C7E48631922F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsVertex({\slshape object})\index{IsVertex@\texttt{IsVertex}}
\label{IsVertex}
}\hfill{\scriptsize (category)}}\\


 All vertices are in this category. }

 

\subsection{\textcolor{Chapter }{IsArrow}}
\logpage{[ 2, 6, 3 ]}\nobreak
\hyperdef{L}{X8266C9B8840C12EB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsArrow({\slshape object})\index{IsArrow@\texttt{IsArrow}}
\label{IsArrow}
}\hfill{\scriptsize (category)}}\\


 All arrows are in this category. }

 

\subsection{\textcolor{Chapter }{IsZeroPath}}
\logpage{[ 2, 6, 4 ]}\nobreak
\hyperdef{L}{X8624A0B0795149CF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsZeroPath({\slshape object})\index{IsZeroPath@\texttt{IsZeroPath}}
\label{IsZeroPath}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is the zero path. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> IsPath(q1.b);
  true
  gap> IsPath(q1.u);
  true
  gap> IsVertex(q1.c);
  false
  gap> IsZeroPath(q1.d);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations of Paths}}\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X7C8294338676C80E}{}
{
 

\subsection{\textcolor{Chapter }{SourceOfPath}}
\logpage{[ 2, 7, 1 ]}\nobreak
\hyperdef{L}{X84D8493C7AAF4ACC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SourceOfPath({\slshape path})\index{SourceOfPath@\texttt{SourceOfPath}}
\label{SourceOfPath}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the source (first) vertex of \mbox{\texttt{\slshape path}}. 

}

 

\subsection{\textcolor{Chapter }{TargetOfPath}}
\logpage{[ 2, 7, 2 ]}\nobreak
\hyperdef{L}{X86827D3F78F51815}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TargetOfPath({\slshape path})\index{TargetOfPath@\texttt{TargetOfPath}}
\label{TargetOfPath}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the target (last) vertex of \mbox{\texttt{\slshape path}}. 

}

 

\subsection{\textcolor{Chapter }{LengthOfPath}}
\logpage{[ 2, 7, 3 ]}\nobreak
\hyperdef{L}{X7FF179D17C4F9FAC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LengthOfPath({\slshape path})\index{LengthOfPath@\texttt{LengthOfPath}}
\label{LengthOfPath}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the length of \mbox{\texttt{\slshape path}}. 

}

 

\subsection{\textcolor{Chapter }{WalkOfPath}}
\logpage{[ 2, 7, 4 ]}\nobreak
\hyperdef{L}{X781A8E06850E47B4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WalkOfPath({\slshape path})\index{WalkOfPath@\texttt{WalkOfPath}}
\label{WalkOfPath}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of the arrows that constitute \mbox{\texttt{\slshape path}} in order. 

}

 

\subsection{\textcolor{Chapter }{*}}
\logpage{[ 2, 7, 5 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{*({\slshape p, q})\index{*@\texttt{*}}
\label{*}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}} -- two paths in the same quiver. \\
\textbf{\indent Returns:\ }
 the multiplication of the paths. If the paths are not in the same quiver an
error is returned. If the target of \mbox{\texttt{\slshape p}} differs from the source of \mbox{\texttt{\slshape q}}, then the result is the zero path. Otherwise, if either path is a vertex,
then the result is the other path. Finally, if both are paths of length at
least 1, then the result is the concatenation of the walks of the two paths. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> SourceOfPath(q1.v);                                                       
  v
  gap> p1:=q1.a*q1.b*q1.d*q1.d;
  a*b*d^2
  gap> TargetOfPath(p1);
  v
  gap> p2:=q1.b*q1.b;
  0
  gap> WalkOfPath(p1);
  [ a, b, d, d ]
  gap> WalkOfPath(q1.a);
  [ a ]
  gap> LengthOfPath(p1);
  4
  gap> LengthOfPath(q1.v);
  0
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 2, 7, 6 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{=({\slshape p, q})\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}} -- two paths in the same quiver. \\
\textbf{\indent Returns:\ }
 true if the two paths are equal. Two paths are equal if they have the same
source and the same target and if they have the same walks. 

}

 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 2, 7, 7 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape p, q})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}} -- two paths in the same quiver. \\
\textbf{\indent Returns:\ }
 a comparison of the two paths with respect to the ordering of the quiver. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1.a=q1.b;
  false
  gap> q1.a < q1.v;
  false
  gap> q1.a < q1.c;
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes of Vertices}}\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X8158F0D27C4628FB}{}
{
 

\subsection{\textcolor{Chapter }{IncomingArrowsOfVertex}}
\logpage{[ 2, 8, 1 ]}\nobreak
\hyperdef{L}{X85E53C177F80E77E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IncomingArrowsOfVertex({\slshape vertex})\index{IncomingArrowsOfVertex@\texttt{IncomingArrowsOfVertex}}
\label{IncomingArrowsOfVertex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of arrows having \mbox{\texttt{\slshape vertex}} as target. Only meaningful if \mbox{\texttt{\slshape vertex}} is in a quiver. 

}

 

\subsection{\textcolor{Chapter }{OutgoingArrowsOfVertex}}
\logpage{[ 2, 8, 2 ]}\nobreak
\hyperdef{L}{X8345D79381E46D73}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OutgoingArrowsOfVertex({\slshape vertex})\index{OutgoingArrowsOfVertex@\texttt{OutgoingArrowsOfVertex}}
\label{OutgoingArrowsOfVertex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of arrows having \mbox{\texttt{\slshape vertex}} as source. 

}

 

\subsection{\textcolor{Chapter }{InDegreeOfVertex}}
\logpage{[ 2, 8, 3 ]}\nobreak
\hyperdef{L}{X7C9CD0527CB9E6EF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InDegreeOfVertex({\slshape vertex})\index{InDegreeOfVertex@\texttt{InDegreeOfVertex}}
\label{InDegreeOfVertex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the number of arrows having \mbox{\texttt{\slshape vertex}} as target. Only meaningful if \mbox{\texttt{\slshape vertex}} is in a quiver. 

}

 

\subsection{\textcolor{Chapter }{OutDegreeOfVertex}}
\logpage{[ 2, 8, 4 ]}\nobreak
\hyperdef{L}{X7A09EB648070276D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OutDegreeOfVertex({\slshape vertex})\index{OutDegreeOfVertex@\texttt{OutDegreeOfVertex}}
\label{OutDegreeOfVertex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 the number of arrows having \mbox{\texttt{\slshape vertex}} as source. 

}

 

\subsection{\textcolor{Chapter }{NeighborsOfVertex}}
\logpage{[ 2, 8, 5 ]}\nobreak
\hyperdef{L}{X7A557B4C83B7C601}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NeighborsOfVertex({\slshape vertex})\index{NeighborsOfVertex@\texttt{NeighborsOfVertex}}
\label{NeighborsOfVertex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 a list of neighbors of \mbox{\texttt{\slshape vertex}}, that is, vertices that are targets of arrows having \mbox{\texttt{\slshape vertex}} as source. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> OutgoingArrowsOfVertex(q1.u);
  [ a, b ]
  gap> InDegreeOfVertex(q1.u);
  2
  gap> NeighborsOfVertex(q1.v);
  [ u, v ]
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Path Algebras}}\label{PathAlgebras}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7E8A43A484CE0BA8}{}
{
  
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  A path algebra is an algebra constructed from a field $F$ (see chapter 56 and 57 in the \textsf{GAP} manual for information about fields) and a quiver $Q$. The path algebra $FQ$ contains all finite linear combinations of paths of $Q$. This chapter describes the functions in \textsf{QPA} that deal with path algebras and quotients of path algebras. Path algebras are
algebras, so see chapter 60: Algebras in the \textsf{GAP} manual for functionality such as generators, basis functions, and mappings.        }

 
\section{\textcolor{Chapter }{Constructing Path Algebras}}\label{Constructing Paths}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X848A225A84A15B1E}{}
{
  

\subsection{\textcolor{Chapter }{PathAlgebra}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7CA1C87B8202C2E9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PathAlgebra({\slshape F, Q})\index{PathAlgebra@\texttt{PathAlgebra}}
\label{PathAlgebra}
}\hfill{\scriptsize (function)}}\\


Arguments: F -- a field, Q -- a quiver.\\
\textbf{\indent Returns:\ }
the path algebra $FQ$ of \mbox{\texttt{\slshape Q}} over the field \mbox{\texttt{\slshape F}}.



For construction of fields, see the \textsf{GAP} documentation. The elements of the path algebra $FQ$ will be ordered by left length-lexicographic ordering. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Q := Quiver( ["u","v"] , [ ["u","u","a"], ["u","v","b"],
  >["v","u","c"], ["v","v","d"] ] );
  <quiver with 2 vertices and 4 arrows>
  gap> F := Rationals;
  Rationals
  gap> FQ := PathAlgebra(F,Q);
  <algebra-with-one over Rationals, with 5 generators> 
\end{Verbatim}
            }

 
\section{\textcolor{Chapter }{Categories and Properties of Path Algebras}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X85A3A8767E7C11AD}{}
{
  

\subsection{\textcolor{Chapter }{IsPathAlgebra}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X8255FDF78315E1B3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebra({\slshape object})\index{IsPathAlgebra@\texttt{IsPathAlgebra}}
\label{IsPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}. \\
 \textbf{\indent Returns:\ }
true whenever \mbox{\texttt{\slshape object}} is a path algebra. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsPathAlgebra(FQ);
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Path Algebras}}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7DE2F2A48492041A}{}
{
 

\subsection{\textcolor{Chapter }{QuiverOfPathAlgebra}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X83FBA499856580B0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverOfPathAlgebra({\slshape FQ})\index{QuiverOfPathAlgebra@\texttt{QuiverOfPathAlgebra}}
\label{QuiverOfPathAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra. \\
 \textbf{\indent Returns:\ }
 the quiver from which \mbox{\texttt{\slshape FQ}} was constructed. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> QuiverOfPathAlgebra(FQ);
  <quiver with 2 vertices and 4 arrows> 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{OrderingOfAlgebra}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X8279084B828E5FD7}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderingOfAlgebra({\slshape FQ})\index{OrderingOfAlgebra@\texttt{OrderingOfAlgebra}}
\label{OrderingOfAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra.\\
 \textbf{\indent Returns:\ }
 the ordering of the quiver of the path algebra. 



\emph{Note:} As of the current version of \textsf{QPA}, only left length lexicographic ordering is supported. }

 

\subsection{\textcolor{Chapter }{.}}
\logpage{[ 3, 4, 3 ]}\nobreak
\hyperdef{L}{X7821AC097821AC09}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{.({\slshape FQ, generator})\index{.@\texttt{.}}
\label{.}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra, \mbox{\texttt{\slshape generator}} -- a vertex or an arrow in the quiver \mbox{\texttt{\slshape Q}}. \\
 \textbf{\indent Returns:\ }
 the \mbox{\texttt{\slshape generator}} as an element of the path algebra. 



Other elements of the path algebra can be constructed as linear combinations
of the generators. For further operations on elements, see below. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> FQ.a;
  (1)*a
  gap> FQ.v;
  (1)*v
  gap> elem := 2*FQ.a - 3*FQ.v;
  (-3)*v+(2)*a 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Operations on Path Algebra Elements}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X7CEF60107CE4616B}{}
{
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape a, b})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape a}} and \mbox{\texttt{\slshape b}} -- two elements of the same path algebra.\\
 \textbf{\indent Returns:\ }
 True whenever \mbox{\texttt{\slshape a}} is smaller than \mbox{\texttt{\slshape b}}, according to the ordering of the path algebra. 

}

 

\subsection{\textcolor{Chapter }{IsLeftUniform}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X853C8B0B8665BFBB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLeftUniform({\slshape element})\index{IsLeftUniform@\texttt{IsLeftUniform}}
\label{IsLeftUniform}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra.\\
 \textbf{\indent Returns:\ }
 true if each monomial in \mbox{\texttt{\slshape element}} has the same source vertex, false otherwise. 

}

 

\subsection{\textcolor{Chapter }{IsRightUniform}}
\logpage{[ 3, 5, 3 ]}\nobreak
\hyperdef{L}{X7C06BE7483992634}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsRightUniform({\slshape element})\index{IsRightUniform@\texttt{IsRightUniform}}
\label{IsRightUniform}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra.\\
 \textbf{\indent Returns:\ }
 true if each monomial in \mbox{\texttt{\slshape element}} has the same target vertex, false otherwise. 

}

 

\subsection{\textcolor{Chapter }{IsUniform}}
\logpage{[ 3, 5, 4 ]}\nobreak
\hyperdef{L}{X8735FBE180797557}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsUniform({\slshape element})\index{IsUniform@\texttt{IsUniform}}
\label{IsUniform}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra. \\
 \textbf{\indent Returns:\ }
 true whenever \mbox{\texttt{\slshape element}} is both left and right uniform. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsLeftUniform(elem);
  false
  gap> IsRightUniform(elem);
  false
  gap> IsUniform(elem);
  false
  gap> another := FQ.a*FQ.b + FQ.b*FQ.d*FQ.c*FQ.b*FQ.d;
  (1)*a*b+(1)*b*d*c*b*d
  gap> IsLeftUniform(another);
  true
  gap> IsRightUniform(another);
  true
  gap> IsUniform(another);
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LeadingTerm}}
\logpage{[ 3, 5, 5 ]}\nobreak
\hyperdef{L}{X84C98E687A3A84D8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingTerm({\slshape element})\index{LeadingTerm@\texttt{LeadingTerm}}
\label{LeadingTerm}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Tip({\slshape element})\index{Tip@\texttt{Tip}}
\label{Tip}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra. \\
 \textbf{\indent Returns:\ }
 the term in \mbox{\texttt{\slshape element}} whose monomial is largest among those monomials that have nonzero coefficients
(known as the "tip" of \mbox{\texttt{\slshape element}}). 



 \emph{Note: } The two operations are equivalent. }

 

\subsection{\textcolor{Chapter }{LeadingCoefficient}}
\logpage{[ 3, 5, 6 ]}\nobreak
\hyperdef{L}{X80710E9B7D8340BD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingCoefficient({\slshape element})\index{LeadingCoefficient@\texttt{LeadingCoefficient}}
\label{LeadingCoefficient}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipCoefficient({\slshape element})\index{TipCoefficient@\texttt{TipCoefficient}}
\label{TipCoefficient}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra. \\
 \textbf{\indent Returns:\ }
 the coefficient of the tip of \mbox{\texttt{\slshape element}} (which is an element of the field). 



 \emph{Note: } The two operations are equivalent. }

 

\subsection{\textcolor{Chapter }{LeadingMonomial}}
\logpage{[ 3, 5, 7 ]}\nobreak
\hyperdef{L}{X7B3EAE41795598A5}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingMonomial({\slshape element})\index{LeadingMonomial@\texttt{LeadingMonomial}}
\label{LeadingMonomial}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipMonomial({\slshape element})\index{TipMonomial@\texttt{TipMonomial}}
\label{TipMonomial}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra. \\
 \textbf{\indent Returns:\ }
 the monomial of the tip of \mbox{\texttt{\slshape element}} (which is an element of the underlying quiver, not of the path algebra). 



 \emph{Note: } The two operations are equivalent. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> elem := FQ.a*FQ.b*FQ.c + FQ.b*FQ.d*FQ.c+FQ.d*FQ.d;
  (1)*d^2+(1)*a*b*c+(1)*b*d*c
  gap> LeadingTerm(elem);
  (1)*b*d*c
  gap> LeadingCoefficient(elem);
  1
  gap> mon := LeadingMonomial(elem);
  b*d*c
  gap> mon in FQ;
  false
  gap> mon in Q;
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MakeUniformOnRight}}
\logpage{[ 3, 5, 8 ]}\nobreak
\hyperdef{L}{X8172B40181E1B7D2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MakeUniformOnRight({\slshape elems})\index{MakeUniformOnRight@\texttt{MakeUniformOnRight}}
\label{MakeUniformOnRight}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape elems}} -- a list of elements in a path algebra.\\
 \textbf{\indent Returns:\ }
 a list of right uniform elements generated by each element of \mbox{\texttt{\slshape elems}}. 

}

 

\subsection{\textcolor{Chapter }{MappedExpression}}
\logpage{[ 3, 5, 9 ]}\nobreak
\hyperdef{L}{X796249A682818750}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MappedExpression({\slshape expr, gens1, gens2})\index{MappedExpression@\texttt{MappedExpression}}
\label{MappedExpression}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape expr}} -- element of a path algebra, \mbox{\texttt{\slshape gens1}} and \mbox{\texttt{\slshape gens2}} -- equal-length lists of generators for subalgebras.\\
 \textbf{\indent Returns:\ }
 \mbox{\texttt{\slshape expr}} as an element of the subalgebra generated by \mbox{\texttt{\slshape gens2}}. 



 The element \mbox{\texttt{\slshape expr}} must be in the subalgebra generated by \mbox{\texttt{\slshape gens1}}. The lists define a mapping of each generator in \mbox{\texttt{\slshape gens1}} to the corresponding generator in \mbox{\texttt{\slshape gens2}}. The value returned is the evaluation of the mapping at \mbox{\texttt{\slshape expr}}. }

 

\subsection{\textcolor{Chapter }{VertexPosition}}
\logpage{[ 3, 5, 10 ]}\nobreak
\hyperdef{L}{X849AC0F67A131929}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VertexPosition({\slshape element})\index{VertexPosition@\texttt{VertexPosition}}
\label{VertexPosition}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of the path algebra on the form $k*v$, where $v$ is a vertex of the underlying quiver and $k$ is an element of the field.\\
 \textbf{\indent Returns:\ }
 the position of the vertex \mbox{\texttt{\slshape v}} in the list of vertices of the quiver. 

}

 }

 
\section{\textcolor{Chapter }{Constructing Quotients of Path Algebras}}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7F0D555379C97A6E}{}
{
  See Chapter 60: Algebras in the \textsf{GAP} manual on how to construct an ideal and a quotient of an algebra. When the
quotient is constructed, it is still a path algebra and thus the commands
introduced for path algebras also works with quotients. }

 
\section{\textcolor{Chapter }{Ideals}}\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X83629803819C4A6F}{}
{
 
\subsection{\textcolor{Chapter }{Ideals and operations on ideals}}\label{IdealsAndOperations}
\logpage{[ 3, 7, 1 ]}
\hyperdef{L}{X812C0F8D7E4B1134}{}
{
 }

 

\subsection{\textcolor{Chapter }{Ideal}}
\logpage{[ 3, 7, 2 ]}\nobreak
\hyperdef{L}{X82ACACDD7D8E9B25}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Ideal({\slshape FQ, elems})\index{Ideal@\texttt{Ideal}}
\label{Ideal}
}\hfill{\scriptsize (operation)}}\\


Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra, \mbox{\texttt{\slshape elems}} -- a list of elements in \mbox{\texttt{\slshape FQ}}.\\
 \textbf{\indent Returns:\ }
the ideal of \mbox{\texttt{\slshape FQ}} generated by \mbox{\texttt{\slshape elems}}. 



For more on ideals, see the \textsf{GAP} reference manual (chapter 60.6). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> I := Ideal(FQ, [FQ.a - FQ.b*FQ.c, FQ.d*FQ.d]); 
  <two-sided ideal in <algebra-with-one over Rationals, with 6
    generators>, (2 generators)>
  gap> GeneratorsOfIdeal(I);
  [ (1)*a+(-1)*b*c, (1)*d^2 ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NthPowerOfArrowIdeal}}
\logpage{[ 3, 7, 3 ]}\nobreak
\hyperdef{L}{X830187497E0BD4F0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NthPowerOfArrowIdeal({\slshape FQ, n})\index{NthPowerOfArrowIdeal@\texttt{NthPowerOfArrowIdeal}}
\label{NthPowerOfArrowIdeal}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra, \mbox{\texttt{\slshape n}} -- a positive integer.\\
 \textbf{\indent Returns:\ }
 the ideal generated all the paths of length \mbox{\texttt{\slshape n}} in \mbox{\texttt{\slshape FQ}}. 

}

 

\subsection{\textcolor{Chapter }{AddNthPowerToRelations}}
\logpage{[ 3, 7, 4 ]}\nobreak
\hyperdef{L}{X824D550E8371098C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AddNthPowerToRelations({\slshape FQ, rels, n})\index{AddNthPowerToRelations@\texttt{AddNthPowerToRelations}}
\label{AddNthPowerToRelations}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a path algebra, \mbox{\texttt{\slshape rels}} -- a (possibly empty) list of elements in \mbox{\texttt{\slshape FQ}}, \mbox{\texttt{\slshape n}} -- a positive integer.\\
 \textbf{\indent Returns:\ }
 the list \mbox{\texttt{\slshape rels}} with the paths of length \mbox{\texttt{\slshape n}} of \mbox{\texttt{\slshape FQ}} appended (will change the list \mbox{\texttt{\slshape rels}}). 

}

 
\subsection{\textcolor{Chapter }{Attributes of ideals}}\label{AttributesOfIdeals}
\logpage{[ 3, 7, 5 ]}
\hyperdef{L}{X85D4E72B787B1C49}{}
{
 For many of the functions related to quotients, you will need to compute a
Groebner basis of the ideal. This is done with the GBNP package. The following
example shows how to set a Groebner basis for an ideal (note that this must be
done before the quotient is constructed). See the next two chapters for more
on Groebner bases. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> rels := [FQ.a - FQ.b*FQ.c, FQ.d*FQ.d];
  [ (1)*a+(-1)*b*c, (1)*d^2 ]
  gap> gb := GBNPGroebnerBasis(rels, FQ); 
  [ (-1)*a+(1)*b*c, (1)*d^2 ]
  gap> I := Ideal(FQ, gb);
  <two-sided ideal in <algebra-with-one over Rationals, with 6
    generators>, (2 generators)>
  gap> GroebnerBasis(I, gb);
  <complete two-sided Groebner basis containing 2 elements>
  gap> quot := FQ/I;
  <algebra-with-one over Rationals, with 6 generators> 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Quotients of Path Algebras}}\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X7A3CA333873389AD}{}
{
  

\subsection{\textcolor{Chapter }{IsQuotientOfPathAlgebra}}
\logpage{[ 3, 8, 1 ]}\nobreak
\hyperdef{L}{X790DB9BF831B577D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsQuotientOfPathAlgebra({\slshape object})\index{IsQuotientOfPathAlgebra@\texttt{IsQuotientOfPathAlgebra}}
\label{IsQuotientOfPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}.\\
 \textbf{\indent Returns:\ }
 true whenever \mbox{\texttt{\slshape object}} is a quotient of a path algebra. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> quot := FQ/I;
  <algebra-with-one over Rationals, with 6 generators>
  gap> IsQuotientOfPathAlgebra(quot);
  true
  gap> IsQuotientOfPathAlgebra(FQ);   
  false 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Quotients of Path Algebras}}\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X86647D317A961513}{}
{
          

\subsection{\textcolor{Chapter }{IsElementOfQuotientOfPathAlgebra}}
\logpage{[ 3, 9, 1 ]}\nobreak
\hyperdef{L}{X87495684791B5742}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsElementOfQuotientOfPathAlgebra({\slshape object})\index{IsElementOfQuotientOfPathAlgebra@\texttt{IsElementOfQuotientOfPathAlgebra}}
\label{IsElementOfQuotientOfPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}.\\
 \textbf{\indent Returns:\ }
 true whenever \mbox{\texttt{\slshape object}} is an element of some quotient of a path algebra. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> elem := quot.a*quot.b;
  [(1)*a*b]
  gap> IsElementOfQuotientOfPathAlgebra(elem);
  true
  gap> IsElementOfQuotientOfPathAlgebra(FQ.a*FQ.b);    
  false 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Coefficients}}
\logpage{[ 3, 9, 2 ]}\nobreak
\hyperdef{L}{X80B32F667BF6AFD8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Coefficients({\slshape element})\index{Coefficients@\texttt{Coefficients}}
\label{Coefficients}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{Coefficients} operates on an \mbox{\texttt{\slshape element}} of a quotient of a path algebra, and it returns the coefficients of the \mbox{\texttt{\slshape element}} in terms of its canonical basis. \\
 \emph{Note: Not in QPA, takes two arguments in \textsf{GAP}.} }

 

\subsection{\textcolor{Chapter }{IsSelfinjectiveAlgebra}}
\logpage{[ 3, 9, 3 ]}\nobreak
\hyperdef{L}{X8555FC6B85FE9C6D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSelfinjectiveAlgebra({\slshape A})\index{IsSelfinjectiveAlgebra@\texttt{IsSelfinjectiveAlgebra}}
\label{IsSelfinjectiveAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
fail if \mbox{\texttt{\slshape A}} is not finite dimensional. Otherwise it returns true or false according to
whether \mbox{\texttt{\slshape A}} is selfinjective or not. 

}

 

\subsection{\textcolor{Chapter }{IsSymmetricAlgebra}}
\logpage{[ 3, 9, 4 ]}\nobreak
\hyperdef{L}{X79DA912C82D01EE8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSymmetricAlgebra({\slshape A})\index{IsSymmetricAlgebra@\texttt{IsSymmetricAlgebra}}
\label{IsSymmetricAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
fail if \mbox{\texttt{\slshape A}} is not finite dimensional or does not have a Groebner basis. Otherwise it
returns true or false according to whether \mbox{\texttt{\slshape A}} is symmetric or not. 

}

 

\subsection{\textcolor{Chapter }{IsWeaklySymmetricAlgebra}}
\logpage{[ 3, 9, 5 ]}\nobreak
\hyperdef{L}{X7EF281F980319375}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsWeaklySymmetricAlgebra({\slshape A})\index{IsWeaklySymmetricAlgebra@\texttt{IsWeaklySymmetricAlgebra}}
\label{IsWeaklySymmetricAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
fail if \mbox{\texttt{\slshape A}} is not finite dimensional or does not have a Groebner basis. Otherwise it
returns true or false according to whether \mbox{\texttt{\slshape A}} is weakly symmetric or not. 

}

 

\subsection{\textcolor{Chapter }{LoewyLength}}
\logpage{[ 3, 9, 6 ]}\nobreak
\hyperdef{L}{X7BEA44FB819910B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LoewyLength({\slshape A})\index{LoewyLength@\texttt{LoewyLength}}
\label{LoewyLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
 fail if \mbox{\texttt{\slshape A}} is not finite dimensional. Otherwise it returns the Loewy length of the
algebra \mbox{\texttt{\slshape A}}. 

}

 

\subsection{\textcolor{Chapter }{CartanMatrix}}
\logpage{[ 3, 9, 7 ]}\nobreak
\hyperdef{L}{X84E3FEF587CB66C3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CartanMatrix({\slshape A})\index{CartanMatrix@\texttt{CartanMatrix}}
\label{CartanMatrix}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
the Cartan matrix of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. 

}

 

\subsection{\textcolor{Chapter }{CoxeterMatrix}}
\logpage{[ 3, 9, 8 ]}\nobreak
\hyperdef{L}{X815CB1D47CB174ED}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoxeterMatrix({\slshape A})\index{CoxeterMatrix@\texttt{CoxeterMatrix}}
\label{CoxeterMatrix}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
 the Coxeter matrix of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. 

}

 

\subsection{\textcolor{Chapter }{CoxeterPolynomial}}
\logpage{[ 3, 9, 9 ]}\nobreak
\hyperdef{L}{X7F6F526C86052150}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoxeterPolynomial({\slshape A})\index{CoxeterPolynomial@\texttt{CoxeterPolynomial}}
\label{CoxeterPolynomial}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
 the Coxeter polynomial of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. 

}

 

\subsection{\textcolor{Chapter }{Centre/Center}}
\logpage{[ 3, 9, 10 ]}\nobreak
\hyperdef{L}{X80E403A8855F6F7A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Centre/Center({\slshape A})\index{Centre/Center@\texttt{Centre/Center}}
\label{Centre/Center}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a path algebra or a quotient of a path algebra.\\
 \textbf{\indent Returns:\ }
 the centre of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra (the check is not
implemented and also not implemented for path algebras). 

}

 }

 
\section{\textcolor{Chapter }{Attributes and Operations on Elements of Quotients of Path Algebra}}\logpage{[ 3, 10, 0 ]}
\hyperdef{L}{X7BD7DB497917893C}{}
{
 

\subsection{\textcolor{Chapter }{IsNormalForm}}
\logpage{[ 3, 10, 1 ]}\nobreak
\hyperdef{L}{X8271E6F27C2C826E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsNormalForm({\slshape element})\index{IsNormalForm@\texttt{IsNormalForm}}
\label{IsNormalForm}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape element}} -- an element of a path algebra.\\
 \textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape element}} is known to be in normal form. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
   gap> IsNormalForm(elem);  
   true  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 3, 10, 2 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape a, b})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape a}} and \mbox{\texttt{\slshape b}} -- elements from a path algebra.\\
 \textbf{\indent Returns:\ }
true whenever \mbox{\texttt{\slshape a}} {\textless} \mbox{\texttt{\slshape b}}. 

}

  

\subsection{\textcolor{Chapter }{ElementOfQuotientOfPathAlgebra}}
\logpage{[ 3, 10, 3 ]}\nobreak
\hyperdef{L}{X7F2527747A3D0D6D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ElementOfQuotientOfPathAlgebra({\slshape family, element, computenormal})\index{ElementOfQuotientOfPathAlgebra@\texttt{ElementOfQuotientOfPathAlgebra}}
\label{ElementOfQuotientOfPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape family}} -- a family of elements, \mbox{\texttt{\slshape element}} -- an element of a path algebra, \mbox{\texttt{\slshape computenormal}} -- true or false.\\
 \textbf{\indent Returns:\ }
The projection of \mbox{\texttt{\slshape element}} into the quotient given by \mbox{\texttt{\slshape family}}. If \mbox{\texttt{\slshape computenormal}} is true, then the normal form of the projection of \mbox{\texttt{\slshape element}} is returned. 



\mbox{\texttt{\slshape family}} is the ElementsFamily of the family of the algebra \mbox{\texttt{\slshape element}} is projected into. }

 

\subsection{\textcolor{Chapter }{ElementOfPathAlgebra}}
\logpage{[ 3, 10, 4 ]}\nobreak
\hyperdef{L}{X841C00E87E19528E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ElementOfPathAlgebra({\slshape PA, path})\index{ElementOfPathAlgebra@\texttt{ElementOfPathAlgebra}}
\label{ElementOfPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape PA}} -- a path algebra, \mbox{\texttt{\slshape path}} -- a path in the quiver from which PA was constructed.\\
 \textbf{\indent Returns:\ }
The embedding of \mbox{\texttt{\slshape path}} into the path algebra \mbox{\texttt{\slshape PA}}, or it returns false if \mbox{\texttt{\slshape path}} is not an element of the quiver from which PA was constructed. 

}

 

\subsection{\textcolor{Chapter }{OriginalPathAlgebra}}
\logpage{[ 3, 10, 5 ]}\nobreak
\hyperdef{L}{X8088721187BA8D82}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OriginalPathAlgebra({\slshape algebra})\index{OriginalPathAlgebra@\texttt{OriginalPathAlgebra}}
\label{OriginalPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape algebra}} -- an algebra.\\
 \textbf{\indent Returns:\ }
a path algebra.



If \mbox{\texttt{\slshape algebra}} is a quotient of a path algebra or just a path algebra itself, the returned
algebra is the path algebra it was constructed from. Otherwise it returns an
error saying that the algebra entered was not a quotient of a path algebra. }

 }

 
\section{\textcolor{Chapter }{Predefined classes of (quotients of) path algebras}}\label{qpa:predefinedalgebras}
\logpage{[ 3, 11, 0 ]}
\hyperdef{L}{X7E36CEF47FB42031}{}
{
 

\subsection{\textcolor{Chapter }{CanonicalAlgebra}}
\logpage{[ 3, 11, 1 ]}\nobreak
\hyperdef{L}{X7E63A4F37856A075}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CanonicalAlgebra({\slshape field, weights[, relcoeff]})\index{CanonicalAlgebra@\texttt{CanonicalAlgebra}}
\label{CanonicalAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape field}} -- a field, \mbox{\texttt{\slshape weights}} -- a list of positive integers, [, relcoeff -- a list of non-zero elements in
the field.\\
 \textbf{\indent Returns:\ }
the canonical algebra over the \mbox{\texttt{\slshape field}} with the quiver given by the weight sequence \mbox{\texttt{\slshape weights}} and the relations given by the coefficients \mbox{\texttt{\slshape relcoeff}}. 



It function checks if all the \mbox{\texttt{\slshape weights}} are greater or equal to two, the number of weights is at least two, the number
of coefficients is the number of \mbox{\texttt{\slshape weights}} - 2, the coefficients for the relations are in field and non-zero. If only the
two first arguments are given, then the number of weights must be two. }

 

\subsection{\textcolor{Chapter }{KroneckerAlgebra}}
\logpage{[ 3, 11, 2 ]}\nobreak
\hyperdef{L}{X83498D3D856CC08A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KroneckerAlgebra({\slshape field, n})\index{KroneckerAlgebra@\texttt{KroneckerAlgebra}}
\label{KroneckerAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape field}} -- a field, \mbox{\texttt{\slshape n}} -- a positive integer.\\
 \textbf{\indent Returns:\ }
the \mbox{\texttt{\slshape n}}-Kronecker algebra over the field \mbox{\texttt{\slshape field}}. 



It function checks if the number \mbox{\texttt{\slshape n}} of arrows is greater or equal to two and returns an error message if not. }

 

\subsection{\textcolor{Chapter }{NakayamaAlgebra}}
\logpage{[ 3, 11, 3 ]}\nobreak
\hyperdef{L}{X7C678A08836F77CC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NakayamaAlgebra({\slshape admiss-seq, field})\index{NakayamaAlgebra@\texttt{NakayamaAlgebra}}
\label{NakayamaAlgebra}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape admiss-seq}} -- a list of positive integers, \mbox{\texttt{\slshape field}} -- a field.\\
 \textbf{\indent Returns:\ }
 The Nakayama algebra corresponding to \mbox{\texttt{\slshape admiss-seq}} over the field \mbox{\texttt{\slshape field}}. If the entered sequence is not an admissible sequence, the sequence is
returned. 



The \mbox{\texttt{\slshape admiss-seq}} consists of the dimensions of the projective representations.}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> alg := NakayamaAlgebra([2,1], Rationals);
  <algebra-with-one over Rationals, with 3 generators>
  gap> QuiverOfPathAlgebra(alg);
  <quiver with 2 vertices and 1 arrows>  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TruncatedPathAlgebra}}
\logpage{[ 3, 11, 4 ]}\nobreak
\hyperdef{L}{X7EF1AE62790D7486}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TruncatedPathAlgebra({\slshape F, Q, n})\index{TruncatedPathAlgebra@\texttt{TruncatedPathAlgebra}}
\label{TruncatedPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape F}} -- a field, \mbox{\texttt{\slshape Q}} -- a quiver, \mbox{\texttt{\slshape n}} -- a positive integer.\\
 \textbf{\indent Returns:\ }
the truncated path algebra \mbox{\texttt{\slshape KQ/I}}, where \mbox{\texttt{\slshape I}} is the ideal generated by all paths of length \mbox{\texttt{\slshape n}} in \mbox{\texttt{\slshape KQ}}. 

}

 }

 
\section{\textcolor{Chapter }{Tensor products of path algebras}}\label{qpa:patensor}
\logpage{[ 3, 12, 0 ]}
\hyperdef{L}{X842527EC7F90C8C5}{}
{
  If $\Lambda$ and $\Gamma$ are quotients of path algebras over the same field $F$, then their tensor product $\Lambda \tensor_F \Gamma$ is also a quotient of a path algebra over $F$.

 The quiver for the tensor product path algebra is the \texttt{QuiverProduct} (\ref{QuiverProduct}) of the quivers of the original algebras.

 The operation \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras}) computes the tensor products of two quotients of path algebras as a quotient
of a path algebra. 

\subsection{\textcolor{Chapter }{QuiverProduct}}
\logpage{[ 3, 12, 1 ]}\nobreak
\hyperdef{L}{X835BBBE18104654A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverProduct({\slshape Q1, Q2})\index{QuiverProduct@\texttt{QuiverProduct}}
\label{QuiverProduct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape Q1}} and \mbox{\texttt{\slshape Q2}} -- quivers.\\
 \textbf{\indent Returns:\ }
 the product quiver $\mbox{\texttt{\slshape Q1}} \quiverproduct \mbox{\texttt{\slshape Q2}}$. 



 A vertex in $\mbox{\texttt{\slshape Q1}} \quiverproduct \mbox{\texttt{\slshape Q2}}$ which is made by combining a vertex named \texttt{u} in \mbox{\texttt{\slshape Q1}} with a vertex \texttt{v} in \mbox{\texttt{\slshape Q2}} is named \texttt{u{\textunderscore}v}. Arrows are named similarly (they are made by combining an arrow from one
quiver with a vertex from the other). }

 

\subsection{\textcolor{Chapter }{QuiverProductDecomposition}}
\logpage{[ 3, 12, 2 ]}\nobreak
\hyperdef{L}{X858517C18242C2F1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverProductDecomposition({\slshape Q})\index{QuiverProductDecomposition@\texttt{QuiverProductDecomposition}}
\label{QuiverProductDecomposition}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape Q}} -- a quiver.\\
 \textbf{\indent Returns:\ }
 the original quivers \mbox{\texttt{\slshape Q}} is a product of, if \mbox{\texttt{\slshape Q}} was created by the \texttt{QuiverProduct} (\ref{QuiverProduct}) operation. 



 The value of this attribute is an object in the category \texttt{IsQuiverProductDecomposition} (\ref{IsQuiverProductDecomposition}). }

 

\subsection{\textcolor{Chapter }{IsQuiverProductDecomposition}}
\logpage{[ 3, 12, 3 ]}\nobreak
\hyperdef{L}{X80E3731882B80106}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsQuiverProductDecomposition({\slshape object})\index{IsQuiverProductDecomposition@\texttt{IsQuiverProductDecomposition}}
\label{IsQuiverProductDecomposition}
}\hfill{\scriptsize (category)}}\\


 Arguments: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}. 

 Category for objects containing information about the relation between a
product quiver and the quivers it is a product of. The quiver factors can be
extracted from the decomposition object by using the [] notation (like
accessing elements of a list). The decomposition object is also used by the
operations \texttt{IncludeInProductQuiver} (\ref{IncludeInProductQuiver}) and \texttt{ProjectFromProductQuiver} (\ref{ProjectFromProductQuiver}). }

 

\subsection{\textcolor{Chapter }{IncludeInProductQuiver}}
\logpage{[ 3, 12, 4 ]}\nobreak
\hyperdef{L}{X856E8B5B7F550647}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IncludeInProductQuiver({\slshape L, Q})\index{IncludeInProductQuiver@\texttt{IncludeInProductQuiver}}
\label{IncludeInProductQuiver}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape L}} -- a list containing the paths $q_1$ and $q_2$, $Q$ -- a product quiver.\\
 \textbf{\indent Returns:\ }
a path in \mbox{\texttt{\slshape Q}}. 



 Includes paths $q_1$ and $q_2$ from two quivers into the product of these quivers, \mbox{\texttt{\slshape Q}}. If at least one of $q_1$ and $q_2$ is a vertex, there is exactly one possible inclusion. If they are both
non-trivial paths, there are several possibilities. This operation constructs
the path which is the inclusion of $q_1$ at the source of $q_2$ multiplied with the inclusion of $q_2$ at the target of $q_1$. }

 

\subsection{\textcolor{Chapter }{ProjectFromProductQuiver}}
\logpage{[ 3, 12, 5 ]}\nobreak
\hyperdef{L}{X8455692C7E282C6C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ProjectFromProductQuiver({\slshape i, p})\index{ProjectFromProductQuiver@\texttt{ProjectFromProductQuiver}}
\label{ProjectFromProductQuiver}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape i}} -- a positive integer, \mbox{\texttt{\slshape p}} -- a path in the product quiver.\\
 \textbf{\indent Returns:\ }
the projection of the product quiver path \mbox{\texttt{\slshape p}} to one of the factors. Which factor it should be projected to is specified by
the argument \mbox{\texttt{\slshape i}}. 

}

 The following example shows how the operations related to quiver products are
used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
  <quiver with 2 vertices and 1 arrows>
  gap> q2 := Quiver( [ "v1", "v2", "v3" ],
                        [ [ "v1", "v2", "b" ],
                          [ "v2", "v3", "c" ] ] );
  <quiver with 3 vertices and 2 arrows>
  gap> q1_q2 := QuiverProduct( q1, q2 );
  <quiver with 6 vertices and 7 arrows>
  gap> q1_q2.u1_b * q1_q2.a_v2;
  u1_b*a_v2
  gap> IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );
  a_v1*u2_b*u2_c
  gap> ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );
  b*c
  gap> q1_q2_dec := QuiverProductDecomposition( q1_q2 );
  <object>
  gap> q1_q2_dec[ 1 ];
  <quiver with 2 vertices and 1 arrows>
  gap> q1_q2_dec[ 1 ] = q1;
  true  
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TensorProductOfAlgebras}}
\logpage{[ 3, 12, 6 ]}\nobreak
\hyperdef{L}{X7A9026937BDDFA6C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TensorProductOfAlgebras({\slshape FQ1, FQ2})\index{TensorProductOfAlgebras@\texttt{TensorProductOfAlgebras}}
\label{TensorProductOfAlgebras}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape FQ1}} and \mbox{\texttt{\slshape FQ2}} -- (quotients of) path algebras.\\
 \textbf{\indent Returns:\ }
 The tensor product of \mbox{\texttt{\slshape FQ1}} and \mbox{\texttt{\slshape FQ2}}. 



 The result is a quotient of a path algebra, whose quiver is the \texttt{QuiverProduct} (\ref{QuiverProduct}) of the quivers of the operands. }

 

\subsection{\textcolor{Chapter }{SimpleTensor}}
\logpage{[ 3, 12, 7 ]}\nobreak
\hyperdef{L}{X7B31F4F680135E72}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SimpleTensor({\slshape L, T})\index{SimpleTensor@\texttt{SimpleTensor}}
\label{SimpleTensor}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape L}} -- a list containing two elements $x$ and $y$ of two (quotients of) path algebras, \mbox{\texttt{\slshape T}} -- the tensor product of these algebras.\\
 \textbf{\indent Returns:\ }
 the simple tensor $x \tensor y$. 



 $x \tensor y$ is in the tensor product \mbox{\texttt{\slshape T}} (produced by \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras})). }

 

\subsection{\textcolor{Chapter }{TensorProductDecomposition}}
\logpage{[ 3, 12, 8 ]}\nobreak
\hyperdef{L}{X7F0EBF88866A537D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TensorProductDecomposition({\slshape T})\index{TensorProductDecomposition@\texttt{TensorProductDecomposition}}
\label{TensorProductDecomposition}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape T}} -- a tensor product of path algebras.\\
 \textbf{\indent Returns:\ }
a list of the factors in the tensor product. 



\mbox{\texttt{\slshape T}} should be produced by \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras})). }

 The following example shows how the operations for tensor products of
quotients of path algebras are used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
  <quiver with 2 vertices and 1 arrows>
  gap> q2 := Quiver( [ "v1", "v2", "v3", "v4" ],
                        [ [ "v1", "v2", "b" ],
                          [ "v1", "v3", "c" ],
                          [ "v2", "v4", "d" ],
                          [ "v3", "v4", "e" ] ] );
  <quiver with 4 vertices and 4 arrows>
  gap> fq1 := PathAlgebra( Rationals, q1 );
  <algebra-with-one over Rationals, with 3 generators>
  gap> fq2 := PathAlgebra( Rationals, q2 );
  <algebra-with-one over Rationals, with 8 generators>
  gap> I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );
  <two-sided ideal in <algebra-with-one over Rationals, with 8 generators>,
   (1 generators)>
  gap> quot := fq2 / I;
  <algebra-with-one over Rationals, with 8 generators>
  gap> t := TensorProductOfAlgebras( fq1, quot );
  <algebra-with-one over Rationals, with 20 generators>
  gap> SimpleTensor( [ fq1.a, quot.b ], t );
  [(1)*a_v1*u2_b]
  gap> t_dec := TensorProductDecomposition( t );
  [ <algebra-with-one over Rationals, with 3 generators>, 
    <algebra-with-one over Rationals, with 8 generators> ]
  gap> t_dec[ 1 ] = fq1;
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{EnvelopingAlgebra}}
\logpage{[ 3, 12, 9 ]}\nobreak
\hyperdef{L}{X820195C47E2BE7E0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EnvelopingAlgebra({\slshape FQ})\index{EnvelopingAlgebra@\texttt{EnvelopingAlgebra}}
\label{EnvelopingAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape FQ}} -- a (quotient of) a path algebra. \\
 \textbf{\indent Returns:\ }
the enveloping algebra $\mbox{\texttt{\slshape FQ}}^\text{e} = \mbox{\texttt{\slshape FQ}} \tensor \mbox{\texttt{\slshape FQ}}^\text{op}$ of \mbox{\texttt{\slshape FQ}} 

}

 

\subsection{\textcolor{Chapter }{IsEnvelopingAlgebra}}
\logpage{[ 3, 12, 10 ]}\nobreak
\hyperdef{L}{X7AE13B567B5F72FC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsEnvelopingAlgebra({\slshape A})\index{IsEnvelopingAlgebra@\texttt{IsEnvelopingAlgebra}}
\label{IsEnvelopingAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- an algebra.\\
 \textbf{\indent Returns:\ }
true if and only if \mbox{\texttt{\slshape A}} is the result of a call to \texttt{EnvelopingAlgebra} (\ref{EnvelopingAlgebra}). 

}

 }

 }

 
\chapter{\textcolor{Chapter }{Groebner Basis}}\label{Groebner-Basis}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X8371E66387CB2E49}{}
{
 This chapter contains the declarations and implementations needed for Groebner
basis. Currently, we do not provide algorithms to actually compute Groebner
basis; instead, the declarations and implementations are provided here for \textsf{GAP} objects and the actual elements of Groebner basis are computed by the \textsf{GBNP} package. 
\section{\textcolor{Chapter }{Constructing a Groebner Basis}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X850B47047FD4D709}{}
{
 

\subsection{\textcolor{Chapter }{InfoGroebnerBasis}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X8451936885F68598}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoGroebnerBasis\index{InfoGroebnerBasis@\texttt{InfoGroebnerBasis}}
\label{InfoGroebnerBasis}
}\hfill{\scriptsize (info class)}}\\


 is the info class for functions dealing with Groebner basis. }

 

\subsection{\textcolor{Chapter }{GroebnerBasis}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7A43611E876B7560}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GroebnerBasis({\slshape A, rels})\index{GroebnerBasis@\texttt{GroebnerBasis}}
\label{GroebnerBasis}
}\hfill{\scriptsize (function)}}\\


Arguments: \mbox{\texttt{\slshape I}} -- an ideal, \mbox{\texttt{\slshape rels}} -- a list of relations generating \mbox{\texttt{\slshape I}}.\\
 \textbf{\indent Returns:\ }
 an object \mbox{\texttt{\slshape GB}} in the `IsGroebnerBasis' category with `IsCompleteGroebnerBasis' property set
on true.



 Sets also \mbox{\texttt{\slshape GB}} as a value of the attribute GroebnerBasisOfIdeal for \mbox{\texttt{\slshape I}} (so one has an access to it by calling GroebnerBasisOfIdeal(\mbox{\texttt{\slshape I}})).\\
 There are absolutely no computations and no checks for correctness in this
function. Giving a set of relations that does not form a Groebner basis may
result in incorrect answers or unexpected errors. This function is intended to
be used by packages providing access to external Groebner basis programs and
should be invoked before further computations on Groebner basis or ideal I. }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Groebner Basis}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X79C7DC5D873A14D0}{}
{
 

\subsection{\textcolor{Chapter }{IsGroebnerBasis}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7BFD28E687AADFBB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGroebnerBasis({\slshape object})\index{IsGroebnerBasis@\texttt{IsGroebnerBasis}}
\label{IsGroebnerBasis}
}\hfill{\scriptsize (category)}}\\


 Arguments: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}. \\
 \textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape object}} is a Groebner basis and false otherwise. 



The function only returns true for Groebner bases that has been set as such
using the \texttt{Groebner Basis} function, as illustrated in the following example. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Q := Quiver( 3, [ [1,2,"a"], [2,3,"b"] ] );
  <quiver with 3 vertices and 2 arrows>
  gap> PA := PathAlgebra( Rationals, Q );
  <algebra-with-one over Rationals, with 5 generators>
  gap> rels := [ PA.a*PA.b ];
  [ (1)*a*b ]
  gap> gb := GBNPGroebnerBasis( rels, PA );
  [ (1)*a*b ]
  gap> I := Ideal( PA, gb );
  <two-sided ideal in <algebra-with-one over Rationals, with 5 generators>, 
    (1 generators)>
  gap> grb := GroebnerBasis( I, gb );
  <complete two-sided Groebner basis containing 1 elements>
  gap> alg := PA/I;
  <algebra-with-one over Rationals, with 5 generators>
  gap> IsGroebnerBasis(gb);
  false
  gap> IsGroebnerBasis(grb);
  true 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsTipReducedGroebnerBasis}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X8592E4C87E41A15A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsTipReducedGroebnerBasis({\slshape gb})\index{IsTipReducedGroebnerBasis@\texttt{IsTipReducedGroebnerBasis}}
\label{IsTipReducedGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner Basis.\\
 \textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape GB}} is a Groebner basis which is tip reduced. 

}

 

\subsection{\textcolor{Chapter }{IsCompletelyReducedGroebnerBasis}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X85C0C1CD87C70AAA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCompletelyReducedGroebnerBasis({\slshape gb})\index{IsCompletelyReducedGroebnerBasis@\texttt{IsCompletelyReducedGroebnerBasis}}
\label{IsCompletelyReducedGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape GB}} is a Groebner basis which is completely reduced. 

}

 

\subsection{\textcolor{Chapter }{IsHomogeneousGroebnerBasis}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X799FD421784D1FFC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsHomogeneousGroebnerBasis({\slshape gb})\index{IsHomogeneousGroebnerBasis@\texttt{IsHomogeneousGroebnerBasis}}
\label{IsHomogeneousGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
 true when \mbox{\texttt{\slshape GB}} is a Groebner basis which is homogenous. 

}

 

\subsection{\textcolor{Chapter }{IsCompleteGroebnerBasis}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X86E7D0AE87CA048D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCompleteGroebnerBasis({\slshape gb})\index{IsCompleteGroebnerBasis@\texttt{IsCompleteGroebnerBasis}}
\label{IsCompleteGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
true when \mbox{\texttt{\slshape GB}} is a complete Groebner basis. 



 While philosophically something that isn't a complete Groebner basis isn't a
Groebner basis at all, this property can be used in conjuction with other
properties to see if the the Groebner basis contains enough information for
computations. An example of a system that creates incomplete Groebner bases is
`Opal'.\\
 \emph{Note:} The current package used for creating Groebner bases is \textsf{GBNP}, and this package does not create incomplete Groebner bases. }

 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Groebner Basis}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X84EF455882169920}{}
{
 

\subsection{\textcolor{Chapter }{CompletelyReduce}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X878AC1107E9671BA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CompletelyReduce({\slshape GB, a})\index{CompletelyReduce@\texttt{CompletelyReduce}}
\label{CompletelyReduce}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis, \mbox{\texttt{\slshape a}} -- an element in a path algebra.\\
 \textbf{\indent Returns:\ }
\mbox{\texttt{\slshape a}} reduced by \mbox{\texttt{\slshape GB}}. 



 If \mbox{\texttt{\slshape a}} is already completely reduced, the original element \mbox{\texttt{\slshape a}} is returned. }

 

\subsection{\textcolor{Chapter }{CompletelyReduceGroebnerBasis}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X7FF28B7B80759D24}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CompletelyReduceGroebnerBasis({\slshape GB})\index{CompletelyReduceGroebnerBasis@\texttt{CompletelyReduceGroebnerBasis}}
\label{CompletelyReduceGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
 the completely reduced Groebner basis of the ideal generated by \mbox{\texttt{\slshape GB}}. 



 The operation modifies a Groebner basis \mbox{\texttt{\slshape GB}} such that each relation in \mbox{\texttt{\slshape GB}} is completely reduced. The \texttt{IsCompletelyReducedGroebnerBasis} and \texttt{IsTipReducedGroebnerBasis} properties are set as a result of this operation. The resulting relations will
be placed in sorted order according to the ordering of \mbox{\texttt{\slshape GB}}. }

 

\subsection{\textcolor{Chapter }{TipReduce}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X7C6CD739788E7F59}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipReduce({\slshape GB, a})\index{TipReduce@\texttt{TipReduce}}
\label{TipReduce}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis, \mbox{\texttt{\slshape a}} - an element in a path algebra. \\
 \textbf{\indent Returns:\ }
the element \mbox{\texttt{\slshape a}} tip reduced by the Groebner basis. 



If \mbox{\texttt{\slshape a}} is already tip reduced, then the original \mbox{\texttt{\slshape a}} is returned. }

 

\subsection{\textcolor{Chapter }{TipReduceGroebnerBasis}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X7B4F38D6852DF8B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipReduceGroebnerBasis({\slshape GB})\index{TipReduceGroebnerBasis@\texttt{TipReduceGroebnerBasis}}
\label{TipReduceGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
a tip reduced Groebner basis. 



 The returned Groebner basis is equivalent to \mbox{\texttt{\slshape GB}} If \mbox{\texttt{\slshape GB}} is already tip reduced, this function returns the original object \mbox{\texttt{\slshape GB}}, possibly with the addition of the `IsTipReduced`' property set. }

 

\subsection{\textcolor{Chapter }{Iterator}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X83ADF8287ED0668E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Iterator({\slshape GB})\index{Iterator@\texttt{Iterator}}
\label{Iterator}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
an iterator (in the IsIterator category, see the \textsf{GAP} manual, chapter 28.7). 



 Creates an iterator that iterates over the relations making up the Groebner
basis. These relations are iterated over in ascending order with respect to
the ordering for the family the elements are contained in. }

 

\subsection{\textcolor{Chapter }{Enumerator}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X7EF8910F82B45EC7}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Enumerator({\slshape GB})\index{Enumerator@\texttt{Enumerator}}
\label{Enumerator}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis. \\
 \textbf{\indent Returns:\ }
an enumerat that enumerates the relations making up the Groebner basis. 



These relations should be enumerated in ascending order with respect to the
ordering for the family the elements are contained in. }

 

\subsection{\textcolor{Chapter }{Nontips}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X7EAA029F8071ACC6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Nontips({\slshape GB})\index{Nontips@\texttt{Nontips}}
\label{Nontips}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis.\\
 \textbf{\indent Returns:\ }
a list of nontip elements for \mbox{\texttt{\slshape GB}}. 



 In order to compute the nontip elements, the Groebner basis must be complete
and tip reduced, and there must be a finite number of nontips. If there are an
infinite number of nontips, the operation returns `fail'. }

 

\subsection{\textcolor{Chapter }{AdmitsFinitelyManyNontips}}
\logpage{[ 4, 3, 8 ]}\nobreak
\hyperdef{L}{X8722C1577C236116}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AdmitsFinitelyManyNontips({\slshape GB})\index{AdmitsFinitelyManyNontips@\texttt{AdmitsFinitelyManyNontips}}
\label{AdmitsFinitelyManyNontips}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a complete Groebner basis.\\
 \textbf{\indent Returns:\ }
true if the Groebner basis admits only finitely many nontips and false
otherwise. 

}

 

\subsection{\textcolor{Chapter }{NontipSize}}
\logpage{[ 4, 3, 9 ]}\nobreak
\hyperdef{L}{X7840F54D8240C288}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NontipSize({\slshape GB})\index{NontipSize@\texttt{NontipSize}}
\label{NontipSize}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a complete Groebner basis.\\
 \textbf{\indent Returns:\ }
the number of nontips admitted by \mbox{\texttt{\slshape GB}}. 

}

 

\subsection{\textcolor{Chapter }{IsPrefixOfTipInTipIdeal}}
\logpage{[ 4, 3, 10 ]}\nobreak
\hyperdef{L}{X8137C99A7934C1CA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPrefixOfTipInTipIdeal({\slshape GB, R})\index{IsPrefixOfTipInTipIdeal@\texttt{IsPrefixOfTipInTipIdeal}}
\label{IsPrefixOfTipInTipIdeal}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape GB}} -- a Groebner basis, \mbox{\texttt{\slshape R}} -- a relation.\\
 \textbf{\indent Returns:\ }
true if the tip of the relation \mbox{\texttt{\slshape R}} is in the tip ideal generated by the tips of \mbox{\texttt{\slshape GB}}. 



 This is used mainly for the construction of right Groebner basis, but is made
available for general use in case there are other unforseen applications. }

 }

 
\section{\textcolor{Chapter }{Right Groebner Basis}}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X82C1C09486934532}{}
{
 In this section we support right Groebner basis for two-sided ideals with
Groebner basis. More general cases may be supported in the future. 

\subsection{\textcolor{Chapter }{IsRightGroebnerBasis}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X86EC39527F33EABE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsRightGroebnerBasis({\slshape object})\index{IsRightGroebnerBasis@\texttt{IsRightGroebnerBasis}}
\label{IsRightGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape object}} -- any object in \textsf{GAP}.\\
 \textbf{\indent Returns:\ }
true when \mbox{\texttt{\slshape object}} a right Groebner basis. 

}

 

\subsection{\textcolor{Chapter }{RightGroebnerBasisOfIdeal}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X812BFF79867FF73A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightGroebnerBasisOfIdeal({\slshape I})\index{RightGroebnerBasisOfIdeal@\texttt{RightGroebnerBasisOfIdeal}}
\label{RightGroebnerBasisOfIdeal}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape I}} -- a right ideal.\\
 \textbf{\indent Returns:\ }
a right Groebner basis of a right ideal, \mbox{\texttt{\slshape I}}, is one has been computed. 

}

 

\subsection{\textcolor{Chapter }{RightGroebnerBasis}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X7B29B9207D20EA9E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightGroebnerBasis({\slshape I})\index{RightGroebnerBasis@\texttt{RightGroebnerBasis}}
\label{RightGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape I}} -- a right ideal.\\
 \textbf{\indent Returns:\ }
a right Groebner basis for \mbox{\texttt{\slshape I}}, which must support a right Groebner basis theory. Right now, this requires
that \mbox{\texttt{\slshape I}} has a complete Groebner basis. 

}

 }

 }

 
\chapter{\textcolor{Chapter }{Using GBNP with Gap}}\label{GBNP}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X83BD16BB7FF08CD1}{}
{
 
\section{\textcolor{Chapter }{GBNP}}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7C8F0BF282342E3A}{}
{
 \textsf{GBNP} is a non-commutative Groebner Basis package which assumes that all algebras
involved will be free algebras over a finite number of non-commuting
generators. It also assumes that the ordering on the monomials is left
length-lexicographic. }

 
\section{\textcolor{Chapter }{Setting up GBNP}}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X86408B737FFF9279}{}
{
 in progress... }

 
\section{\textcolor{Chapter }{Relevant GBNP internals}}\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X78E3029087911EF4}{}
{
 in progress... }

 
\section{\textcolor{Chapter }{Communicating with GBNP}}\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X7A26A6DF791985FE}{}
{
 in progress... }

 }

 
\chapter{\textcolor{Chapter }{Right Modules over Path Algebras}}\label{Right-Modules}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X87EFC38F7BC77B27}{}
{
 There are two implementations of right modules over path algebras. The first
type are matrix modules that are defined by vector spaces and linear
transformations. The second type are presentations defined by vertex
projective modules. 
\section{\textcolor{Chapter }{Matrix Modules}}\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X7D4882837C7EE06C}{}
{
 The first implementation of right modules over path algebras views them as a
collection of vector spaces and linear transformations. Each vertex in the
path algebra is associated with a vector space over the field of the algebra.
For each vertex $v$ of the algebra there is a vector space $V$. Arrows of the algebra are then associated with linear transformations which
map the vector space of the source vertex to the vector space of the target
vertex. For example, if $a$ is an arrow from $v$ to $w$ then there is a transformation from vector space $V$ to $W$. In practice when creating the modules all we need to know is the
transformations and we can create the vector spaces of the correct dimension,
and check to make sure the dimensions all agree. We can create a module in
this way as follows.

 

\subsection{\textcolor{Chapter }{RightModuleOverPathAlgebra}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X82DAF2167E65C4A8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleOverPathAlgebra({\slshape A, mats})\index{RightModuleOverPathAlgebra@\texttt{RightModuleOverPathAlgebra}}
\label{RightModuleOverPathAlgebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleOverPathAlgebra({\slshape A, dim{\textunderscore}vector, gens})\index{RightModuleOverPathAlgebra@\texttt{RightModuleOverPathAlgebra}}
\label{RightModuleOverPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a (quotient of a) path algebra, \mbox{\texttt{\slshape mats}} -- a list of matrices, \mbox{\texttt{\slshape dim{\textunderscore}vector}} -- the dimension vector of the module, \mbox{\texttt{\slshape gens}} -- a list of elements (generators). For further explanations, see below. \\
\textbf{\indent Returns:\ }
a module over a path algebra or over a qoutient of a path algebra in the
second variant.



 In the first function call, the list of matrices \mbox{\texttt{\slshape mats}} can take on three different forms.

 1) The argument \mbox{\texttt{\slshape mats}} can be a list of blocks of matrices where each block is of the form, `["name
of arrow",matrix]'. So if you named your arrows when you created the quiver,
then you can associate a matrix with that arrow explicitly.

 2) The argument \mbox{\texttt{\slshape mats}} is just a list of matrices, and the matrices will be associated to the arrows
in the order of arrow creation. If when creating the quiver, the arrow $a$ was created first, then $a$ would be associated with the first matrix.

 3) The method is very much the same as the second method. If \mbox{\texttt{\slshape arrows}} is a list of the arrows of the quiver (obtained for instance through \texttt{arrows := ArrowsOfQuiver(Q);}), the argument \mbox{\texttt{\slshape mats}} can have the format \texttt{[[arrows[1],matrix{\textunderscore}1],[arrows[2],matrix{\textunderscore}2],....
].}

 If you would like the trivial vector space at any vertex, then for each
incoming arrow "a", associate it with a list of the form \texttt{["a",[n,0]]} where n is the dimension of the vector space at the source vertex of the
arrow. Likewise for all outgoing arrows "b", associate them to a block of form \texttt{["b",[0,n]]} where n is the dimension of the vector space at the target vertex of the
arrow.

 A warning though, the function assumes that you do not mix the styles of
inputting the matrices/linear transformations associated to the arrows in the
quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise an
error will be returned. The function verifies that the dimensions of the
matrices and vector spaces are correct and match, and that each arrow has only
one matrix assigned to it.

 In the second function call, the second argument \mbox{\texttt{\slshape dim{\textunderscore}vector}} is the dimension vector of the module, and the last argument \mbox{\texttt{\slshape gens}} (maybe an empty list []) is a list of elements of the form ["label",matrix].
This function constructs a right module over a (quotient of a) path algebra \mbox{\texttt{\slshape A}} with dimension vector \mbox{\texttt{\slshape dim{\textunderscore}vector}}, and where the generators/arrows with a non-zero action is given in the list \mbox{\texttt{\slshape gens}}. The format of the list \mbox{\texttt{\slshape gens}} is [["a",[matrix{\textunderscore}a]],["b",[matrix{\textunderscore}b]],...],
where "a" and "b" are labels of arrows used when the underlying quiver was
created and matrix{\textunderscore}? is the action of the algebra element
corresponding to the arrow with label "?". The action of the arrows can be
entered in any order. The function checks if the algebra \mbox{\texttt{\slshape A}} is a (quotient of a) path algebra and if the matrices of the action of the
arrows have the correct size according to the dimension vector entered and
also whether or not the relations of the algebra are satisfied. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap&gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); 
  &lt;quiver with 2 vertices and 3 arrows&gt;
  gap&gt; P := PathAlgebra(Rationals, Q);
  &lt;algebra-with-one over Rationals, with 5 generators&gt;
  gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
  &gt; ["c", [[0,0],[1,0]]]];
  [ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
    [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
    [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
  gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
  &lt;right-module over &lt;algebra-with-one over Rationals, with 5
  generators&gt;&gt; 
  gap&gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; 
  gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
  &lt;right-module over &lt;algebra-with-one over Rationals, with 5
  generators&gt;&gt; 
  gap&gt; arrows := ArrowsOfQuiver(Q);
  [ a, b, c ]
  gap&gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], 
  &gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;
  gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
  &lt;right-module over &lt;algebra-with-one over Rationals, with 5
  generators&gt;&gt;
  gap&gt; # Next we give the vertex simple associate to vertex 1. 
  gap&gt; M :=
  RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);
  &lt;right-module over &lt;algebra-with-one over Rationals, with 5
  					generators&gt;&gt; 
  gap&gt; # Finally, the next defines the zero representation of the quiver.
  gap&gt; M :=
  RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);
  &lt;right-module over &lt;algebra-with-one over Rationals, with 5
  					generators&gt;&gt; 
  gap&gt; Dimension(M);
  0
  gap&gt; Basis(M);
  Basis( &lt;
  0-dimensional right-module over &lt;algebra-with-one over Rationals, with 
  5 generators&gt;&gt;, [  ] )
  gap> # Using the above example.  
  gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",
  [[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
  [ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
    [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
  gap> M := RightModuleOverPathAlgebra(P,[2,3],matrices);
  <right-module over <algebra-with-one over Rationals, with 5 generators>>
  gap> M := RightModuleOverPathAlgebra(P,[2,3],[]);      
  <right-module over <algebra-with-one over Rationals, with 5 generators>>
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Categories Of Matrix Modules}}\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X869F4DD2877A99BA}{}
{
 

\subsection{\textcolor{Chapter }{IsPathAlgebraModule}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X82A8398478788A5A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebraModule({\slshape object})\index{IsPathAlgebraModule@\texttt{IsPathAlgebraModule}}
\label{IsPathAlgebraModule}
}\hfill{\scriptsize (filter)}}\\
\textbf{\indent Returns:\ }
 true or false depending on whether \mbox{\texttt{\slshape object}} belongs to the category \texttt{IsPathAlgebraModule}.



 These matrix modules fall under the category `IsAlgebraModule' with the added
filter of `IsPathAlgebraModule'. Operations available for algebra modules can
be applied to path algebra modules. See "ref:representations of algebras" for
more details. These modules are also vector spaces over the field of the path
algebra. So refer to "ref:vector spaces" for descriptions of the basis and
elementwise operations available. }

 }

 
\section{\textcolor{Chapter }{Acting on Module Elements}}\logpage{[ 6, 3, 0 ]}
\hyperdef{L}{X862F510485ADBC67}{}
{
 

\subsection{\textcolor{Chapter }{\texttt{\symbol{94}}}}
\logpage{[ 6, 3, 1 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{94}}({\slshape m, p})\index{^@\texttt{\texttt{\symbol{94}}}}
\label{^}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape m}} -- an element in a module, \mbox{\texttt{\slshape p}} -- a path in a path algebra. \\
\textbf{\indent Returns:\ }
 the element \mbox{\texttt{\slshape m}} multiplied with \mbox{\texttt{\slshape p}}. 



 When you act on an module element $m$ by an arrow $a$ from $v$ to $w$, the component of $m$ from $V$ is acted on by $L$ the transformation associated to $a$ and placed in the component $W$. All other components are given the value $0$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> # Using the path algebra P from the above example. 
  gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
  > ["c", [[0,0],[1,0]]]];
  [ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
    [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
    [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
  gap> M := RightModuleOverPathAlgebra(P,matrices);
  <right-module over <algebra-with-one over Rationals, with 5
  generators>> 
  gap> B:=BasisVectors(Basis(M));
  [ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
    [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
    [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
  gap> B[1]+B[3];
  [ [ 1, 0 ], [ 1, 0, 0 ] ]
  gap> 4*B[2];
  [ [ 0, 4 ], [ 0, 0, 0 ] ]
  gap> m:=5*B[1]+2*B[4]+B[5];
  [ [ 5, 0 ], [ 0, 2, 1 ] ]
  gap> m^(P.a*P.b-P.c);
  [ [ 0, 5 ], [ 0, 0, 0 ] ]
  gap> B[1]^P.a;
  [ [ 0, 0 ], [ 1, 0, 0 ] ]
  gap> B[2]^P.b;
  [ [ 0, 0 ], [ 0, 0, 0 ] ]
  gap> B[4]^(P.b*P.c);
  [ [ 0, 0 ], [ 0, 0, 0 ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Operations on representations}}\logpage{[ 6, 4, 0 ]}
\hyperdef{L}{X7E5B84B1832D839E}{}
{
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);
  <quiver with 3 vertices and 5 arrows>
  gap> KQ := PathAlgebra(Rationals, Q);
  <algebra-with-one over Rationals, with 8 generators>
  gap> gens := GeneratorsOfAlgebra(KQ);
  [ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ]
  gap> u := gens[1];; v := gens[2];;
  gap> w := gens[3];; a := gens[4];;
  gap> b := gens[5];; c := gens[6];;
  gap> d := gens[7];; e := gens[8];;
  gap> rels := [d*e,c^2,a*c*d-b*d,e*a];;
  gap> I:= Ideal(KQ,rels);;
  gap> gb:= GBNPGroebnerBasis(rels,KQ);;
  gap> gbb:= GroebnerBasis(I,gb);;
  gap> A:= KQ/I;
  <algebra-with-one over Rationals, with 8 generators>
  gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],
  ["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
  gap> N:= RightModuleOverPathAlgebra(A,mat);                         
  <right-module over <algebra-with-one over Rationals, with 8 generators>>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CommonDirectSummand}}
\logpage{[ 6, 4, 1 ]}\nobreak
\hyperdef{L}{X8687EC4878E755CC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CommonDirectSummand({\slshape M, N})\index{CommonDirectSummand@\texttt{CommonDirectSummand}}
\label{CommonDirectSummand}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} -- two path algebra modules. \\
\textbf{\indent Returns:\ }
a list of four modules [\mbox{\texttt{\slshape X}},\mbox{\texttt{\slshape U}},\mbox{\texttt{\slshape X}}, \mbox{\texttt{\slshape V}}], where \mbox{\texttt{\slshape X}} is one common non-zero direct summand of \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}, the sum of \mbox{\texttt{\slshape X}} and \mbox{\texttt{\slshape U}} is \mbox{\texttt{\slshape M}} and the sum of \mbox{\texttt{\slshape X}} and \mbox{\texttt{\slshape V}} is \mbox{\texttt{\slshape N}}, if such a non-zero direct summand exists. Otherwise it returns false.



The function checks if \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are \texttt{PathAlgebraMatModule}s over the same (quotient of a) path algebra. }

 

\subsection{\textcolor{Chapter }{DimensionVector}}
\logpage{[ 6, 4, 2 ]}\nobreak
\hyperdef{L}{X7B5EA4B0820DE28C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DimensionVector({\slshape M})\index{DimensionVector@\texttt{DimensionVector}}
\label{DimensionVector}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the dimension vector of the representation \mbox{\texttt{\slshape M}}. 



 A shortcoming of this that it is not defined for modules of quotients of path
algebras. }

 

\subsection{\textcolor{Chapter }{Dimension}}
\logpage{[ 6, 4, 3 ]}\nobreak
\hyperdef{L}{X7E6926C6850E7C4E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Dimension({\slshape M})\index{Dimension@\texttt{Dimension}}
\label{Dimension}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the dimension of the representation \mbox{\texttt{\slshape M}}. 

}

 

\subsection{\textcolor{Chapter }{IsDirectSummand}}
\logpage{[ 6, 4, 4 ]}\nobreak
\hyperdef{L}{X7E24DCE07E98E50D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsDirectSummand({\slshape M, N})\index{IsDirectSummand@\texttt{IsDirectSummand}}
\label{IsDirectSummand}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M, N}} -- two path algebra modules (\texttt{PathAlgebraMatModule}s). \\
\textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape M}} is isomorphic to a direct summand of \mbox{\texttt{\slshape N}}, otherwise false.



The function checks if \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are \texttt{PathAlgebraMatModule}s over the same (quotient of a) path algebra. }

 

\subsection{\textcolor{Chapter }{DirectSumOfModules}}
\logpage{[ 6, 4, 5 ]}\nobreak
\hyperdef{L}{X879541298181840D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DirectSumOfModules({\slshape L})\index{DirectSumOfModules@\texttt{DirectSumOfModules}}
\label{DirectSumOfModules}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape L}} -- a list of \texttt{PathAlgebraMatModule}s over the same (quotient of a) path algebra. \\
\textbf{\indent Returns:\ }
the direct sum of the representations contained in the list \mbox{\texttt{\slshape L}}.



In addition three attributes are attached to the result, \texttt{IsDirectSumOfModules, DirectSumProjections} and \texttt{DirectSumInclusions}. }

 

\subsection{\textcolor{Chapter }{IsDirectSumOfModules}}
\logpage{[ 6, 4, 6 ]}\nobreak
\hyperdef{L}{X7A50C15B87236111}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsDirectSumOfModules({\slshape M})\index{IsDirectSumOfModules@\texttt{IsDirectSumOfModules}}
\label{IsDirectSumOfModules}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
 true if \mbox{\texttt{\slshape M}} is constructed via the command \texttt{DirectSumOfModules}. 

}

 

\subsection{\textcolor{Chapter }{DirectSumInclusions}}
\logpage{[ 6, 4, 7 ]}\nobreak
\hyperdef{L}{X857807CF8560B3C4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DirectSumInclusions({\slshape M})\index{DirectSumInclusions@\texttt{DirectSumInclusions}}
\label{DirectSumInclusions}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
 the list of inclusions from the individual modules to their direct sum, when a
direct sum has been constructed using \texttt{DirectSumOfModules}. 

}

 

\subsection{\textcolor{Chapter }{DirectSumProjections}}
\logpage{[ 6, 4, 8 ]}\nobreak
\hyperdef{L}{X80CFB7E47A785E12}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DirectSumProjections({\slshape M})\index{DirectSumProjections@\texttt{DirectSumProjections}}
\label{DirectSumProjections}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
 the list of projections from the direct sum to the individual modules used to
construct direct sum, when a direct sum has been constructed using \texttt{DirectSumOfModules}. 

}

 Using the example above. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> N2:=DirectSumOfModules([N,N]);
  <14-dimensional right-module over <algebra-with-one of dimension 
  17 over Rationals>>
  gap> proj:=DirectSumProjections(N2);
  [ <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> inc:=DirectSumInclusions(N2);  
  [ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      14-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      14-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{1stSyzygy}}
\logpage{[ 6, 4, 9 ]}\nobreak
\hyperdef{L}{X7EC01D588141BB96}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{1stSyzygy({\slshape M})\index{1stSyzygy@\texttt{1stSyzygy}}
\label{1stSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the first syzygy of the representation \mbox{\texttt{\slshape M}} as a representation. 

}

 

\subsection{\textcolor{Chapter }{IsInAdditiveClosure}}
\logpage{[ 6, 4, 10 ]}\nobreak
\hyperdef{L}{X7E5246D4831DB250}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsInAdditiveClosure({\slshape M, N})\index{IsInAdditiveClosure@\texttt{IsInAdditiveClosure}}
\label{IsInAdditiveClosure}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M, N}} -- two path algebra modules (\texttt{PathAlgebraMatModule}s). \\
\textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape M}} is in the additive closure of the module \mbox{\texttt{\slshape N}}, otherwise false.



The function checks if \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are \texttt{PathAlgebraMatModule}s over the same (quotient of a) path algebra. }

 

\subsection{\textcolor{Chapter }{IsOmegaPeriodic}}
\logpage{[ 6, 4, 11 ]}\nobreak
\hyperdef{L}{X7BE6A5B586463067}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsOmegaPeriodic({\slshape M, n})\index{IsOmegaPeriodic@\texttt{IsOmegaPeriodic}}
\label{IsOmegaPeriodic}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}), \mbox{\texttt{\slshape n}} -- be a positive integer. \\
\textbf{\indent Returns:\ }
\texttt{i}, where \texttt{i} is the smallest positive integer less or equal \texttt{n} such that the representation \mbox{\texttt{\slshape M}} is isomorphic to the \texttt{i}-th syzygy of \mbox{\texttt{\slshape M}}, and false otherwise. 

}

 

\subsection{\textcolor{Chapter }{IsInjectiveModule}}
\logpage{[ 6, 4, 12 ]}\nobreak
\hyperdef{L}{X803C2799861FFBC5}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsInjectiveModule({\slshape M})\index{IsInjectiveModule@\texttt{IsInjectiveModule}}
\label{IsInjectiveModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
true if the representation \mbox{\texttt{\slshape M}} is injective. 

}

 

\subsection{\textcolor{Chapter }{IsProjectiveModule}}
\logpage{[ 6, 4, 13 ]}\nobreak
\hyperdef{L}{X8359AC9585777CA1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsProjectiveModule({\slshape M})\index{IsProjectiveModule@\texttt{IsProjectiveModule}}
\label{IsProjectiveModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
true if the representation \mbox{\texttt{\slshape M}} is projective. 

}

 

\subsection{\textcolor{Chapter }{IsSemisimpleModule}}
\logpage{[ 6, 4, 14 ]}\nobreak
\hyperdef{L}{X7A8BC26E866E44DD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSemisimpleModule({\slshape M})\index{IsSemisimpleModule@\texttt{IsSemisimpleModule}}
\label{IsSemisimpleModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
true if the representation \mbox{\texttt{\slshape M}} is semisimple. 

}

 

\subsection{\textcolor{Chapter }{IsSimpleModule}}
\logpage{[ 6, 4, 15 ]}\nobreak
\hyperdef{L}{X7FB82B3184287362}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSimpleModule({\slshape M})\index{IsSimpleModule@\texttt{IsSimpleModule}}
\label{IsSimpleModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
true if the representation \mbox{\texttt{\slshape M}} is simple. 

}

 

\subsection{\textcolor{Chapter }{LoewyLength}}
\logpage{[ 6, 4, 16 ]}\nobreak
\hyperdef{L}{X7BEA44FB819910B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LoewyLength({\slshape M})\index{LoewyLength@\texttt{LoewyLength}}
\label{LoewyLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the Loewy length of the module \mbox{\texttt{\slshape M}}.



 The function checks that the module \mbox{\texttt{\slshape M}} is a module over a finite dimensional quotient of a path algebra, and returns
fail otherwise (This is not implemented yet). }

 

\subsection{\textcolor{Chapter }{MaximalCommonDirectSummand}}
\logpage{[ 6, 4, 17 ]}\nobreak
\hyperdef{L}{X7B480767836D0764}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MaximalCommonDirectSummand({\slshape M, N})\index{MaximalCommonDirectSummand@\texttt{MaximalCommonDirectSummand}}
\label{MaximalCommonDirectSummand}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M, N}} -- two path algebra modules (\texttt{PathAlgebraMatModule}s). \\
\textbf{\indent Returns:\ }
a list of three modules [\mbox{\texttt{\slshape X}},\mbox{\texttt{\slshape U}},\mbox{\texttt{\slshape V}}], where \mbox{\texttt{\slshape X}} is a maximal common non-zero direct summand of \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}, the sum of \mbox{\texttt{\slshape X}} and \mbox{\texttt{\slshape U}} is \mbox{\texttt{\slshape M}} and the sum of \mbox{\texttt{\slshape X}} and \mbox{\texttt{\slshape V}} is \mbox{\texttt{\slshape N}}, if such a non-zero maximal direct summand exists. Otherwise it returns
false.



The function checks if \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are \texttt{PathAlgebraMatModule}s over the same (quotient of a) path algebra. }

 

\subsection{\textcolor{Chapter }{IsomorphicModules}}
\logpage{[ 6, 4, 18 ]}\nobreak
\hyperdef{L}{X7D198BB5808D38F2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsomorphicModules({\slshape M, N})\index{IsomorphicModules@\texttt{IsomorphicModules}}
\label{IsomorphicModules}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M, N}} -- two path algebra modules (\texttt{PathAlgebraMatModule}s). \\
\textbf{\indent Returns:\ }
true or false depending on whether \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are isomorphic or not.



 The function first checks if the modules \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are modules over the same algebra, and returns fail if not. The function
returns true if the modules are isomorphic, otherwise false. }

 

\subsection{\textcolor{Chapter }{NthSyzygy}}
\logpage{[ 6, 4, 19 ]}\nobreak
\hyperdef{L}{X7EB51A487B5B239D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NthSyzygy({\slshape M, n})\index{NthSyzygy@\texttt{NthSyzygy}}
\label{NthSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}), \mbox{\texttt{\slshape n}} -- a positive integer. \\
\textbf{\indent Returns:\ }
the top of the syzygies until a syzygy is projective or the \mbox{\texttt{\slshape n}}-th syzygy has been computed. 

}

 

\subsection{\textcolor{Chapter }{NthSyzygyNC}}
\logpage{[ 6, 4, 20 ]}\nobreak
\hyperdef{L}{X870531C67C402A64}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NthSyzygyNC({\slshape M, n})\index{NthSyzygyNC@\texttt{NthSyzygyNC}}
\label{NthSyzygyNC}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}), \mbox{\texttt{\slshape n}} -- a positive integer. \\
\textbf{\indent Returns:\ }
the \texttt{n}-th syzygy of the module \mbox{\texttt{\slshape M}}, unless the projective dimension of \mbox{\texttt{\slshape M}} is less or equal to \texttt{n-1}, in which case it returns the projective dimension of \mbox{\texttt{\slshape M}}. It does not check if the \texttt{n}-th syzygy is projective or not. 

}

 

\subsection{\textcolor{Chapter }{RadicalOfModule}}
\logpage{[ 6, 4, 21 ]}\nobreak
\hyperdef{L}{X7E44920683157DE2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalOfModule({\slshape M})\index{RadicalOfModule@\texttt{RadicalOfModule}}
\label{RadicalOfModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the radical of the module \mbox{\texttt{\slshape M}}.



 This returns only the representation given by the radical of the module \mbox{\texttt{\slshape M}}. The operation \texttt{RadicalOfModuleInclusion} (\ref{RadicalOfModuleInclusion}) computes the inclusion of the radical of \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}. }

 

\subsection{\textcolor{Chapter }{RadicalSeries}}
\logpage{[ 6, 4, 22 ]}\nobreak
\hyperdef{L}{X7929281B848A9FBE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalSeries({\slshape M})\index{RadicalSeries@\texttt{RadicalSeries}}
\label{RadicalSeries}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the radical series of the module \mbox{\texttt{\slshape M}}.



 The function gives the radical series as a list of vectors \texttt{[n{\textunderscore}1,...,n{\textunderscore}s]}, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of
each simple. The first vector listed corresponds to the top layer, and so on. }

 

\subsection{\textcolor{Chapter }{SocleSeries}}
\logpage{[ 6, 4, 23 ]}\nobreak
\hyperdef{L}{X84A724267E6F136D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleSeries({\slshape M})\index{SocleSeries@\texttt{SocleSeries}}
\label{SocleSeries}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the socle series of the module \mbox{\texttt{\slshape M}}.



 The function gives the socle series as a list of vectors \texttt{[n{\textunderscore}1,...,n{\textunderscore}s]}, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of
each simple. The last vector listed corresponds to the socle layer, and so on
backwards. }

 

\subsection{\textcolor{Chapter }{SocleOfModule}}
\logpage{[ 6, 4, 24 ]}\nobreak
\hyperdef{L}{X79DF34618798E866}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleOfModule({\slshape M})\index{SocleOfModule@\texttt{SocleOfModule}}
\label{SocleOfModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the socle of the module \mbox{\texttt{\slshape M}}.



 This operation only return the representation given by the socle of the module \mbox{\texttt{\slshape M}}. The inclusion the socle of \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}} can be computed using \texttt{SocleOfModuleInclusion} (\ref{SocleOfModuleInclusion}). }

 

\subsection{\textcolor{Chapter }{SubRepresentation}}
\logpage{[ 6, 4, 25 ]}\nobreak
\hyperdef{L}{X858AC23C83AC843E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SubRepresentation({\slshape M, gens})\index{SubRepresentation@\texttt{SubRepresentation}}
\label{SubRepresentation}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}), \mbox{\texttt{\slshape gens}} -- elements in \mbox{\texttt{\slshape M}}. \\
\textbf{\indent Returns:\ }
the submodule of the module \mbox{\texttt{\slshape M}} generated by the elements \mbox{\texttt{\slshape gens}}.



 The function checks if \mbox{\texttt{\slshape gens}} are elements in \mbox{\texttt{\slshape M}}, and returns an error message otherwise. The inclusion of the submodule
generated by the elements \mbox{\texttt{\slshape gens}} into \mbox{\texttt{\slshape M}} can be computed using \texttt{SubRepresentationInclusion} (\ref{SubRepresentationInclusion}). }

 

\subsection{\textcolor{Chapter }{SupportModuleElement}}
\logpage{[ 6, 4, 26 ]}\nobreak
\hyperdef{L}{X856EA09A83A5A636}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SupportModuleElement({\slshape m})\index{SupportModuleElement@\texttt{SupportModuleElement}}
\label{SupportModuleElement}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape m}} -- an element of a path algebra module. \\
\textbf{\indent Returns:\ }
the primitive idempotents \mbox{\texttt{\slshape v}} in the algebra over which the module containing the element \mbox{\texttt{\slshape m}} is a module, such that \mbox{\texttt{\slshape m\texttt{\symbol{94}}v}} is non-zero.



 The function checks if \mbox{\texttt{\slshape m}} is an element in a module over a (quotient of a) path algebra, and returns
fail otherwise. }

 

\subsection{\textcolor{Chapter }{TopOfModule}}
\logpage{[ 6, 4, 27 ]}\nobreak
\hyperdef{L}{X87F571327E43AFB4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TopOfModule({\slshape M})\index{TopOfModule@\texttt{TopOfModule}}
\label{TopOfModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
the top of the module \mbox{\texttt{\slshape M}}.



 This returns only the representation given by the top of the module \mbox{\texttt{\slshape M}}. The operation \texttt{TopOfModuleProjection} (\ref{TopOfModuleProjection}) computes the projection of the module \mbox{\texttt{\slshape M}} onto the top of the module \mbox{\texttt{\slshape M}}. }

 

\subsection{\textcolor{Chapter }{MinimalGeneratingSetOfModule}}
\logpage{[ 6, 4, 28 ]}\nobreak
\hyperdef{L}{X821FA104861FF19B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimalGeneratingSetOfModule({\slshape M})\index{MinimalGeneratingSetOfModule@\texttt{MinimalGeneratingSetOfModule}}
\label{MinimalGeneratingSetOfModule}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
a minimal generator set of the module \mbox{\texttt{\slshape M}} as a module of the path algebra it is defined over. 

}

 

\subsection{\textcolor{Chapter }{MatricesOfPathAlgebraModule}}
\logpage{[ 6, 4, 29 ]}\nobreak
\hyperdef{L}{X81BB198380631A9B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatricesOfPathAlgebraModule({\slshape M})\index{MatricesOfPathAlgebraModule@\texttt{MatricesOfPathAlgebraModule}}
\label{MatricesOfPathAlgebraModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module (\texttt{PathAlgebraMatModule}). \\
\textbf{\indent Returns:\ }
a list of the matrices that defines the representation \mbox{\texttt{\slshape M}} as a right module of the acting path algebra. 



 The list of matrices that are returned are not the same identical to the
matrices entered to define the representation if there is zero vector space in
at least one vertex. Then zero matrices of the appropriate size are returned.
A shortcoming of this that it is not defined for modules of quotients of path
algebras. }

 }

 
\section{\textcolor{Chapter }{Special representations}}\logpage{[ 6, 5, 0 ]}
\hyperdef{L}{X7919F94382D9B38B}{}
{
 Here we collect the predefined representations/modules over a finite
dimensional quotient of a path algebra. 

\subsection{\textcolor{Chapter }{BasisOfProjectives}}
\logpage{[ 6, 5, 1 ]}\nobreak
\hyperdef{L}{X8048CD27796253CA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BasisOfProjectives({\slshape A})\index{BasisOfProjectives@\texttt{BasisOfProjectives}}
\label{BasisOfProjectives}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a finite dimensional (quotient of a) path algebra. \\
\textbf{\indent Returns:\ }
a list of bases for all the indecomposable projective representations over \mbox{\texttt{\slshape A}}. The basis for each indecomposable projective is given a list of elements in
nontips in \mbox{\texttt{\slshape A}}. 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{IndecProjectiveModules}}
\logpage{[ 6, 5, 2 ]}\nobreak
\hyperdef{L}{X85EDCFE27F66093F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IndecProjectiveModules({\slshape A[, list]})\index{IndecProjectiveModules@\texttt{IndecProjectiveModules}}
\label{IndecProjectiveModules}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a finite dimensional (quotient of a) path algebra, (optional) \mbox{\texttt{\slshape list}} -- a list of integers. \\
\textbf{\indent Returns:\ }
a list of all the indecomposable projective representations over \mbox{\texttt{\slshape A}}, when only one argument is supplied. The second argument should be a list of
integers, for example [1, 3, 4], which will return the indecomposable
projective corresponding to vertex 1, 3 and 4, in this order. 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{IndecInjectiveModules}}
\logpage{[ 6, 5, 3 ]}\nobreak
\hyperdef{L}{X87741234871B1F5C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IndecInjectiveModules({\slshape A[, list]})\index{IndecInjectiveModules@\texttt{IndecInjectiveModules}}
\label{IndecInjectiveModules}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a finite dimensional (quotient of a) path algebra, (optional) \mbox{\texttt{\slshape list}} -- a list of integers. \\
\textbf{\indent Returns:\ }
a list of all the indecomposable injective representations over \mbox{\texttt{\slshape A}}, when only one argument is supplied. The second argument should be a list of
integers, for example [1, 3, 4], which will return the indecomposable
injective corresponding to vertex 1, 3 and 4, in this order. 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{SimpleModules}}
\logpage{[ 6, 5, 4 ]}\nobreak
\hyperdef{L}{X7C61261F7C5E53B8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SimpleModules({\slshape A})\index{SimpleModules@\texttt{SimpleModules}}
\label{SimpleModules}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a finite dimensional (quotient of a) path algebra. \\
\textbf{\indent Returns:\ }
a list of all the simple representations over \mbox{\texttt{\slshape A}} . 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{ZeroModule}}
\logpage{[ 6, 5, 5 ]}\nobreak
\hyperdef{L}{X7CCE2D12807AA35A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ZeroModule({\slshape A})\index{ZeroModule@\texttt{ZeroModule}}
\label{ZeroModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a finite dimensional (quotient of a) path algebra. \\
\textbf{\indent Returns:\ }
the zero representation over \mbox{\texttt{\slshape A}} . 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 }

 
\section{\textcolor{Chapter }{Functors on representations}}\logpage{[ 6, 6, 0 ]}
\hyperdef{L}{X7D99BF5A87DDC099}{}
{
 

\subsection{\textcolor{Chapter }{DualOfModule}}
\logpage{[ 6, 6, 1 ]}\nobreak
\hyperdef{L}{X82D7B50A7ACA47BF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualOfModule({\slshape M})\index{DualOfModule@\texttt{DualOfModule}}
\label{DualOfModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a representation of a path algebra $KQ$. \\
\textbf{\indent Returns:\ }
 the dual of \mbox{\texttt{\slshape M}} over the opposite path algebra \mbox{\texttt{\slshape KQ{\textunderscore}op}}. 

}

 

\subsection{\textcolor{Chapter }{DualOfModuleHomomorphism}}
\logpage{[ 6, 6, 2 ]}\nobreak
\hyperdef{L}{X847DDC417BFB8515}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualOfModuleHomomorphism({\slshape f})\index{DualOfModuleHomomorphism@\texttt{DualOfModuleHomomorphism}}
\label{DualOfModuleHomomorphism}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} -- a map between two representations \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} over a path algebra $A$. \\
\textbf{\indent Returns:\ }
 the dual of this map over the opposite path algebra \mbox{\texttt{\slshape A\texttt{\symbol{94}}op}}. 

}

 

\subsection{\textcolor{Chapter }{DTr}}
\logpage{[ 6, 6, 3 ]}\nobreak
\hyperdef{L}{X82D31F887C14E921}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DTr({\slshape M[, n]})\index{DTr@\texttt{DTr}}
\label{DTr}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualOfTranspose({\slshape M[, n]})\index{DualOfTranspose@\texttt{DualOfTranspose}}
\label{DualOfTranspose}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module, (optional) \mbox{\texttt{\slshape n}} -- an integer. \\
\textbf{\indent Returns:\ }
the dual of the transpose of \mbox{\texttt{\slshape M}} when called with only one argument, while it returns the dual of the transpose
applied to \mbox{\texttt{\slshape M}} \mbox{\texttt{\slshape n}} times otherwise. If \mbox{\texttt{\slshape n}} is negative, then powers of \texttt{TrD} are computed. \texttt{DualOfTranspose} is a synonym for \texttt{DTr}. 

}

 

\subsection{\textcolor{Chapter }{TrD}}
\logpage{[ 6, 6, 4 ]}\nobreak
\hyperdef{L}{X7939949279208FA3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TrD({\slshape M[, n]})\index{TrD@\texttt{TrD}}
\label{TrD}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TransposeOfDual({\slshape M[, n]})\index{TransposeOfDual@\texttt{TransposeOfDual}}
\label{TransposeOfDual}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module, (optional) \mbox{\texttt{\slshape n}} -- an integer. \\
\textbf{\indent Returns:\ }
the transpose of the dual of \mbox{\texttt{\slshape M}} when called with only one argument, while it returns the transpose of the dual
applied to \mbox{\texttt{\slshape M}} \mbox{\texttt{\slshape n}} times otherwise. If \mbox{\texttt{\slshape n}} is negative, then powers of \texttt{TrD} are computed. \texttt{TransposeOfDual} is a synonym for \texttt{TrD}.

}

 

\subsection{\textcolor{Chapter }{TransposeOfModule}}
\logpage{[ 6, 6, 5 ]}\nobreak
\hyperdef{L}{X79C0B620842128AF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TransposeOfModule({\slshape M})\index{TransposeOfModule@\texttt{TransposeOfModule}}
\label{TransposeOfModule}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a path algebra module. \\
\textbf{\indent Returns:\ }
the transpose of the module \mbox{\texttt{\slshape M}}.

}

 }

 
\section{\textcolor{Chapter }{Vertex Projective Presentations}}\logpage{[ 6, 7, 0 ]}
\hyperdef{L}{X8097F19E8228B68C}{}
{
 In general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a projective module of $R$. Then we can form a direct sum of these projective modules together to form
larger projective module. One can construct more general modules by providing
a \mbox{\texttt{\slshape vertex projective presentation}}. In this case, $M$ is the cokernel as given by the following exact sequence: $\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R \rightarrow{M}
\rightarrow 0$ for some map between $\oplus_{j=1}^{r} w(j)R$ and $\oplus_{i=1}^{g} v(i)R$. The maps $w$ and $v$ map the integers to some idempotent in $R$. 

\subsection{\textcolor{Chapter }{RightProjectiveModule}}
\logpage{[ 6, 7, 1 ]}\nobreak
\hyperdef{L}{X79175B097A0718FE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightProjectiveModule({\slshape A, verts})\index{RightProjectiveModule@\texttt{RightProjectiveModule}}
\label{RightProjectiveModule}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape A}} -- a (quotient of a) path algebra, \mbox{\texttt{\slshape verts}} -- a list of vertices. \\
\textbf{\indent Returns:\ }
 the right projective module over \mbox{\texttt{\slshape A}} which is the direct sum of projective modules of the form \mbox{\texttt{\slshape vA}} where the vertices are taken from \mbox{\texttt{\slshape verts}}.



 In this implementation the algebra can be a quotient of a path algebra. So if
the list was $[v,w]$ then the module created will be the direct sum $vA \oplus wA$, in that order. Elements of the modules are vectors of algebra elements, and
in each component, each path begins with the vertex in that position in the
list of vertices. Right projective modules are implementated as algebra
modules (see "ref:Representations of Algebras") and all operations for algebra
modules are applicable to right projective modules. In particular, one can
construct submodules using `SubAlgebraModule'. }

 Here we create the right projective module $P = vA \oplus vA \oplus wA$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
  <quiver with 3 vertices and 3 arrows>
  gap> A:=PathAlgebra(F,Q);
  <algebra-with-one over GF(11), with 6 generators>
  gap> P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
  <right-module over <algebra-with-one over GF(11), with 6 generators>>
  gap> Dimension(P);
  12
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Vectorize}}
\logpage{[ 6, 7, 2 ]}\nobreak
\hyperdef{L}{X78E05C8F7ADE2BCD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Vectorize({\slshape M, components})\index{Vectorize@\texttt{Vectorize}}
\label{Vectorize}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape M}} -- a module over a path algebra, \mbox{\texttt{\slshape components}} -- a list of elements of \mbox{\texttt{\slshape M}}. \\
\textbf{\indent Returns:\ }
a vector in \mbox{\texttt{\slshape M}} from a list of path algebra elements \mbox{\texttt{\slshape components}}, which defines the components in the resulting vector.



 The returned vector is normalized, so the vector's components may not match
the input components. }

 In the following example, we create two elements in $P$, perform some elementwise operations, and then construct a submodule using
the two elements as generators.

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
  [ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
  gap> p2:=Vectorize(P,[A.a,A.b,A.w]);
  [ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
  gap> 2*p1 + p2;
  [ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ]
  gap> S:=SubAlgebraModule(P,[p1,p2]);
  <right-module over <algebra-with-one of dimension 8 over GF(11)>>
  gap> Dimension(S);
  3
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{\texttt{\symbol{94}}}}
\logpage{[ 6, 7, 3 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{94}}({\slshape m, a})\index{^@\texttt{\texttt{\symbol{94}}}}
\label{^}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape m}} -- an element of a path algebra module, \mbox{\texttt{\slshape a}} -- an element of a path algebra. \\
\textbf{\indent Returns:\ }
 the element \mbox{\texttt{\slshape m}} multiplied with \mbox{\texttt{\slshape a}}. 



 This action is defined by multiplying each component in \mbox{\texttt{\slshape m}} by \mbox{\texttt{\slshape a}} on the right. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p2^(A.c - A.w);
  [ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
    (Z(11)^5)*w+(Z(11)^0)*c ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 6, 7, 4 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape m1, m2})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape m1, m2}} -- two elements of a module over a path algebra (?). \\
\textbf{\indent Returns:\ }
 `true' if \mbox{\texttt{\slshape m1}} is less than \mbox{\texttt{\slshape m2}} and false otherwise. 



 Elements are compared componentwise from left to right using the ordering of
the underlying algebra. The element \mbox{\texttt{\slshape m1}} is less than \mbox{\texttt{\slshape m2}} if the first time components are not equal, the component of \mbox{\texttt{\slshape m1}} is less than the corresponding component of \mbox{\texttt{\slshape m2}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p1 < p2;
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{/}}
\logpage{[ 6, 7, 5 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{/({\slshape M, N})\index{/@\texttt{/}}
\label{/}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M, N}} -- two finite dimensional modules over a path algebra (?). \\
\textbf{\indent Returns:\ }
 the factor module $M/N$. 



 This module is again a right algebra module, and all applicable methods and
operations are available for the resulting factor module. Furthermore, the
resulting module is a vector space, so operations for computing bases and
dimensions are also available. }

 This 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PS := P/S;
  <9-dimensional right-module over <algebra-with-one of dimension
  8 over GF(11)>> 
  gap> Basis(PS);
  Basis( <9-dimensional right-module over <algebra-with-one of dimension 
  8 over GF(11)>>, [ [ [ <zero> of ..., <zero> of ...,
  (Z(11)^0)*w ] ],  
    [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], 
    [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*b, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*b*c, <zero> of ... ] ], 
    [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], 
    [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ] ] )
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Homomorphisms of Right Modules over Path Algebras}}\label{Homomorphisms}
\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7C049EFC82A7CAA7}{}
{
 This chapter describes the categories, representations, attributes, and
operations on homomorphisms between representations of quivers.

 Given two homorphisms $f\colon L\to M$ and $g\colon M\to N$, then the composition is written $f*g$. The elements in the modules or the representations of a quiver are row
vectors. Therefore the homomorphisms between two modules are acting on these
row vectors, that is, if $m_i$ is in $M[i]$ and $g_i\colon M[i]\to N[i]$ represents the linear map, then the value of $g$ applied to $m_i$ is the matrix product $m_i*g_i$.

 The example used throughout this chapter is the following. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Q:= Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);;
  gap> KQ:= PathAlgebra(Rationals, Q);;
  gap> gen:= GeneratorsOfAlgebra(KQ);;
  gap> a:= gen[4];;
  gap> b:= gen[5];;
  gap> c:= gen[6];;
  gap> d:= gen[7];;
  gap> e:= gen[8];;
  gap> rels:= [d*e,c^2,a*c*d-b*d,e*a];;
  gap> I:= Ideal(KQ,rels);;
  gap> gb:= GBNPGroebnerBasis(rels,KQ);;
  gap> gbb:= GroebnerBasis(I,gb);;
  gap> A:= KQ/I;;
  gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],["c",[[0,0],[1,0]]],
  ["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
  gap> N:= RightModuleOverPathAlgebra(A,mat);;
\end{Verbatim}
 
\section{\textcolor{Chapter }{Categories and representation of homomorphisms}}\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X7B18E84678FA5EE0}{}
{
 

\subsection{\textcolor{Chapter }{IsPathAlgebraModuleHomomorphism}}
\logpage{[ 7, 1, 1 ]}\nobreak
\hyperdef{L}{X79AE9787877E0A28}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebraModuleHomomorphism({\slshape f})\index{IsPathAlgebraModuleHomomorphism@\texttt{IsPathAlgebraModuleHomomorphism}}
\label{IsPathAlgebraModuleHomomorphism}
}\hfill{\scriptsize (filter)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - any object in GAP.\\
 \textbf{\indent Returns:\ }
 true or false depending on if \mbox{\texttt{\slshape f}} belongs to the categories \texttt{IsAdditiveElementWithZero}, \texttt{IsAdditiveElementWithInverse}, \texttt{IsGeneralMapping}, \texttt{RespectsAddition}, \texttt{RespectsZero}, \texttt{RespectsScalarMultiplication}, \texttt{IsTotal} and \texttt{IsSingleValued} or not. 



 This defines the category \texttt{IsPathAlgebraModuleHomomorphism}. }

 

\subsection{\textcolor{Chapter }{RightModuleHomOverAlgebra}}
\logpage{[ 7, 1, 2 ]}\nobreak
\hyperdef{L}{X8318ED607FE21F55}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleHomOverAlgebra({\slshape M, N, mats})\index{RightModuleHomOverAlgebra@\texttt{RightModuleHomOverAlgebra}}
\label{RightModuleHomOverAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}}, \mbox{\texttt{\slshape N}} - two modules over the same (quotient of a) path algebra, \mbox{\texttt{\slshape mats}} - a list of matrices, one for each vertex in the quiver of the path algebra.\\
 \textbf{\indent Returns:\ }
a homomorphism in the category \texttt{IsPathAlgebraModuleHomomorphism} from the module \mbox{\texttt{\slshape M}} to the module \mbox{\texttt{\slshape N}} given by the matrices \mbox{\texttt{\slshape mats}}.



 The arguments \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are two modules over the same algebra (this is checked), and \mbox{\texttt{\slshape mats}} is a list of matrices \texttt{mats[i]}, where \texttt{mats[i]} represents the linear map from \texttt{M[i]} to \texttt{N[i]} with \texttt{i} running through all the vertices in the same order as when the underlying
quiver was created. If both \texttt{DimensionVector(M)[i]} and \texttt{DimensionVector(N)[i]} are non-zero, then \texttt{mats[i]} is a \texttt{DimensionVector(M)[i]} by \texttt{DimensionVector(N)[i]} matrix. If \texttt{DimensionVector(M)[i]} is zero and \texttt{DimensionVector(N)[i]} is non-zero, then \texttt{mats[i]} must be the zero \texttt{1} by \texttt{DimensionVector(N)[i]} matrix. Similarly for the other way around. If both \texttt{DimensionVector(M)[i]} and \texttt{DimensionVector(N)[i]} are zero, then \texttt{mats[i]} must be the \texttt{1} by \texttt{1} zero matrix. The function checks if \mbox{\texttt{\slshape mats}} is a homomorphism from the module \mbox{\texttt{\slshape M}} to the module \mbox{\texttt{\slshape N}} by checking that the matrices given in \mbox{\texttt{\slshape mats}} have the correct size and satisfy the appropriate commutativity conditions
with the matrices in the modules given by \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}. The source (or domain) and the range (or codomain) of the homomorphism
constructed can by obtained again by \texttt{Range} (\ref{Range}) and by \texttt{Source} (\ref{Source}), respectively. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]],
  ["c",[[0]]],["d",[[1]]],["e",[1,0]]]);
  <right-module over <algebra-with-one over Rationals, with 8 generators>>
  gap> DimensionVector(L);
  [ 0, 1, 1 ]
  gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals,
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d],
  [(1)*e] ] )> -> <7-dimensional right-module over AlgebraWithOne(Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] ] )> >
  gap> IsPathAlgebraModuleHomomorphism(f);
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Generalities of homomorphisms}}\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X830529F9800BF688}{}
{
 

\subsection{\textcolor{Chapter }{MatricesOfPathAlgebraMatModuleHomomorphism}}
\logpage{[ 7, 2, 1 ]}\nobreak
\hyperdef{L}{X7B63FBAF84533D75}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatricesOfPathAlgebraMatModuleHomomorphism({\slshape f})\index{MatricesOfPathAlgebraMatModuleHomomorphism@\texttt{Matrices}\-\texttt{Of}\-\texttt{Path}\-\texttt{Algebra}\-\texttt{Mat}\-\texttt{Module}\-\texttt{Homomorphism}}
\label{MatricesOfPathAlgebraMatModuleHomomorphism}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the matrices defining the homomorphism \mbox{\texttt{\slshape f}}.

}

 

\subsection{\textcolor{Chapter }{Range}}
\logpage{[ 7, 2, 2 ]}\nobreak
\hyperdef{L}{X829F76BB80BD55DB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Range({\slshape f})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the range (or codomain) the homomorphism \mbox{\texttt{\slshape f}}.

}

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 7, 2, 3 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Source({\slshape f})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the source (or domain) the homomorphism \mbox{\texttt{\slshape f}}.

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> MatricesOfPathAlgebraMatModuleHomomorphism(f);
  [ [ [ 0, 0, 0 ] ], [ [ 1, 0 ] ], [ [ 1, 2 ] ] ]
  gap> Range(f);
  <7-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> Source(f);
  <2-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> Source(f) = L;
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{PreImagesRepresentative}}
\logpage{[ 7, 2, 4 ]}\nobreak
\hyperdef{L}{X7AE24A1586B7DE79}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PreImagesRepresentative({\slshape f, elem})\index{PreImagesRepresentative@\texttt{PreImagesRepresentative}}
\label{PreImagesRepresentative}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules, \mbox{\texttt{\slshape elem}} - an element in the range of \mbox{\texttt{\slshape f}}.\\
 \textbf{\indent Returns:\ }
a preimage of the element \mbox{\texttt{\slshape elem}} in the range (or codomain) the homomorphism \mbox{\texttt{\slshape f}} if a preimage exists, otherwise it returns \texttt{fail}.



 The function checks if \mbox{\texttt{\slshape elem}} is an element in the range of \mbox{\texttt{\slshape f}} and returns an error message if not. }

 

\subsection{\textcolor{Chapter }{ImageElm}}
\logpage{[ 7, 2, 5 ]}\nobreak
\hyperdef{L}{X7CFAB0157BFB1806}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageElm({\slshape f, elem})\index{ImageElm@\texttt{ImageElm}}
\label{ImageElm}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules, \mbox{\texttt{\slshape elem}} - an element in the source of \mbox{\texttt{\slshape f}}.\\
 \textbf{\indent Returns:\ }
the image of the element \mbox{\texttt{\slshape elem}} in the source (or domain) of the homomorphism \mbox{\texttt{\slshape f}}.



 The function checks if \mbox{\texttt{\slshape elem}} is an element in the source of \mbox{\texttt{\slshape f}}, and it returns an error message otherwise. }

 

\subsection{\textcolor{Chapter }{ImagesSet}}
\logpage{[ 7, 2, 6 ]}\nobreak
\hyperdef{L}{X8781348F7F5796A0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImagesSet({\slshape f, elts})\index{ImagesSet@\texttt{ImagesSet}}
\label{ImagesSet}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules, \mbox{\texttt{\slshape elts}} - an element in the source of \mbox{\texttt{\slshape f}}, or the source of \mbox{\texttt{\slshape f}}.\\
 \textbf{\indent Returns:\ }
the non-zero images of a set of elements \mbox{\texttt{\slshape elts}} in the source of the homomorphism \mbox{\texttt{\slshape f}}, or if \mbox{\texttt{\slshape elts}} is the source of \mbox{\texttt{\slshape f}}, it returns a basis of the image.



 The function checks if the set of elements \mbox{\texttt{\slshape elts}} consists of elements in the source of \mbox{\texttt{\slshape f}}, and it returns an error message otherwise. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  B:=BasisVectors(Basis(N)); 
  [ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
  gap> PreImagesRepresentative(f,B[4]);     
  [ [ 0 ], [ 1 ], [ 0 ] ]
  gap> PreImagesRepresentative(f,B[5]);
  fail
  gap> BL:=BasisVectors(Basis(L));
  [ [ [ 0 ], [ 1 ], [ 0 ] ], [ [ 0 ], [ 0 ], [ 1 ] ] ]
  gap> ImageElm(f,BL[1]);
  [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ]
  gap> ImagesSet(f,L);
  [ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
  gap> ImagesSet(f,BL);
  [ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Zero}}
\logpage{[ 7, 2, 7 ]}\nobreak
\hyperdef{L}{X804B376481243046}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Zero({\slshape f})\index{Zero@\texttt{Zero}}
\label{Zero}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the zero map between \texttt{Source(f)} and \texttt{Range(f)}.

}

 

\subsection{\textcolor{Chapter }{ZeroMapping}}
\logpage{[ 7, 2, 8 ]}\nobreak
\hyperdef{L}{X795FF8DC785F110A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ZeroMapping({\slshape M, N})\index{ZeroMapping@\texttt{ZeroMapping}}
\label{ZeroMapping}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}}, \mbox{\texttt{\slshape N}} - two modules.\\
 \textbf{\indent Returns:\ }
the zero map between \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}.

}

 

\subsection{\textcolor{Chapter }{IdentityMapping}}
\logpage{[ 7, 2, 9 ]}\nobreak
\hyperdef{L}{X7EBAE0368470A603}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IdentityMapping({\slshape M})\index{IdentityMapping@\texttt{IdentityMapping}}
\label{IdentityMapping}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the identity map between \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape M}}.

}

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}= (maps)}}
\logpage{[ 7, 2, 10 ]}\nobreak
\hyperdef{L}{X7E8438F77ECB778E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}= (maps)({\slshape f, g})\index{= (maps)@\texttt{\texttt{\symbol{92}}= (maps)}}
\label{= (maps)}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms between two modules.\\
 \textbf{\indent Returns:\ }
true, if \texttt{Source(f) = Source(g)}, \texttt{Range(f) = Range(g)}, and the matrices defining the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} coincide.

}

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (maps)}}
\logpage{[ 7, 2, 11 ]}\nobreak
\hyperdef{L}{X7FA09A067BE00277}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}+ (maps)({\slshape f, g})\index{+ (maps)@\texttt{\texttt{\symbol{92}}+ (maps)}}
\label{+ (maps)}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms between two modules.\\
 \textbf{\indent Returns:\ }
the sum \mbox{\texttt{\slshape f+g}} of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}.



The function checks if the maps have the same source and the same range, and
returns an error message otherwise. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (maps)}}
\logpage{[ 7, 2, 12 ]}\nobreak
\hyperdef{L}{X7E8438F77ECB778E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}* (maps)({\slshape f, g})\index{* (maps)@\texttt{\texttt{\symbol{92}}* (maps)}}
\label{* (maps)}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms between two modules, or one scalar and one homomorphism
between modules.\\
 \textbf{\indent Returns:\ }
the composition \mbox{\texttt{\slshape fg}} of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}, if the input are maps between representations of the same quivers. If \mbox{\texttt{\slshape f}} or \mbox{\texttt{\slshape g}} is a scalar, it returns the natural action of scalars on the maps between
representations.



The function checks if the maps are composable, in the first case and in the
second case it checks if the scalar is in the correct field, and returns an
error message otherwise. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> z:=Zero(f);
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> f = z;
  false
  gap> Range(f) = Range(z);
  true
  gap> y := ZeroMapping(L,N); 
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> y = z;            
  true
  gap> id := IdentityMapping(N);  
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> f*id;
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> id*f;
  Error, codomain of the first argument is not equal to the domain of the second\
   argument,  called from
  <function>( <arguments> ) called from read-eval-loop
  Entering break read-eval-print loop ...
  you can 'quit;' to quit to outer loop, or
  you can 'return;' to continue
  brk> 
  gap> 2*f + z;
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CoKernelOfWhat}}
\logpage{[ 7, 2, 13 ]}\nobreak
\hyperdef{L}{X7F6E2378786AC02A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoKernelOfWhat({\slshape f})\index{CoKernelOfWhat@\texttt{CoKernelOfWhat}}
\label{CoKernelOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 a homomorphism \mbox{\texttt{\slshape g}}, if \mbox{\texttt{\slshape f}} has been computed as the cokernel of the homomorphism \mbox{\texttt{\slshape g}}. 

}

 

\subsection{\textcolor{Chapter }{ImageOfWhat}}
\logpage{[ 7, 2, 14 ]}\nobreak
\hyperdef{L}{X78EE24857C79789E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageOfWhat({\slshape f})\index{ImageOfWhat@\texttt{ImageOfWhat}}
\label{ImageOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 a homomorphism \mbox{\texttt{\slshape g}}, if \mbox{\texttt{\slshape f}} has been computed as the image projection or the image inclusion of the
homomorphism \mbox{\texttt{\slshape g}}. 

}

 

\subsection{\textcolor{Chapter }{IsInjective}}
\logpage{[ 7, 2, 15 ]}\nobreak
\hyperdef{L}{X7F065FD7822C0A12}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsInjective({\slshape f})\index{IsInjective@\texttt{IsInjective}}
\label{IsInjective}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is one-to-one. 

}

 

\subsection{\textcolor{Chapter }{IsSurjective}}
\logpage{[ 7, 2, 16 ]}\nobreak
\hyperdef{L}{X784ECE847E005B8F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSurjective({\slshape f})\index{IsSurjective@\texttt{IsSurjective}}
\label{IsSurjective}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is onto. 

}

 

\subsection{\textcolor{Chapter }{IsIsomorphism}}
\logpage{[ 7, 2, 17 ]}\nobreak
\hyperdef{L}{X7E07BBF57B92BA56}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsIsomorphism({\slshape f})\index{IsIsomorphism@\texttt{IsIsomorphism}}
\label{IsIsomorphism}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is an isomorphism. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]], 
       ["c",[[0]]],["d",[[1]]],["e",[1,0]]]);;
  gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);;
  gap> g := CoKernelProjection(f);                                       
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <5-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> CoKernelOfWhat(g) = f;
  true
  gap> h := ImageProjection(f);
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> ImageOfWhat(h) = f;
  true
  gap> IsInjective(f); IsSurjective(f); IsIsomorphism(f); IsIsomorphism(h);
  true
  false
  false
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsSplitEpimorphism}}
\logpage{[ 7, 2, 18 ]}\nobreak
\hyperdef{L}{X80A66EFA862E56BC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSplitEpimorphism({\slshape f})\index{IsSplitEpimorphism@\texttt{IsSplitEpimorphism}}
\label{IsSplitEpimorphism}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{false} if the homomorphism \mbox{\texttt{\slshape f}} is not a splittable epimorphism, otherwise it returns a splitting of the
homomorphism \mbox{\texttt{\slshape f}}. 

}

 

\subsection{\textcolor{Chapter }{IsSplitMonomorphism}}
\logpage{[ 7, 2, 19 ]}\nobreak
\hyperdef{L}{X7DFACF1F7D7F7EE9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSplitMonomorphism({\slshape f})\index{IsSplitMonomorphism@\texttt{IsSplitMonomorphism}}
\label{IsSplitMonomorphism}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{false} if the homomorphism \mbox{\texttt{\slshape f}} is not a splittable monomorphism, otherwise it returns a splitting of the
homomorphism \mbox{\texttt{\slshape f}}. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> S := SimpleModules(A)[1];;
  gap> H := HomOverAlgebra(N,S);; 
  gap> IsSplitMonomorphism(H[1]);  
  false      
  gap> f := IsSplitEpimorphism(H[1]);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> IsSplitMonomorphism(f);
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsZero}}
\logpage{[ 7, 2, 20 ]}\nobreak
\hyperdef{L}{X82BDA47282F9BBA7}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsZero({\slshape f})\index{IsZero@\texttt{IsZero}}
\label{IsZero}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is a zero homomorphism. 

}

 

\subsection{\textcolor{Chapter }{KernelOfWhat}}
\logpage{[ 7, 2, 21 ]}\nobreak
\hyperdef{L}{X7EF520F67BA7F082}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KernelOfWhat({\slshape f})\index{KernelOfWhat@\texttt{KernelOfWhat}}
\label{KernelOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 a homomorphism \mbox{\texttt{\slshape g}}, if \mbox{\texttt{\slshape f}} has been computed as the kernel of the homomorphism \mbox{\texttt{\slshape g}}. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]],
    ["c",[[0]]],["d",[[1]]],["e",[1,0]]]);
  <right-module over <algebra-with-one over Rationals, with 8 generators>>
  gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);;
  gap> IsZero(0*f);
  true
  gap> KnownAttributesOfObject(g);
  [ "Range", "Source", "PathAlgebraOfMatModuleMap", "KernelOfWhat" ]
  gap> KernelOfWhat(g) = f;
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Homomorphisms and modules constructed from homomorphisms and modules}}\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X7E8D1A3F7C03CFF1}{}
{
 

\subsection{\textcolor{Chapter }{CoKernel}}
\logpage{[ 7, 3, 1 ]}\nobreak
\hyperdef{L}{X875F177A82BF9B8B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoKernel({\slshape f})\index{CoKernel@\texttt{CoKernel}}
\label{CoKernel}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoKernelProjection({\slshape f})\index{CoKernelProjection@\texttt{CoKernelProjection}}
\label{CoKernelProjection}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the cokernel of a homomorphism \mbox{\texttt{\slshape f}} between two modules.



 The first variant \texttt{CoKernel} returns the cokernel of the homomorphism \mbox{\texttt{\slshape f}} as a module, while the latter one returns the projection homomorphism from the
range of the homomorphism \mbox{\texttt{\slshape f}} to the cokernel of the homomorphism \mbox{\texttt{\slshape f}}. }

 

\subsection{\textcolor{Chapter }{EndOverAlgebra}}
\logpage{[ 7, 3, 2 ]}\nobreak
\hyperdef{L}{X79FDBE1B795308A9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EndOverAlgebra({\slshape M})\index{EndOverAlgebra@\texttt{EndOverAlgebra}}
\label{EndOverAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the endomorphism ring of \mbox{\texttt{\slshape M}} as a subalgebra of the direct sum of the full matrix rings of \texttt{DimensionVector(M)[i] x DimensionVector(M)[i]}, where \mbox{\texttt{\slshape i}} runs over all vertices where \texttt{DimensionVector(M)[i]} is non-zero.



 The endomorphism is an algebra with one, and one can apply for example \texttt{RadicalOfAlgebra} to find the radical of the endomorphism ring. }

 

\subsection{\textcolor{Chapter }{HomFromProjective}}
\logpage{[ 7, 3, 3 ]}\nobreak
\hyperdef{L}{X844682C07989D181}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomFromProjective({\slshape m, M})\index{HomFromProjective@\texttt{HomFromProjective}}
\label{HomFromProjective}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape m}}, \mbox{\texttt{\slshape M}} - an element and a module.\\
 \textbf{\indent Returns:\ }
the homomorphism from the indecomposable projective module defined by the
support of the element \mbox{\texttt{\slshape m}} to the module \mbox{\texttt{\slshape M}}.



 The function checks if \mbox{\texttt{\slshape m}} is an elememt in \mbox{\texttt{\slshape M}} and if the element \mbox{\texttt{\slshape m}} is supported in only one vertex. Otherwise it returns fail. }

 

\subsection{\textcolor{Chapter }{HomOverAlgebra}}
\logpage{[ 7, 3, 4 ]}\nobreak
\hyperdef{L}{X8681E72F7FD4BFCE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomOverAlgebra({\slshape M, N})\index{HomOverAlgebra@\texttt{HomOverAlgebra}}
\label{HomOverAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}}, \mbox{\texttt{\slshape N}} - two modules.\\
 \textbf{\indent Returns:\ }
a basis for the vector space of homomorphisms from \mbox{\texttt{\slshape M}} to \mbox{\texttt{\slshape N}}.



 The function checks if \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are modules over the same algebra, and returns an error message and fail
otherwise. }

 

\subsection{\textcolor{Chapter }{Image}}
\logpage{[ 7, 3, 5 ]}\nobreak
\hyperdef{L}{X87F4D35A826599C6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Image({\slshape f})\index{Image@\texttt{Image}}
\label{Image}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageProjection({\slshape f})\index{ImageProjection@\texttt{ImageProjection}}
\label{ImageProjection}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageInclusion({\slshape f})\index{ImageInclusion@\texttt{ImageInclusion}}
\label{ImageInclusion}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageProjectionInclusion({\slshape f})\index{ImageProjectionInclusion@\texttt{ImageProjectionInclusion}}
\label{ImageProjectionInclusion}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the image of a homomorphism \mbox{\texttt{\slshape f}} between two modules.



 The first variant \texttt{Image} returns the image of the homomorphism \mbox{\texttt{\slshape f}} as a module. The second returns the projection from the source of \mbox{\texttt{\slshape f}} to the image of the homomorphism \mbox{\texttt{\slshape f}}. The third returns the inclusion of the image into the range of the
homomorphism \mbox{\texttt{\slshape f}}. The last one returns both the projection and the inclusion as a list of two
elements (first the projection and then the inclusion). }

 

\subsection{\textcolor{Chapter }{Kernel}}
\logpage{[ 7, 3, 6 ]}\nobreak
\hyperdef{L}{X7DCD99628504B810}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Kernel({\slshape f})\index{Kernel@\texttt{Kernel}}
\label{Kernel}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KernelInclusion({\slshape f})\index{KernelInclusion@\texttt{KernelInclusion}}
\label{KernelInclusion}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
the kernel of a homomorphism \mbox{\texttt{\slshape f}} between two modules.



 The first variant \texttt{Kernel} returns the kernel of the homomorphism \mbox{\texttt{\slshape f}} as a module, while the latter one returns the inclusion homomorphism of the
kernel into the source of the homomorphism \mbox{\texttt{\slshape f}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> hom := HomOverAlgebra(N,N);
  [ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> g := hom[1];
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> M := CoKernel(g);
  <6-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> f := CoKernelProjection(g);
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> Range(f) = M;
  true
  gap> endo := EndOverAlgebra(N);
  <algebra-with-one of dimension 5 over Rationals>
  gap> RadicalOfAlgebra(endo);
  <algebra of dimension 3 over Rationals>
  gap> B := BasisVectors(Basis(N));
  [ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
  gap> p := HomFromProjective(B[1],N);
  <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> U := Image(p);
  <5-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> projinc := ImageProjectionInclusion(p);
  [ <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      5-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> U = Range(projinc[1]);                                      
  true
  gap> Kernel(p);
  <3-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LiftingInclusionMorphisms}}
\logpage{[ 7, 3, 7 ]}\nobreak
\hyperdef{L}{X848B51017E269802}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LiftingInclusionMorphisms({\slshape f, g})\index{LiftingInclusionMorphisms@\texttt{LiftingInclusionMorphisms}}
\label{LiftingInclusionMorphisms}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms with common range.\\
 \textbf{\indent Returns:\ }
 a factorization of \mbox{\texttt{\slshape g}} in terms of \mbox{\texttt{\slshape f}}, whenever possible and \texttt{fail} otherwise. 



 Given two inclusions $f\colon B\to C$ and $g\colon A\to C$, this function constructs a morphism from $A$ to $B$, whenever the image of \mbox{\texttt{\slshape g}} is contained in the image of \mbox{\texttt{\slshape f}}. Otherwise the function returns fail. The function checks if \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} are one-to-one, if they have the same range and if the image of \mbox{\texttt{\slshape g}} is contained in the image of \mbox{\texttt{\slshape f}}. }

 

\subsection{\textcolor{Chapter }{LiftingMorphismFromProjective}}
\logpage{[ 7, 3, 8 ]}\nobreak
\hyperdef{L}{X7A10EF0587ADA535}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LiftingMorphismFromProjective({\slshape f, g})\index{LiftingMorphismFromProjective@\texttt{LiftingMorphismFromProjective}}
\label{LiftingMorphismFromProjective}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms with common range.\\
 \textbf{\indent Returns:\ }
 a factorization of \mbox{\texttt{\slshape g}} in terms of \mbox{\texttt{\slshape f}}, whenever possible and \texttt{fail} otherwise. 



 Given two morphisms $f\colon B\to C$ and $g\colon P\to C$, where $P$ is a direct sum of indecomposable projective modules constructed via \texttt{DirectSumOfModules} and \mbox{\texttt{\slshape f}} an epimorphism, this function finds a lifting of \mbox{\texttt{\slshape g}} to $B$. The function checks if $P$ is a direct sum of indecomposable projective modules, if \mbox{\texttt{\slshape f}} is onto and if \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} have the same range. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> B := BasisVectors(Basis(N));
  [ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
    [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
  gap> g := SubRepresentationInclusion(N,[B[1],B[4]]);
  <mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> f := SubRepresentationInclusion(N,[B[1],B[2]]);
  <mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> LiftingInclusionMorphisms(f,g);
  <mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> S := SimpleModules(A); 
  [ <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
    <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
    <right-module over <algebra-with-one over Rationals, with 8 generators>> ]
  gap> homNS := HomOverAlgebra(N,S[1]);
  [ <mapping: <
      7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
      1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >, 
    <mapping: <
      7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
      1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >, 
    <mapping: <
      7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
      1-dimensional right-module over AlgebraWithOne( Rationals, ... )> > ]
  gap> f := homNS[1];
  <mapping: <
  7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
  1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >
  gap> p := ProjectiveCover(S[1]);
  <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> LiftingMorphismFromProjective(f,p);
  <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{LeftMinimalVersion}}
\logpage{[ 7, 3, 9 ]}\nobreak
\hyperdef{L}{X7F2D09C07F6DDBF8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeftMinimalVersion({\slshape f})\index{LeftMinimalVersion@\texttt{LeftMinimalVersion}}
\label{LeftMinimalVersion}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 the left minimal version \mbox{\texttt{\slshape f'}} of the homomorphism \mbox{\texttt{\slshape f}} together with the a list \texttt{B} of modules such that the direct sum of the modules, \texttt{Range(f')} and the modules in the list \texttt{B} is isomorphic to \texttt{Range(f)}. 

}

 

\subsection{\textcolor{Chapter }{RightMinimalVersion}}
\logpage{[ 7, 3, 10 ]}\nobreak
\hyperdef{L}{X7D479D1C7C4DF55B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightMinimalVersion({\slshape f})\index{RightMinimalVersion@\texttt{RightMinimalVersion}}
\label{RightMinimalVersion}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape f}} - a homomorphism between two modules.\\
 \textbf{\indent Returns:\ }
 the right minimal version \mbox{\texttt{\slshape f'}} of the homomorphism \mbox{\texttt{\slshape f}} together with the a list \texttt{B} of modules such that the direct sum of the modules, \texttt{Source(f')} and the modules on the list \texttt{B} is isomorphic to \texttt{Source(f)}. 

}

 

\subsection{\textcolor{Chapter }{MinimalLeftApproximation}}
\logpage{[ 7, 3, 11 ]}\nobreak
\hyperdef{L}{X86A43CB784C2CDBA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimalLeftApproximation({\slshape C, M})\index{MinimalLeftApproximation@\texttt{MinimalLeftApproximation}}
\label{MinimalLeftApproximation}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape C}}, \mbox{\texttt{\slshape M}} - two modules.\\
 \textbf{\indent Returns:\ }
 the minimal left \texttt{add M}-approximation of the module \mbox{\texttt{\slshape C}}. Note: The order of the arguments is opposite of the order for minimal right
approximations. 

}

 

\subsection{\textcolor{Chapter }{MinimalRightApproximation}}
\logpage{[ 7, 3, 12 ]}\nobreak
\hyperdef{L}{X86A02B5381F62FE6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MinimalRightApproximation({\slshape M, C})\index{MinimalRightApproximation@\texttt{MinimalRightApproximation}}
\label{MinimalRightApproximation}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape M}}, \mbox{\texttt{\slshape C}} - two modules.\\
 \textbf{\indent Returns:\ }
 the minimal right \texttt{add M}-approximation of the module \mbox{\texttt{\slshape C}}. Note: The order of the arguments is opposite of the order for minimal left
approximations. 

}

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> H:= HomOverAlgebra(N,N);;
  gap> RightMinimalVersion(H[1]);   
  [ <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    [ <6-dimensional right-module over <algebra-with-one of dimension 
          17 over Rationals>> ] ]
  gap> LeftMinimalVersion(H[1]);             
  [ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      1-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    [ <6-dimensional right-module over <algebra-with-one of dimension 
          17 over Rationals>> ] ]
  gap> S:=SimpleModules(A)[1];;
  gap> MinimalRightApproximation(N,S);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> S:=SimpleModules(A)[3];;
  gap> MinimalLeftApproximation(S,N);        
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MorphismOnKernel}}
\logpage{[ 7, 3, 13 ]}\nobreak
\hyperdef{L}{X87AB8D2E8660869D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MorphismOnKernel({\slshape f, g, alpha, beta})\index{MorphismOnKernel@\texttt{MorphismOnKernel}}
\label{MorphismOnKernel}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MorphismOnImage({\slshape f, g, alpha, beta})\index{MorphismOnImage@\texttt{MorphismOnImage}}
\label{MorphismOnImage}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MorphismOnCoKernel({\slshape f, g, alpha, beta})\index{MorphismOnCoKernel@\texttt{MorphismOnCoKernel}}
\label{MorphismOnCoKernel}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}}, \mbox{\texttt{\slshape alpha}}, \mbox{\texttt{\slshape beta}} - four homomorphisms of modules.\\
 \textbf{\indent Returns:\ }
the morphism induced on the kernels, the images or the cokernels of the
morphisms \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}, respectively, whenever $f\colon A\to B$, $\beta\colon B\to B'$, $\alpha\colon A\to A'$ and $g\colon A'\to B'$ forms a commutative diagram.



 It is checked if \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}}, \mbox{\texttt{\slshape alpha}}, \mbox{\texttt{\slshape beta}} forms a commutative diagram, that is, if $f \beta - \alpha g = 0$. }

 

\subsection{\textcolor{Chapter }{ProjectiveCover}}
\logpage{[ 7, 3, 14 ]}\nobreak
\hyperdef{L}{X83257E2F7F8E0068}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ProjectiveCover({\slshape M})\index{ProjectiveCover@\texttt{ProjectiveCover}}
\label{ProjectiveCover}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the projective cover of \mbox{\texttt{\slshape M}}, that is, returns the map $P(M)\to M$.



 If the module \mbox{\texttt{\slshape M}} is zero, then the zero map to \mbox{\texttt{\slshape M}} is returned. }

 

\subsection{\textcolor{Chapter }{PullBack}}
\logpage{[ 7, 3, 15 ]}\nobreak
\hyperdef{L}{X7C705F2A79F8E43C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PullBack({\slshape f, g})\index{PullBack@\texttt{PullBack}}
\label{PullBack}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms with a common range.\\
 \textbf{\indent Returns:\ }
the pullback of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}.



 It is checked if \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} have the same range. Given the input $f\colon A\to B$ (horizontal map) and $g\colon C\to B$ (vertical map), the pullback $E$ is returned as the two homomorphisms $[f',g']$, where $f'\colon E\to C$ (horizontal map) and $g'\colon E\to A$ (vertical map). }

 

\subsection{\textcolor{Chapter }{PushOut}}
\logpage{[ 7, 3, 16 ]}\nobreak
\hyperdef{L}{X81A2D49D85923894}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PushOut({\slshape f, g})\index{PushOut@\texttt{PushOut}}
\label{PushOut}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape f}}, \mbox{\texttt{\slshape g}} - two homomorphisms between modules with a common source.\\
 \textbf{\indent Returns:\ }
the pushout of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}.



 It is checked if \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} have the same source. Given the input $f\colon A\to B$ (horizontal map) and $g\colon A\to C$ (vertical map), the pushout $E$ is returned as the two homomorphisms $[f',g']$, where $f'\colon C\to E$ (horizontal map) and $g'\colon B\to E$ (vertical map). }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> g := MorphismOnKernel(hom[1],hom[2],hom[1],hom[2]);
  <mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> IsomorphicModules(Source(g),Range(g));
  true
  gap> p := ProjectiveCover(N);
  <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> N1 := Kernel(p);
  <17-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> pullback := PullBack(p,hom[1]);
  [ <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      7-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> Kernel(pullback[1]);
  <17-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> IsomorphicModules(N1,Kernel(pullback[1]));
  true
  gap> t := LiftingMorphismFromProjective(p,p*hom[1]);
  <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <24-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> s := MorphismOnKernel(p,p,t,hom[1]);    
  <mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <17-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> Source(s)=N1;
  true
  gap> q := KernelInclusion(p);
  <mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <24-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> pushout := PushOut(q,s);
  [ <mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      24-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> U := CoKernel(pushout[1]);
  <7-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> IsomorphicModules(U,N);
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RadicalOfModuleInclusion}}
\logpage{[ 7, 3, 17 ]}\nobreak
\hyperdef{L}{X7BF04DAE78E98D9C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalOfModuleInclusion({\slshape M})\index{RadicalOfModuleInclusion@\texttt{RadicalOfModuleInclusion}}
\label{RadicalOfModuleInclusion}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the inclusion of the radical of the module \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}.



 The radical of \mbox{\texttt{\slshape M}} can be accessed using \texttt{Source}, or it can be computed directly via the command \texttt{RadicalOfModule} (\ref{RadicalOfModule}). }

 

\subsection{\textcolor{Chapter }{SocleOfModuleInclusion}}
\logpage{[ 7, 3, 18 ]}\nobreak
\hyperdef{L}{X82EB23337C5F4DBB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleOfModuleInclusion({\slshape M})\index{SocleOfModuleInclusion@\texttt{SocleOfModuleInclusion}}
\label{SocleOfModuleInclusion}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the inclusion of the socle of the module \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}.



 The socle of \mbox{\texttt{\slshape M}} can be accessed using \texttt{Source}, or it can be computed directly via the command \texttt{SocleOfModule} (\ref{SocleOfModule}). }

 

\subsection{\textcolor{Chapter }{SubRepresentationInclusion}}
\logpage{[ 7, 3, 19 ]}\nobreak
\hyperdef{L}{X7E9BF05587D4A86A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SubRepresentationInclusion({\slshape M, gens})\index{SubRepresentationInclusion@\texttt{SubRepresentationInclusion}}
\label{SubRepresentationInclusion}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module, \mbox{\texttt{\slshape gens}} - a list of elements in \mbox{\texttt{\slshape M}}.\\
 \textbf{\indent Returns:\ }
the inclusion of the submodule generated by the generators \mbox{\texttt{\slshape gens}} into the module \mbox{\texttt{\slshape M}}.



 The function checks if \mbox{\texttt{\slshape gens}} consists of elements in \mbox{\texttt{\slshape M}}, and returns an error message otherwise. The module given by the submodule
generated by the generators \mbox{\texttt{\slshape gens}} can be accessed using \texttt{Source}. }

 

\subsection{\textcolor{Chapter }{TopOfModuleProjection}}
\logpage{[ 7, 3, 20 ]}\nobreak
\hyperdef{L}{X804BD7CD804E63C4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TopOfModuleProjection({\slshape M})\index{TopOfModuleProjection@\texttt{TopOfModuleProjection}}
\label{TopOfModuleProjection}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module.\\
 \textbf{\indent Returns:\ }
the projection from the module \mbox{\texttt{\slshape M}} to the top of the module \mbox{\texttt{\slshape M}}.



 The module given by the top of the module \mbox{\texttt{\slshape M}} can be accessed using \texttt{Range} of the homomorphism. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> f := RadicalOfModuleInclusion(N);
  <mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> radN := Source(f);
  <4-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> g := SocleOfModuleInclusion(N);
  <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> U := SubRepresentationInclusion(N,[B[5]+B[6],B[7]]);
  <mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> h := TopOfModuleProjection(N);
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <3-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Homological algebra}}\logpage{[ 7, 4, 0 ]}
\hyperdef{L}{X7D310EDE847865C1}{}
{
 

\subsection{\textcolor{Chapter }{ExtOverAlgebra}}
\logpage{[ 7, 4, 1 ]}\nobreak
\hyperdef{L}{X787217547958E9C3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtOverAlgebra({\slshape M, N})\index{ExtOverAlgebra@\texttt{ExtOverAlgebra}}
\label{ExtOverAlgebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtOverAlgebraAdd({\slshape M, N})\index{ExtOverAlgebraAdd@\texttt{ExtOverAlgebraAdd}}
\label{ExtOverAlgebraAdd}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}}, \mbox{\texttt{\slshape N}} - two modules.\\
 \textbf{\indent Returns:\ }
a list of two elements \texttt{ExtOverAlgebra} or three elements \texttt{ExtOverAlgebraAdd}, where the first element is the map from the first syzygy, $\Omega(M)$ to the projective cover, $P(M)$ of the module \mbox{\texttt{\slshape M}}, the second element is a basis of $\Ext^1(M,N)$ in terms of elements in $\Hom(\Omega(M),N)$ and the third element is a function which preforms the addition in $\Ext^1(M,N)$.



 The function checks if the arguments \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are modules of the same algebra, and returns an error message otherwise. It $\Ext^1(M,N)$ is zero, an empty list is returned. }

 

\subsection{\textcolor{Chapter }{ExtAlgebraGenerators}}
\logpage{[ 7, 4, 2 ]}\nobreak
\hyperdef{L}{X7B9209CD7A46F544}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ExtAlgebraGenerators({\slshape M, n})\index{ExtAlgebraGenerators@\texttt{ExtAlgebraGenerators}}
\label{ExtAlgebraGenerators}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - a module, \mbox{\texttt{\slshape n}} - a positive integer.\\
 \textbf{\indent Returns:\ }
returns a list of three elements, where the first element is the dimensions of
Ext\texttt{\symbol{94}}[0..n](M,M), the second element is the number of
minimal generators in the degrees [0..n], and the third element is the
generators in these degrees.



 This function computes the generators of the Ext-algebra $Ext^*(M,M)$ up to degree \mbox{\texttt{\slshape n}}. }

 }

 
\section{\textcolor{Chapter }{Auslander-Reiten theory}}\logpage{[ 7, 5, 0 ]}
\hyperdef{L}{X855427278501E7FB}{}
{
 

\subsection{\textcolor{Chapter }{AlmostSplitSequence}}
\logpage{[ 7, 5, 1 ]}\nobreak
\hyperdef{L}{X87BADA287BD9972C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AlmostSplitSequence({\slshape M})\index{AlmostSplitSequence@\texttt{AlmostSplitSequence}}
\label{AlmostSplitSequence}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape M}} - an indecomposable non-projective module.\\
 \textbf{\indent Returns:\ }
the almost split sequence ending in the module \mbox{\texttt{\slshape M}} if it is indecomposable and not projective. It returns the almost split
sequence in terms of two maps, a left minimal almost split map and a right
minimal almost split map. 



 The range of the right minimal almost split map is not necessarily equal to
the module \mbox{\texttt{\slshape M}} one started with, but isomorphic. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> S := SimpleModules(A);
  [ <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
    <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
    <right-module over <algebra-with-one over Rationals, with 8 generators>> ]
  gap> Ext:=ExtOverAlgebra(S[2],S[2]);
  [ <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      4-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    [ <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
          [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
            [(1)*e] ] )> -> <
          1-dimensional right-module over AlgebraWithOne( Rationals, 
          [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
            [(1)*e] ] )> > ] ]
  gap> Length(Ext[2]);
  1
  gap> # i.e. Ext^1(S[2],S[2]) is 1-dimensional
  gap> pushout := PushOut(Ext[2][1],Ext[1]);   
  [ <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      2-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      2-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> f:= CoKernelProjection(pushout[1]);
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
   ] )> >
  gap> U := Range(pushout[1]);            
  <2-dimensional right-module over <algebra-with-one over Rationals, with 
  8 generators>>
  gap> assU := AlmostSplitSequence(U);
  [ <mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      8-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> >, 
    <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> -> <
      2-dimensional right-module over AlgebraWithOne( Rationals, 
      [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
        [(1)*e] ] )> > ]
  gap> assU[1]*assU[2] = Zero(assU[1]*assU[2]);
  true
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Chain complexes}}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X7A06103979B92808}{}
{
  (Not completely documentet yet.) 
\section{\textcolor{Chapter }{Representation of categories}}\logpage{[ 8, 1, 0 ]}
\hyperdef{L}{X7CAF603281B94AC8}{}
{
  A chain complex consists of objects and morphisms from some category. In QPA,
this category will usually be the category of right modules over some quotient
of a path algebra. 

\subsection{\textcolor{Chapter }{IsCat}}
\logpage{[ 8, 1, 1 ]}\nobreak
\hyperdef{L}{X7F0E546178977963}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCat\index{IsCat@\texttt{IsCat}}
\label{IsCat}
}\hfill{\scriptsize (Category)}}\\


 The category for categories. A category is a record, storing a number of
properties that is specified within each category. Two categories can be
compared using \texttt{=}. Currently, the only implemented category is the one of right modules over a
(quotient of a) path algebra. }

 

\subsection{\textcolor{Chapter }{CatOfRightAlgebraModules}}
\logpage{[ 8, 1, 2 ]}\nobreak
\hyperdef{L}{X7BB9B02E7E76FF9C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CatOfRightAlgebraModules({\slshape A})\index{CatOfRightAlgebraModules@\texttt{CatOfRightAlgebraModules}}
\label{CatOfRightAlgebraModules}
}\hfill{\scriptsize (operation)}}\\


Arguments: \mbox{\texttt{\slshape A}} -- a (quotient of a) path algebra.\\
 \textbf{\indent Returns:\ }
The category mod $A$. 



 mod $A$ has several properties, which can be accessed using the \texttt{.} mark. Some of the properties store functions. All properties are demonstrated
in the following example. 
\begin{itemize}
\item \texttt{zeroObj} -- returns the zero module of mod $A$.
\item \texttt{isZeroObj} -- returns true if the given module is zero.
\item \texttt{zeroMap} -- returns the ZeroMapping function.
\item \texttt{isZeroMapping} -- returns the IsZero test.
\item \texttt{composeMaps} -- returns the composition of the two given maps.
\item \texttt{ker} -- returns the Kernel function.
\item \texttt{im} -- returns the Image function.
\item \texttt{isExact} -- returns true if two consecutive maps are exact. 
\end{itemize}
 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> alg;
  <algebra-with-one over Rationals, with 7 generators>
  gap> # L, M, and N are alg-modules
  gap> # f: L --> M and g: M --> N are non-zero morphisms
  gap> cat := CatOfRightAlgebraModules(alg);
  <cat: right modules over algebra>
  gap> cat.zeroObj;
  <right-module over <algebra-with-one over Rationals, with 7 generators>>
  gap> cat.isZeroObj(M);
  false
  gap> cat.zeroMap(M,N);
  <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ])> -> 
    <1-dimensional right-module over AlgebraWithOne( Rationals,
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
  gap> cat.composeMaps(g,f);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c]]
    -> <1-dimensional right-module over AlgebraWithOne( Rationals,
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
  gap> cat.ker(g);
  <2-dimensional right-module over <algebra-with-one over Rationals,
    with 7 generators>>
  gap> cat.isExact(g,f);
  false 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Making a complex}}\logpage{[ 8, 2, 0 ]}
\hyperdef{L}{X7EC3D95F7C791F7E}{}
{
  The most general constructor for complexes is the function \texttt{Complex} (\ref{Complex}). In addition to this, there are constructors for common special cases: 
\begin{itemize}
\item \texttt{ZeroComplex} (\ref{ZeroComplex})
\item \texttt{StalkComplex} (\ref{StalkComplex})
\item \texttt{FiniteComplex} (\ref{FiniteComplex})
\item \texttt{ShortExactSequence} (\ref{ShortExactSequence})
\end{itemize}
  

\subsection{\textcolor{Chapter }{IsComplex}}
\logpage{[ 8, 2, 1 ]}\nobreak
\hyperdef{L}{X856E7B4E8264E8F0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsComplex\index{IsComplex@\texttt{IsComplex}}
\label{IsComplex}
}\hfill{\scriptsize (Category)}}\\


 The category for chain complexes. }

 

\subsection{\textcolor{Chapter }{IsZeroComplex}}
\logpage{[ 8, 2, 2 ]}\nobreak
\hyperdef{L}{X7E0CE8AC87533991}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsZeroComplex\index{IsZeroComplex@\texttt{IsZeroComplex}}
\label{IsZeroComplex}
}\hfill{\scriptsize (Category)}}\\


 Category for zero complexes, subcategory of \texttt{IsComplex} (\ref{IsComplex}). }

 

\subsection{\textcolor{Chapter }{Complex}}
\logpage{[ 8, 2, 3 ]}\nobreak
\hyperdef{L}{X7E51958C86D73D17}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Complex({\slshape cat, baseDegree, middle, positive, negative})\index{Complex@\texttt{Complex}}
\label{Complex}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A newly created chain complex



 The first argument, \mbox{\texttt{\slshape cat}} is an \texttt{IsCat} (\ref{IsCat}) object describing the category to create a chain complex over.

 The rest of the arguments describe the differentials of the complex. These are
divided into three parts: one finite (``middle'') and two infinite (``positive'' and ``negative''). The positive part contains all differentials in degrees higher than those
in the middle part, and the negative part contains all differentials in
degrees lower than those in the middle part. (The middle part may be placed
anywhere, so the positive part can -- despite its name -- contain some
differentials of negative degree. Conversely, the negative part can contain
some differentials of positive degree.)

 The argument \mbox{\texttt{\slshape middle}} is a list containing the differentials for the middle part. The argument \mbox{\texttt{\slshape baseDegree}} gives the degree of the first differential in this list. The second
differential is placed in degree $\mbox{\texttt{\slshape baseDegree}}+1$, and so on. Thus, the middle part consists of the degrees 
\[ \mbox{\texttt{\slshape baseDegree}},\quad \mbox{\texttt{\slshape baseDegree}} + 1,\quad \ldots\quad \mbox{\texttt{\slshape baseDegree}} + \text{Length}(\mbox{\texttt{\slshape middle}}). \]
 Each of the arguments \mbox{\texttt{\slshape positive}} and \mbox{\texttt{\slshape negative}} can be one of the following: 
\begin{itemize}
\item The string \texttt{"zero"}, meaning that the part contains only zero objects and zero morphisms.
\item A list of the form \texttt{[ "repeat", L ]}, where \texttt{L} is a list of morphisms. The part will contain the differentials in \texttt{L} repeated infinitely many times. The convention for the order of elements in \texttt{L} is that \texttt{L[1]} is the differential which is closest to the middle part, and \texttt{L[Length(L)]} is farthest away from the middle part.
\item A list of the form \texttt{[ "pos", f ]} or \texttt{[ "pos", f, store ]}, where \texttt{f} is a function of two arguments, and \texttt{store} (if included) is a boolean. The function \texttt{f} is used to compute the differentials in this part. The function \texttt{f} is not called immediately by the \texttt{Complex} constructor, but will be called later as the differentials in this part are
needed. The function call \texttt{f(C,i)} (where \texttt{C} is the complex and \texttt{i} an integer) should produce the differential in degree \texttt{i}. The function may use \texttt{C} to look up other differentials in the complex, as long as this does not cause
an infinite loop. If \texttt{store} is \texttt{true} (or not specified), each computed differential is stored, and they are
computed in order from the one closest to the middle part, regardless of which
order they are requested in.
\item A list of the form \texttt{[ "next", f, init ]}, where \texttt{f} is a function of one argument, and \texttt{init} is a morphism. The function \texttt{f} is used to compute the differentials in this part. For the first differential
in the part (that is, the one closest to the middle part), \texttt{f} is called with \texttt{init} as argument. For the next differential, \texttt{f} is called with the first differential as argument, and so on. Thus, the
differentials are 
\[ f(\text{init}),\quad f^2(\text{init}),\quad f^3(\text{init}),\quad \ldots \]
 Each differential is stored when it has been computed. 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{ZeroComplex}}
\logpage{[ 8, 2, 4 ]}\nobreak
\hyperdef{L}{X80F8DD20789BBBC0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ZeroComplex({\slshape cat})\index{ZeroComplex@\texttt{ZeroComplex}}
\label{ZeroComplex}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A newly created zero complex



 This function creates a zero complex (a complex consisting of only zero
objects and zero morphisms) over the category described by the \texttt{IsCat} (\ref{IsCat}) object \mbox{\texttt{\slshape cat}}. }

 

\subsection{\textcolor{Chapter }{FiniteComplex}}
\logpage{[ 8, 2, 5 ]}\nobreak
\hyperdef{L}{X7C75868E82A831C8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{FiniteComplex({\slshape cat, baseDegree, differentials})\index{FiniteComplex@\texttt{FiniteComplex}}
\label{FiniteComplex}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A newly created complex



 This function creates a complex where all but finitely many objects are the
zero object.

 The argument \mbox{\texttt{\slshape cat}} is an \texttt{IsCat} (\ref{IsCat}) object describing the category to create a chain complex over.

 The argument \mbox{\texttt{\slshape differentials}} is a list of morphisms. The argument \mbox{\texttt{\slshape baseDegree}} gives the degree for the first differential in this list. The subsequent
differentials are placed in degrees $\mbox{\texttt{\slshape baseDegree}}+1$, and so on.

 This means that the \mbox{\texttt{\slshape differentials}} argument specifies the differentials in degrees 
\[ \mbox{\texttt{\slshape baseDegree}},\quad \mbox{\texttt{\slshape baseDegree}} + 1,\quad \ldots \quad \mbox{\texttt{\slshape baseDegree}} + \text{Length}(\mbox{\texttt{\slshape differentials}}); \]
 and thus implicitly the objects in degrees 
\[ \mbox{\texttt{\slshape baseDegree}} - 1,\quad \mbox{\texttt{\slshape baseDegree}},\quad \ldots \quad \mbox{\texttt{\slshape baseDegree}} + \text{Length}(\mbox{\texttt{\slshape differentials}}). \]
 All other objects in the complex are zero. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> # L, M and N are modules over the same algebra A
  gap> # cat is the category mod A
  gap> # f: L --> M and g: M --> N maps
  gap> C := FiniteComplex(cat, 1, [g,f]);
  0 -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> 0 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{StalkComplex}}
\logpage{[ 8, 2, 6 ]}\nobreak
\hyperdef{L}{X80B47D78785F6859}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StalkComplex({\slshape cat, obj, degree})\index{StalkComplex@\texttt{StalkComplex}}
\label{StalkComplex}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape cat}} -- a category, \mbox{\texttt{\slshape obj}} -- an object in \mbox{\texttt{\slshape cat}}, \mbox{\texttt{\slshape degree}} -- the degree \mbox{\texttt{\slshape obj}} should be placed in.\\
 \textbf{\indent Returns:\ }
a newly created complex. 



 The new complex is a stalk complex with \mbox{\texttt{\slshape obj}} in position \mbox{\texttt{\slshape degree}}, and zero elsewhere. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Ms := StalkComplex(cat, M, 3);
  0 -> 3:(2,2) -> 0 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{ShortExactSequence}}
\logpage{[ 8, 2, 7 ]}\nobreak
\hyperdef{L}{X7A685484784087FE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ShortExactSequence({\slshape cat, f, g})\index{ShortExactSequence@\texttt{ShortExactSequence}}
\label{ShortExactSequence}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\slshape cat}} -- a category, \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} -- maps in \mbox{\texttt{\slshape cat}}, where \mbox{\texttt{\slshape f}}: $A \rightarrow B$ and \mbox{\texttt{\slshape g}}: $B \rightarrow C$.\\
 \textbf{\indent Returns:\ }
a newly created complex. 



If the sequence $0 \rightarrow A \rightarrow B \rightarrow C \rightarrow 0$ is exact, this complex (with $B$ in degree 0) is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> ses := ShortExactSequence(cat, f, g);
  0 -> 1:(0,0,1,0) -> 0:(0,1,1,1) -> -1:(0,1,0,1) -> 0 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Information about a complex}}\logpage{[ 8, 3, 0 ]}
\hyperdef{L}{X7F7E0C197FA31B29}{}
{
  

\subsection{\textcolor{Chapter }{CatOfComplex}}
\logpage{[ 8, 3, 1 ]}\nobreak
\hyperdef{L}{X7BBF131485F3C792}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CatOfComplex({\slshape C})\index{CatOfComplex@\texttt{CatOfComplex}}
\label{CatOfComplex}
}\hfill{\scriptsize (attribute)}}\\
\textbf{\indent Returns:\ }
 The category the objects of the complex \mbox{\texttt{\slshape C}} live in. 



 }

 

\subsection{\textcolor{Chapter }{ObjectOfComplex}}
\logpage{[ 8, 3, 2 ]}\nobreak
\hyperdef{L}{X8239596E87830A51}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ObjectOfComplex({\slshape C, i})\index{ObjectOfComplex@\texttt{ObjectOfComplex}}
\label{ObjectOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
 The object at position \mbox{\texttt{\slshape i}} in the complex. 



 }

 

\subsection{\textcolor{Chapter }{DifferentialOfComplex}}
\logpage{[ 8, 3, 3 ]}\nobreak
\hyperdef{L}{X7B597AC77A3D71F9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DifferentialOfComplex({\slshape C, i})\index{DifferentialOfComplex@\texttt{DifferentialOfComplex}}
\label{DifferentialOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
 The map in \mbox{\texttt{\slshape C}} between objects at positions $i$ and $i-1$. 



 }

 

\subsection{\textcolor{Chapter }{DifferentialsOfComplex}}
\logpage{[ 8, 3, 4 ]}\nobreak
\hyperdef{L}{X858D2D1A8674D2EC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DifferentialsOfComplex({\slshape C})\index{DifferentialsOfComplex@\texttt{DifferentialsOfComplex}}
\label{DifferentialsOfComplex}
}\hfill{\scriptsize (attribute)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex\\
 \textbf{\indent Returns:\ }
 The differentials of the complex, stored as an \texttt{IsInfList} object. 

}

 

\subsection{\textcolor{Chapter }{CyclesOfComplex}}
\logpage{[ 8, 3, 5 ]}\nobreak
\hyperdef{L}{X85FBFD9C8382C93B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CyclesOfComplex({\slshape C, i})\index{CyclesOfComplex@\texttt{CyclesOfComplex}}
\label{CyclesOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer. \\
 \textbf{\indent Returns:\ }
The $i$-cycle of the complex, that is the subobject $Ker(d_i)$ of \texttt{ObjectOfComplex(C,i)}. 



 }

 

\subsection{\textcolor{Chapter }{BoundariesOfComplex}}
\logpage{[ 8, 3, 6 ]}\nobreak
\hyperdef{L}{X8168D8CC7805FE30}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BoundariesOfComplex({\slshape C, i})\index{BoundariesOfComplex@\texttt{BoundariesOfComplex}}
\label{BoundariesOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer. \\
 \textbf{\indent Returns:\ }
 The $i$-boundary of the complex, that is the subobject $Im(d_{i+1})$ of \texttt{ObjectOfComplex(C,i)}. 



 }

 

\subsection{\textcolor{Chapter }{HomologyOfComplex}}
\logpage{[ 8, 3, 7 ]}\nobreak
\hyperdef{L}{X7F8D61447AB57EF3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HomologyOfComplex({\slshape C, i})\index{HomologyOfComplex@\texttt{HomologyOfComplex}}
\label{HomologyOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
 The $i$th homology of the complex, that is, $Ker(d_i)/Im(d_{i+1})$. 



Note: this operation is currently not available. When working in the category
of right $kQ/I$-modules, it is possible to "cheat" and use the following procedure to compute
the homology of a complex: }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C;                     
  0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
  gap> # Want to compute the homology in degree 2
  gap> f := DifferentialOfComplex(C,3);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
    < 4-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
  gap> g := KernelInclusion(DifferentialOfComplex(C,2));
    <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
    < 4-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
  gap> # We know that Im f is included in Ker g, so can find the
  gap> # lifting morphism h from C_3 to Ker g.
  gap> h := LiftingInclusionMorphisms(g,f);
    <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
    < 2-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
  gap> # The cokernel of h is Ker g / Im f 
  gap> Homology := CoKernel(h);
  <1-dimensional right-module over <algebra-with-one over Rationals, with 
    4 generators>> 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsFiniteComplex}}
\logpage{[ 8, 3, 8 ]}\nobreak
\hyperdef{L}{X7DCBCF7682DC87FC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsFiniteComplex({\slshape C})\index{IsFiniteComplex@\texttt{IsFiniteComplex}}
\label{IsFiniteComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape C}} is a finite complex, false otherwise. 



 }

 

\subsection{\textcolor{Chapter }{UpperBound}}
\logpage{[ 8, 3, 9 ]}\nobreak
\hyperdef{L}{X7A5CB74485184FEE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{UpperBound({\slshape C})\index{UpperBound@\texttt{UpperBound}}
\label{UpperBound}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
If it exists: The smallest integer $i$ such that the object at position $i$ is non-zero, but for all $j > i$ the object at position $j$ is zero. 



If \mbox{\texttt{\slshape C}} is not a finite complex, the operation will return fail or infinity, depending
on how \mbox{\texttt{\slshape C}} was defined. }

 

\subsection{\textcolor{Chapter }{LowerBound}}
\logpage{[ 8, 3, 10 ]}\nobreak
\hyperdef{L}{X807CC5AD7FDFA4E3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowerBound({\slshape C})\index{LowerBound@\texttt{LowerBound}}
\label{LowerBound}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
If it exists: The greatest integer $i$ such that the object at position $i$ is non-zero, but for all $j < i$ the object at position $j$ is zero. 



If \mbox{\texttt{\slshape C}} is not a finite complex, the operation will return fail or negative infinity,
depending on how \mbox{\texttt{\slshape C}} was defined. }

 

\subsection{\textcolor{Chapter }{LengthOfComplex}}
\logpage{[ 8, 3, 11 ]}\nobreak
\hyperdef{L}{X7C1F81277A5AC8B4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LengthOfComplex({\slshape C})\index{LengthOfComplex@\texttt{LengthOfComplex}}
\label{LengthOfComplex}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
the length of the complex. 



The length is defined as follows: If \mbox{\texttt{\slshape C}} is a zero complex, the length is zero. If \mbox{\texttt{\slshape C}} is a finite complex, the lenght is the upper bound -- the lower bound + 1. If \mbox{\texttt{\slshape C}} is an inifinite complex, the lenght is infinity. }

 

\subsection{\textcolor{Chapter }{HighestKnownDegree}}
\logpage{[ 8, 3, 12 ]}\nobreak
\hyperdef{L}{X82D615CD796C9C0A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HighestKnownDegree({\slshape C})\index{HighestKnownDegree@\texttt{HighestKnownDegree}}
\label{HighestKnownDegree}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
The greatest integer $i$ such that the object at position $i$ is known (or computed). 



For a finite complex, this will be infinity. }

 

\subsection{\textcolor{Chapter }{LowestKnownDegree}}
\logpage{[ 8, 3, 13 ]}\nobreak
\hyperdef{L}{X868105FF86FA1B6E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LowestKnownDegree({\slshape C})\index{LowestKnownDegree@\texttt{LowestKnownDegree}}
\label{LowestKnownDegree}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
The smallest integer $i$ such that the object at position $i$ is known (or computed). 



For a finite complex, this will be negative infinity. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C;
  0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
  gap> IsFiniteComplex(C);
  true
  gap> UpperBound(C);
  4
  gap> LowerBound(C);
  0
  gap> LengthOfComplex(C);
  5
  gap> HighestKnownDegree(C);
  +inf
  gap> LowestKnownDegree(C);
  -inf 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsExactSequence}}
\logpage{[ 8, 3, 14 ]}\nobreak
\hyperdef{L}{X793465497B435197}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsExactSequence({\slshape C})\index{IsExactSequence@\texttt{IsExactSequence}}
\label{IsExactSequence}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape C}} is exact at every position. 



If the complex is not finite and not repeating, the function fails. }

 

\subsection{\textcolor{Chapter }{IsExactInDegree}}
\logpage{[ 8, 3, 15 ]}\nobreak
\hyperdef{L}{X7A6AE1C378E2EEE2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsExactInDegree({\slshape C, i})\index{IsExactInDegree@\texttt{IsExactInDegree}}
\label{IsExactInDegree}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape C}} is exact at position \mbox{\texttt{\slshape i}}. 



 }

 

\subsection{\textcolor{Chapter }{IsShortExactSequence}}
\logpage{[ 8, 3, 16 ]}\nobreak
\hyperdef{L}{X87ADD4F685457000}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsShortExactSequence({\slshape C})\index{IsShortExactSequence@\texttt{IsShortExactSequence}}
\label{IsShortExactSequence}
}\hfill{\scriptsize (property)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex.\\
 \textbf{\indent Returns:\ }
true if \mbox{\texttt{\slshape C}} is exact and of the form 
\[ \ldots \rightarrow 0 \rightarrow A \rightarrow B \rightarrow C \rightarrow 0
\rightarrow \ldots \]
 This could be positioned in any degree (as opposed to the construction of a
short exact sequence, where $B$ will be put in degree zero). 



 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C;                
  0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
  gap> IsExactSequence(C);
  false
  gap> IsExactInDegree(C,1);
  true
  gap> IsExactInDegree(C,2);
  false 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Transforming and combinig complexes}}\logpage{[ 8, 4, 0 ]}
\hyperdef{L}{X7CA0FC4E80154A0B}{}
{
  

\subsection{\textcolor{Chapter }{Shift}}
\logpage{[ 8, 4, 1 ]}\nobreak
\hyperdef{L}{X81F7B0AB84D6319B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Shift({\slshape C, i})\index{Shift@\texttt{Shift}}
\label{Shift}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
A new complex, which is a shift of \mbox{\texttt{\slshape C}}. 



If \mbox{\texttt{\slshape i}} {\textgreater} 0, the complex is shifted to the left. If \mbox{\texttt{\slshape i}} {\textless} 0, the complex is shifted to the right. Note that shifting might
change the differentials: In the shifted complex, $d_{new}$ is defined to be $(-1)^i d_{old}$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C;
  0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
  gap> Shift(C,1);
  0 -> 3:(0,1) -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> -1:(2,2) -> 0
  gap> D := Shift(C,-1);
  0 -> 5:(0,1) -> 4:(1,0) -> 3:(2,2) -> 2:(1,1) -> 1:(2,2) -> 0
  gap> dc := DifferentialOfComplex(C,3)!.maps;
  [ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
  gap> dd := DifferentialOfComplex(D,4)!.maps;
  [ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ]
  gap> MatricesOfPathAlgebraMatModuleHomomorphism(dc);
  [ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
  gap> MatricesOfPathAlgebraMatModuleHomomorphism(dd);
  [ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ] 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{YonedaProduct}}
\logpage{[ 8, 4, 2 ]}\nobreak
\hyperdef{L}{X7897A65085171913}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{YonedaProduct({\slshape C, D})\index{YonedaProduct@\texttt{YonedaProduct}}
\label{YonedaProduct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}}, \mbox{\texttt{\slshape D}} -- complexes.\\
 \textbf{\indent Returns:\ }
The Yoneda product of the two complexes, which is a complex. 



To compute the Yoneda product, \mbox{\texttt{\slshape C}} and \mbox{\texttt{\slshape D}} must be such that the object in degree \texttt{LowerBound(C)} equals the object in degree \texttt{UpperBound(D)}, that is 
\[ \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow A \rightarrow 0
\rightarrow \ldots \]
 
\[ \ldots \rightarrow 0 \rightarrow A \rightarrow D_{j} \rightarrow D_{j-1}
\rightarrow \ldots \]
 The product is of this form: 
\[ \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow D_{j} \rightarrow
D_{j-1} \rightarrow \ldots \]
 where the map $C_{i} \rightarrow D_{j}$ is the composition of the maps $C_{i} \rightarrow A$ and $A \rightarrow D_{j}$. Also, the object $D_{j}$ is in degree $j$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> C2;
  0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(0,0) -> 0
  gap> C3;
  0 -> -1:(1,1) -> -2:(2,2) -> -3:(1,1) -> 0
  gap> YonedaProduct(C2,C3);
  0 -> 1:(0,1) -> 0:(1,0) -> -1:(2,2) -> -2:(2,2) -> -3:(1,1) -> 0 
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{BrutalTruncationBelow}}
\logpage{[ 8, 4, 3 ]}\nobreak
\hyperdef{L}{X87E1CA507EB6B86E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BrutalTruncationBelow({\slshape C, i})\index{BrutalTruncationBelow@\texttt{BrutalTruncationBelow}}
\label{BrutalTruncationBelow}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
A newly created complex. 



Replace all objects with degree $j$ {\textless} $i$ with zero. The differentials affected will also become zero. }

 

\subsection{\textcolor{Chapter }{BrutalTruncationAbove}}
\logpage{[ 8, 4, 4 ]}\nobreak
\hyperdef{L}{X7CE9481684DD304E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BrutalTruncationAbove({\slshape C, i})\index{BrutalTruncationAbove@\texttt{BrutalTruncationAbove}}
\label{BrutalTruncationAbove}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i}} -- an integer.\\
 \textbf{\indent Returns:\ }
A newly created complex. 



Replace all objects with degree $j$ {\textgreater} $i$ with zero. The differentials affected will also become zero. }

 

\subsection{\textcolor{Chapter }{BrutalTruncation}}
\logpage{[ 8, 4, 5 ]}\nobreak
\hyperdef{L}{X8547C51781BBB48F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BrutalTruncation({\slshape C, i, j})\index{BrutalTruncation@\texttt{BrutalTruncation}}
\label{BrutalTruncation}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\slshape C}} -- a complex, \mbox{\texttt{\slshape i, j}} -- integers.\\
 \textbf{\indent Returns:\ }
A newly created complex. 



Brutally truncates in both ends. The integer arguments must be ordered such
that \mbox{\texttt{\slshape i}} {\textgreater} \mbox{\texttt{\slshape j}}. }

 }

 
\section{\textcolor{Chapter }{Chain maps}}\logpage{[ 8, 5, 0 ]}
\hyperdef{L}{X85F418EB859E7597}{}
{
  Work in progress. }

 }

 

\appendix


\chapter{\textcolor{Chapter }{An Appendix}}\label{Appendix}
\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X7B53252784137533}{}
{
  \label{ElevenBack} This is an appendix. }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
