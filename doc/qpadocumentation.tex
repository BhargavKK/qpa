% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}


\newcommand{\tensor}{\otimes}
\newcommand{\quiverproduct}{\times}
\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages


\newcommand{\GAP}{\textsf{GAP}}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{QPA\mbox{}}}\\[1cm]
\hypersetup{pdftitle=QPA}
\markright{\scriptsize \mbox{}\hfill QPA \hfill\mbox{}}
{\Large \textbf{Quivers and Path Algebras\mbox{}}}\\[1cm]
{Version version 1.4\mbox{}}\\[1cm]
{September 2010\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{The QPA-team\\
 \href{http://sourceforge.net/projects/quiverspathalg/} {\texttt{http://sourceforge.net/projects/quiverspathalg/}}\\
 (See also \href{http://www.math.ntnu.no/~oyvinso/QPA/} {\texttt{http://www.math.ntnu.no/\texttt{\symbol{126}}oyvinso/QPA/}}) \mbox{}}}\\
\hypersetup{pdfauthor=The QPA-team\\
 \href{http://sourceforge.net/projects/quiverspathalg/} {\texttt{http://sourceforge.net/projects/quiverspathalg/}}\\
 (See also \href{http://www.math.ntnu.no/~oyvinso/QPA/} {\texttt{http://www.math.ntnu.no/\texttt{\symbol{126}}oyvinso/QPA/}}) }
\mbox{}\\[2cm]
\begin{minipage}{12cm}\noindent
 We can add a comment here. \end{minipage}

\end{center}\vfill

\mbox{}\\

\noindent \textbf{Address: }\begin{minipage}[t]{8cm}\noindent
 Virginia Tech, Blacksburg, USA\\
 NTNU, Trondheim, Norway\\
 \end{minipage}
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
{\copyright} 2010-2020 The QPA-team. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
The system design of \textsf{QPA} was initiated by Edward L. Green, Lenwood S. Heath, and Craig A. Struble. It
was continued and completed by Randall Cone and Edward Green. We would like to
thank the following people for their contributions: \begin{center}
\begin{tabular}{ll}Gerard Brunick&
Quivers, path algebras\\
Randall Cone&
Code modernization and cleanup, GBNP interface (for Groebner bases),\\
 &
projective resolutions, user documentation\\
George Yuhasz&
User documentation, matrix representations of path algebras\\
\end{tabular}\\[2mm]
\end{center}

 \mbox{}}\\[1cm]
{\small 
\section*{Colophon}
\logpage{[ 0, 0, 4 ]}
This is the Colophon page. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 5 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Quick Start}}\label{Quickstart}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7EB860EC84DFC71E}{}
{
 This chapter is intended for those who would like to get started with \textsf{QPA} right away by playing with a few examples. A simple example is presented
first:  
\section{\textcolor{Chapter }{Example 1}}\label{Example 1}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8388E29680F31ABD}{}
{
 We construct a quiver $q$, i.e. a finite directed graph, with one vertex and two loops: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
  <quiver with 1 vertices and 2 arrows>
\end{Verbatim}
 We can request the list of vertices and the list of arrows for $q$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> VerticesOfQuiver(q);
  [ u ]
  gap> ArrowsOfQuiver(q);
  [ a, b ]
\end{Verbatim}
 Next we create the path algebra $pa$ from $q$ over the rational numbers: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> pa := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 3 generators>
\end{Verbatim}
 In this case it is interesting to note that we've created an algebra
isomorphic to the free algebra on two generators. We now retrieve and label
the generators and multiplicative identity for $pa$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gens := GeneratorsOfAlgebra(pa);
  [ (1)*u, (1)*a, (1)*b ]
  gap> u := gens[1];
  (1)*u
  gap> a := gens[2];
  (1)*a
  gap> b := gens[3];
  (1)*b
  gap> id := One(pa);
  (1)*u
\end{Verbatim}
 As we expect, in this case, the multiplicative identity for $pa$ and the single vertex $u$ are one in the same: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> u = id;
  true
\end{Verbatim}
 We now create a list of generators for an ideal and ask for its Groebner
basis: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> polys := [a*b*a-b,b*a*b-b];
  [ (-1)*b+(1)*a*b*a, (-1)*b+(1)*b*a*b ]
  gap> gb := GBNPGroebnerBasis(polys,pa);
  [ (-1)*a*b+(1)*b*a, (-1)*a*b+(1)*b^2, (-1)*b+(1)*a^2*b ]
\end{Verbatim}
 Next, we create an ideal $I$ in \texttt{\symbol{123}}\texttt{\symbol{92}}GAP\texttt{\symbol{125}} using the
Groebner basis $gb$ found above, and then the quotient $pa/I$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> I := Ideal(pa,gb);
  <two-sided ideal in <algebra-with-one over Rationals, with 3
  generators>, 
   (3 generators)>
\end{Verbatim}
 Once we have the generators for a Groebner basis, we set the appropriate
property for the ideal $I$: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> grb := GroebnerBasis(I,gb);    
  <partial two-sided Groebner basis containing 3 elements>
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 2}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X7A18778D836BC971}{}
{
 In this next example we create another path algebra that is essentially the
free algebra on six generators. We then find the Groebner basis for a
commutative example from (create bibliographic reference here) the book "Some
Tapas of Computer Algebra" by A.M. Cohen, H. Cuypers, H. Sterk. We create the
underlying quiver, and from it the path algebra over the rational numbers: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
  >                    ["u","u","d"],["u","u","e"],["u","u","f"]]);
  <quiver with 1 vertices and 6 arrows>
  gap> fq := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 7 generators>
\end{Verbatim}
 Next, the generators are labeled and the list of polynomials is entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gens := GeneratorsOfAlgebra(fq);
  [ (1)*u, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e, (1)*f ]
  gap> u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
  gap> d := gens[5];; e := gens[6];; f := gens[7];;
  gap> polys := [ e*a,
  >            a^3 + f*a,
  >            a^9 + c*a^3,
  >            a^81 + c*a^9 + d*a^3,
  >            a^27 + d*a^81 + e*a^9 + f*a^3,
  >            b + c*a^27 + e*a^81 + f*a^9,
  >            c*b + d*a^27 + f*a^81,
  >            a + d*b + e*a^27,
  >            c*a + e*b + f*a^27,
  >            d*a + f*b,
  >            b^3 - b,
  >            a*b - b*a, a*c - c*a,
  >            a*d - d*a, a*e - e*a,
  >            a*f - f*a, b*c - c*b,
  >            b*d - d*b, b*e - e*b,
  >            b*f - f*b, c*d - d*c,
  >            c*e - e*c, c*f - f*c,
  >            d*e - e*d, d*f - f*d,
  >            e*f - f*e
  > ];;
\end{Verbatim}
 Finally, the Groebner basis is found: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gb := GBNPGroebnerBasis(polys,fq);
  [ (1)*a, (1)*b, (-1)*c*d+(1)*d*c, (-1)*c*e+(1)*e*c, (-1)*d*e+(1)*e*d,
    (-1)*c*f+(1)*f*c, (-1)*d*f+(1)*f*d, (-1)*e*f+(1)*f*e ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 3}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7D680484821C7835}{}
{
 The next example is from B. Keller's PhD thesis, p. 26: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
  <quiver with 2 vertices and 3 arrows>
  gap> pa := PathAlgebra(Rationals,q);
  <algebra-with-one over Rationals, with 5 generators>
  gap> 
  gap> # Get generators of path algebra:
  gap> gens := GeneratorsOfAlgebra(pa);
  [ (1)*u, (1)*v, (1)*c, (1)*b, (1)*a ]
  gap> u := gens[1];; v := gens[2];; c := gens[3];;
  gap> b := gens[4];; a := gens[5];; id := One(pa);;
  gap> 
  gap> polys := [a*b*c+b*a*b+a+c];
  [ (1)*c+(1)*a+(1)*b*a*b+(1)*a*b*c ]
  gap> gb := GBNPGroebnerBasis(polys,pa);
  [ (-1)*b*c+(1)*a*c, (1)*a+(1)*b*a*b, (1)*c+(1)*a*b*c, (-1)*b*a^2+(1)*a^2*b ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Example 4}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X848E4DDE845A6EE9}{}
{
 Here's an example that doesn't meet our necessary criteria that all elements
in a generating set have monomials in the arrow ideal. Since the given path
algebra is isomorphic to a free algebra, the single vertex is sent to the
identity and there are no complications. First, we set up the algebra and
generating set: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
  <quiver with 1 vertices and 2 arrows>
  gap> f := Rationals;
  Rationals
  gap> fq := PathAlgebra(f,q);
  <algebra-with-one over Rationals, with 3 generators>
  gap> 
  gap> # Get generators of path algebra:
  gap> gens := GeneratorsOfAlgebra(fq);
  [ (1)*u, (1)*x, (1)*y ]
  gap> u := gens[1];; x := gens[2];; y := gens[3];; id := One(fq);;
  gap> polys := [x*y-y*x,x^2*y-id,x*y^2-id];
  [ (1)*x*y+(-1)*y*x, (-1)*u+(1)*x^2*y, (-1)*u+(1)*x*y^2 ]
\end{Verbatim}
 Then we ask GBNP for its Groebner basis: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> gb := GBNPGroebnerBasisNC(polys,fq);
  The given path algebra is isomorphic to a free algebra.
  [ (-1)*x+(1)*y, (-1)*u+(1)*x^3 ]
\end{Verbatim}
 NOTE: It is important to realize that we've used the routine
`GBNPGroebnerBasisNC' which doesn't check that all elements in a given list
have non-vertex monomials. So, if we run the standard \textsf{QPA} Groebner basis routine on this example, we get the following: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> GBNPGroebnerBasis(polys,pa);
  Please make sure all elements are in the given path algebra, 
  and each summand of each element is not (only) a vertex.
  false
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Quivers}}\label{Quivers}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7FA7E6B581D41A94}{}
{
 
\section{\textcolor{Chapter }{Information class, Quivers}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7C14F4617F7E9F09}{}
{
 A quiver $Q$ is a set derived from a labeled directed multigraph with loops $\Gamma$. An element of $Q$ is called a *path*, and falls into one of three classes. The first class is
the set of *vertices* of $\Gamma$. The second class is the set of *walks* in $\Gamma$ of length at least one, each of which is represented by the corresponding
sequence of *arrows* in $\Gamma$. The third class is the singleton set containing the distinguished *zero
path*, usually denoted $0$. An associative multiplication is defined on $Q$.

 This chapter describes the functions in \textsf{QPA} that deal with paths and quivers. The functions for constructing paths in
Section \ref{Constructing Paths} are normally not useful in isolation; typically, they are invoked by the
functions for constructing quivers in Section \ref{Constructing Quivers}. 

\subsection{\textcolor{Chapter }{InfoQuiver}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X786A65F07FA1BB78}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoQuiver\index{InfoQuiver@\texttt{InfoQuiver}}
\label{InfoQuiver}
}\hfill{\scriptsize (info class)}}\\


 is the info class for functions dealing with quivers. }

  }

 
\section{\textcolor{Chapter }{Constructing Quivers}}\label{Constructing Quivers}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X860B15D57EAB46D7}{}
{
 

\subsection{\textcolor{Chapter }{Quiver}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X871563F685BE93A2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape N[, arrow1, arrow2, ...]})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape [vertex1, vertex2, ..., ][arrow1, arrow2, ...]})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Quiver({\slshape adjacencymatrix})\index{Quiver@\texttt{Quiver}}
\label{Quiver}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a quiver, which satisfies the property \texttt{IsQuiver} (\ref{IsQuiver}).



 The first construction takes the number \mbox{\texttt{\slshape N}} of vertices and a list of arrows to specify the graph $\Gamma$ and hence the quiver. The second construction takes a list of vertex names and
a list of arrows for the same purpose. The third construction takes an
adjacency matrix for the graph $\Gamma$.

 In the first and third constructions, the vertices are named `v1, v2, ...'. In
the second construction, unique vertex names are given as strings in the list
that is the first parameter. Each arrow is a list consisting of a source
vertex and a target vertex, followed optionally by an arrow name as a string.

 Vertices and arrows are referenced as record components using the dot (`.')
operator. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> VerticesOfQuiver(q1);
  [ u, v ]
  gap> ArrowsOfQuiver(q1);
  [ a, b, c, d ]
  gap> q2 := Quiver(2,[[1,1],[2,1],[1,2]]);
  <quiver with 2 vertices and 3 arrows>
  gap> ArrowsOfQuiver(q2);
  [ a1, a2, a3 ]
  gap> VerticesOfQuiver(q2);
  [ v1, v2 ]
  gap> q3 := Quiver(2,[[1,1,"a"],[2,1,"b"],[1,2,"c"]]);
  <quiver with 2 vertices and 3 arrows>
  gap> ArrowsOfQuiver(q3);
  [ a, b, c ]
  gap> q4 := Quiver([[1,1],[2,1]]);
  <quiver with 2 vertices and 5 arrows>
  gap> VerticesOfQuiver(q4);
  [ v1, v2 ]
  gap> ArrowsOfQuiver(q4);
  [ a1, a2, a3, a4, a5 ]
  gap> SourceOfPath(q4.a2);
  v1
  gap> TargetOfPath(q4.a2);
  v2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{OrderedBy}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X83E498008233E2DD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderedBy({\slshape quiver, ordering})\index{OrderedBy@\texttt{OrderedBy}}
\label{OrderedBy}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a copy of \mbox{\texttt{\slshape quiver}} whose elements are ordered by \mbox{\texttt{\slshape ordering}}. The default ordering of a quiver is length left lexicographic. See Section \ref{qpa:Orderings} for more information.



 }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Quivers}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X80BB6B6183134D88}{}
{
 

\subsection{\textcolor{Chapter }{IsQuiver}}
\logpage{[ 2, 3, 1 ]}\nobreak
\hyperdef{L}{X7E9C03497FD7778B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsQuiver({\slshape object})\index{IsQuiver@\texttt{IsQuiver}}
\label{IsQuiver}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a quiver. }

 

\subsection{\textcolor{Chapter }{IsAcyclic}}
\logpage{[ 2, 3, 2 ]}\nobreak
\hyperdef{L}{X847A62A6806046C4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsAcyclic({\slshape object})\index{IsAcyclic@\texttt{IsAcyclic}}
\label{IsAcyclic}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a quiver with no cycles. }

 

\subsection{\textcolor{Chapter }{IsFinite}}
\logpage{[ 2, 3, 3 ]}\nobreak
\hyperdef{L}{X808A4061809A6E67}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsFinite({\slshape object})\index{IsFinite@\texttt{IsFinite}}
\label{IsFinite}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a finite set. Synonymous with `IsAcyclic'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> quiver1 := Quiver(2,[[1,2]]);
  <quiver with 2 vertices and 1 arrows>
  gap> IsQuiver("v1");
  false
  gap> IsQuiver(quiver1);
  true
  gap> IsAcyclic(quiver1);
  true
  gap> quiver2 := Quiver(["u","v"],[["u","v"],["v","u"]]);
  <quiver with 2 vertices and 2 arrows>
  gap> IsAcyclic(quiver2);
  false
  gap> IsFinite(quiver1);
  true
  gap> IsFinite(quiver2);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Orderings of paths in a quiver}}\label{qpa:Orderings}
\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X78BBB63B828EB9FB}{}
{
 To be written. }

 
\section{\textcolor{Chapter }{Attributes and Operations for Quivers}}\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X80CF69E37B54F3C1}{}
{
 

\subsection{\textcolor{Chapter }{.}}
\logpage{[ 2, 5, 1 ]}\nobreak
\hyperdef{L}{X7821AC097821AC09}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{.({\slshape Q, element})\index{.@\texttt{.}}
\label{.}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{.} operates on \mbox{\texttt{\slshape Q}}, a quiver, and an element, a vertex or an arrow, to allow access to
generators of the quiver. If you have named your vertices and arrows the the
access looks like `\mbox{\texttt{\slshape Q}}.\mbox{\texttt{\slshape name of element}}'. If you have not named the elements of the quiver then the default names are
v1, v2, ... and a1, a2, ... in the order they are created. }

 

\subsection{\textcolor{Chapter }{VerticesOfQuiver}}
\logpage{[ 2, 5, 2 ]}\nobreak
\hyperdef{L}{X7C82A4BC7FB329D8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VerticesOfQuiver({\slshape object})\index{VerticesOfQuiver@\texttt{VerticesOfQuiver}}
\label{VerticesOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of paths that are vertices in \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{ArrowsOfQuiver}}
\logpage{[ 2, 5, 3 ]}\nobreak
\hyperdef{L}{X82C42D7D820D5F9B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ArrowsOfQuiver({\slshape object})\index{ArrowsOfQuiver@\texttt{ArrowsOfQuiver}}
\label{ArrowsOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of paths that are arrows in \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{AdjacencyMatrixOfQuiver}}
\logpage{[ 2, 5, 4 ]}\nobreak
\hyperdef{L}{X7AF572F081AEFE98}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AdjacencyMatrixOfQuiver({\slshape object})\index{AdjacencyMatrixOfQuiver@\texttt{AdjacencyMatrixOfQuiver}}
\label{AdjacencyMatrixOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the adjacency matrix of \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{GeneratorsOfQuiver}}
\logpage{[ 2, 5, 5 ]}\nobreak
\hyperdef{L}{X7B4A7F0F813E63FC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorsOfQuiver({\slshape object})\index{GeneratorsOfQuiver@\texttt{GeneratorsOfQuiver}}
\label{GeneratorsOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of the vertices and the arrows in \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{OrderOfQuiver}}
\logpage{[ 2, 5, 6 ]}\nobreak
\hyperdef{L}{X7C00FB118125F3F8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderOfQuiver({\slshape object})\index{OrderOfQuiver@\texttt{OrderOfQuiver}}
\label{OrderOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the number of vertices in \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{SizeOfQuiver}}
\logpage{[ 2, 5, 7 ]}\nobreak
\hyperdef{L}{X87E83DB57F0CB1D8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SizeOfQuiver({\slshape object})\index{SizeOfQuiver@\texttt{SizeOfQuiver}}
\label{SizeOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the number of arrows in \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{OrderingOfQuiver}}
\logpage{[ 2, 5, 8 ]}\nobreak
\hyperdef{L}{X84D1D1AA82689B03}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderingOfQuiver({\slshape object})\index{OrderingOfQuiver@\texttt{OrderingOfQuiver}}
\label{OrderingOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the ordering used to order elements in \mbox{\texttt{\slshape object}}. See Section \ref{qpa:Orderings} for more information. }

 

\subsection{\textcolor{Chapter }{OppositeOfQuiver}}
\logpage{[ 2, 5, 9 ]}\nobreak
\hyperdef{L}{X825050BA7DCC6D43}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OppositeOfQuiver({\slshape Q})\index{OppositeOfQuiver@\texttt{OppositeOfQuiver}}
\label{OppositeOfQuiver}
}\hfill{\scriptsize (operation)}}\\


 This takes the quiver \mbox{\texttt{\slshape Q}} and produces the opposite quiver, where the vertices are labelled "name in
original quiver" + "{\textunderscore}op" and the arrows are labelled "name in
orginal quiver" + "{\textunderscore}op". }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> q1.a;
  a
  gap> q1.v;
  v
  gap> VerticesOfQuiver(q1);
  [ u, v ]
  gap> ArrowsOfQuiver(q1);
  [ a, b, c, d ]
  gap> AdjacencyMatrixOfQuiver(q1);
  [ [ 1, 1 ], [ 1, 1 ] ]
  gap> GeneratorsOfQuiver(q1);
  [ u, v, a, b, c, d ]
  gap> OrderOfQuiver(q1);
  2
  gap> SizeOfQuiver(q1);
  4
  gap> OrderingOfQuiver(q1);
  <length left lexicographic ordering>
  gap> q1_op := OppositeOfQuiver(q1);
  <quiver with 2 vertices and 4 arrows>
  gap> VerticesOfQuiver(q1);
  [ u_op, v_op ]
  gap> ArrowsOfQuiver(q1);
  [ a_op, b_op, c_op, d_op ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Categories and Properties of Paths}}\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X862A804B80C5A47D}{}
{
 

\subsection{\textcolor{Chapter }{IsPath}}
\logpage{[ 2, 6, 1 ]}\nobreak
\hyperdef{L}{X78B503DB83F2B6DE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPath({\slshape object})\index{IsPath@\texttt{IsPath}}
\label{IsPath}
}\hfill{\scriptsize (category)}}\\


 All path objects are in this category. }

 

\subsection{\textcolor{Chapter }{IsVertex}}
\logpage{[ 2, 6, 2 ]}\nobreak
\hyperdef{L}{X7F06C7E48631922F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsVertex({\slshape object})\index{IsVertex@\texttt{IsVertex}}
\label{IsVertex}
}\hfill{\scriptsize (category)}}\\


 All vertices are in this category. }

 

\subsection{\textcolor{Chapter }{IsArrow}}
\logpage{[ 2, 6, 3 ]}\nobreak
\hyperdef{L}{X8266C9B8840C12EB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsArrow({\slshape object})\index{IsArrow@\texttt{IsArrow}}
\label{IsArrow}
}\hfill{\scriptsize (category)}}\\


 All arrows are in this category. }

 

\subsection{\textcolor{Chapter }{IsZeroPath}}
\logpage{[ 2, 6, 4 ]}\nobreak
\hyperdef{L}{X8624A0B0795149CF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsZeroPath({\slshape object})\index{IsZeroPath@\texttt{IsZeroPath}}
\label{IsZeroPath}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is the zero path. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> IsPath(q1.b);
  true
  gap> IsPath(q1.u);
  true
  gap> IsVertex(q1.c);
  false
  gap> IsZeroPath(q1.d);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations of Paths}}\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X7C8294338676C80E}{}
{
 

\subsection{\textcolor{Chapter }{SourceOfPath}}
\logpage{[ 2, 7, 1 ]}\nobreak
\hyperdef{L}{X84D8493C7AAF4ACC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SourceOfPath({\slshape object})\index{SourceOfPath@\texttt{SourceOfPath}}
\label{SourceOfPath}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the source (first) vertex of \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{TargetOfPath}}
\logpage{[ 2, 7, 2 ]}\nobreak
\hyperdef{L}{X86827D3F78F51815}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TargetOfPath({\slshape object})\index{TargetOfPath@\texttt{TargetOfPath}}
\label{TargetOfPath}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the target (last) vertex of \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{LengthOfPath}}
\logpage{[ 2, 7, 3 ]}\nobreak
\hyperdef{L}{X7FF179D17C4F9FAC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LengthOfPath({\slshape object})\index{LengthOfPath@\texttt{LengthOfPath}}
\label{LengthOfPath}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the length of \mbox{\texttt{\slshape object}}. }

 

\subsection{\textcolor{Chapter }{WalkOfPath}}
\logpage{[ 2, 7, 4 ]}\nobreak
\hyperdef{L}{X781A8E06850E47B4}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{WalkOfPath({\slshape object})\index{WalkOfPath@\texttt{WalkOfPath}}
\label{WalkOfPath}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of the arrows that constitue \mbox{\texttt{\slshape object}} in order. }

 

\subsection{\textcolor{Chapter }{*}}
\logpage{[ 2, 7, 5 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{*({\slshape p, q})\index{*@\texttt{*}}
\label{*}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{*} operates on \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}}, which are two paths in the same quiver. It returns the multiplication of the
paths. If the paths are not in the same quiver an error is returned. If the
target of \mbox{\texttt{\slshape p}} differs from the source of \mbox{\texttt{\slshape q}}, then the result is the zero path. Otherwise, if either path is a vertex,
then the result is the other path. Finally, if both are paths of length at
least 1, then the result is the concatenation of the walks of the two paths. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> SourceOfPath(q1.v);                                                       
  v
  gap> p1:=q1.a*q1.b*q1.d*q1.d;
  a*b*d^2
  gap> TargetOfPath(p1);
  v
  gap> p2:=q1.b*q1.b;
  0
  gap> WalkOfPath(p1);
  [ a, b, d, d ]
  gap> WalkOfPath(q1.a);
  [ a ]
  gap> LengthOfPath(p1);
  4
  gap> LengthOfPath(q1.v);
  0
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{=}}
\logpage{[ 2, 7, 6 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{=({\slshape p, q})\index{=@\texttt{=}}
\label{=}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{=} operates on two paths \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}}, and compares the paths for equality. Two paths are equal if they have the
same source and the same target and if they have the same walks. The paths \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}} must be in the same quiver. }

 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 2, 7, 7 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape p, q})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{{\textless}} operates on two paths \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}}, and compares them with respect to the ordering of the quiver. This is
meaningful only if \mbox{\texttt{\slshape p}} and \mbox{\texttt{\slshape q}} are in the same quiver. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1.a=q1.b;
  false
  gap> q1.a < q1.v;
  false
  gap> q1.a < q1.c;
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes of Vertices}}\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X8158F0D27C4628FB}{}
{
 

\subsection{\textcolor{Chapter }{IncomingArrowsOfVertex}}
\logpage{[ 2, 8, 1 ]}\nobreak
\hyperdef{L}{X85E53C177F80E77E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IncomingArrowsOfVertex({\slshape object})\index{IncomingArrowsOfVertex@\texttt{IncomingArrowsOfVertex}}
\label{IncomingArrowsOfVertex}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of arrows having \mbox{\texttt{\slshape object}} as target. Only meaningful if \mbox{\texttt{\slshape object}} is in a quiver. }

 

\subsection{\textcolor{Chapter }{OutgoingArrowsOfVertex}}
\logpage{[ 2, 8, 2 ]}\nobreak
\hyperdef{L}{X8345D79381E46D73}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OutgoingArrowsOfVertex({\slshape object})\index{OutgoingArrowsOfVertex@\texttt{OutgoingArrowsOfVertex}}
\label{OutgoingArrowsOfVertex}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of arrows having \mbox{\texttt{\slshape object}} as source. }

 

\subsection{\textcolor{Chapter }{InDegreeOfVertex}}
\logpage{[ 2, 8, 3 ]}\nobreak
\hyperdef{L}{X7C9CD0527CB9E6EF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InDegreeOfVertex({\slshape object})\index{InDegreeOfVertex@\texttt{InDegreeOfVertex}}
\label{InDegreeOfVertex}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the number of arrows having \mbox{\texttt{\slshape object}} as target. Only meaningful if \mbox{\texttt{\slshape object}} is in a quiver. }

 

\subsection{\textcolor{Chapter }{OutDegreeOfVertex}}
\logpage{[ 2, 8, 4 ]}\nobreak
\hyperdef{L}{X7A09EB648070276D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OutDegreeOfVertex({\slshape object})\index{OutDegreeOfVertex@\texttt{OutDegreeOfVertex}}
\label{OutDegreeOfVertex}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the number of arrows having \mbox{\texttt{\slshape object}} as source. }

 

\subsection{\textcolor{Chapter }{NeighborsOfVertex}}
\logpage{[ 2, 8, 5 ]}\nobreak
\hyperdef{L}{X7A557B4C83B7C601}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NeighborsOfVertex({\slshape object})\index{NeighborsOfVertex@\texttt{NeighborsOfVertex}}
\label{NeighborsOfVertex}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns a list of neighbors of \mbox{\texttt{\slshape object}}, that is, vertices that are targets of arrows having \mbox{\texttt{\slshape object}} as source. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> OutgoingArrowsOfVertex(q1.u);
  [ a, b ]
  gap> InDegreeOfVertex(q1.u);
  2
  gap> NeighborsOfVertex(q1.v);
  [ u, v ]
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Path Algebras}}\label{PathAlgebras}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7E8A43A484CE0BA8}{}
{
 
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 A path algebra is an algebra constructed from a field $F$ and a quiver $Q$. The path algebra $FQ$ contains all finite linear combinations of elements of $Q$. This chapter describes the functions in \textsf{QPA} that deal with path algebras and quotients of path algebras. Path algebras are
algebras so see Chapter "ref:algebras" for functionality such as generators,
basis functions, and mappings. 

\subsection{\textcolor{Chapter }{InfoPathAlgebra}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7C19179882715B18}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoPathAlgebra\index{InfoPathAlgebra@\texttt{InfoPathAlgebra}}
\label{InfoPathAlgebra}
}\hfill{\scriptsize (info class)}}\\


 is the info class for functions dealing with path algebras. }

 }

 
\section{\textcolor{Chapter }{Constructing Path Algebras}}\label{Constructing Paths}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X848A225A84A15B1E}{}
{
 

\subsection{\textcolor{Chapter }{PathAlgebra}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7CA1C87B8202C2E9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PathAlgebra({\slshape F, Q})\index{PathAlgebra@\texttt{PathAlgebra}}
\label{PathAlgebra}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
the path algebra $FG$ of \mbox{\texttt{\slshape Q}} over the field \mbox{\texttt{\slshape F}}.



 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
  > ["v","u","c"],["v","v","d"]]);
  <quiver with 2 vertices and 4 arrows>
  gap> f := FiniteField(23);
  GF(23)
  gap> fq := PathAlgebra(f,q);
  <algebra-with-one over GF(23), with 6 generators>
\end{Verbatim}
 \texttt{\symbol{92}}* NO: the FOLLOWING is not true: 

\subsection{\textcolor{Chapter }{OrderedBy}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X83E498008233E2DD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OrderedBy({\slshape path, algebra, ordering})\index{OrderedBy@\texttt{OrderedBy}}
\label{OrderedBy}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 a copy of \mbox{\texttt{\slshape path algebra}} whose elements are ordered by \mbox{\texttt{\slshape ordering}}. See Section \ref{qpa:Orderings} for more information on orderings.



 }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Path Algebras}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X85A3A8767E7C11AD}{}
{
 

\subsection{\textcolor{Chapter }{IsPathAlgebra}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X8255FDF78315E1B3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebra({\slshape object})\index{IsPathAlgebra@\texttt{IsPathAlgebra}}
\label{IsPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a path algebra. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsPathAlgebra(fq);
  true
  gap> IsPathAlgebra(q);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Path Algebras}}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7DE2F2A48492041A}{}
{
 

\subsection{\textcolor{Chapter }{QuiverOfPathAlgebra}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X83FBA499856580B0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverOfPathAlgebra({\slshape object})\index{QuiverOfPathAlgebra@\texttt{QuiverOfPathAlgebra}}
\label{QuiverOfPathAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Returns the quiver from which \mbox{\texttt{\slshape object}} was constructed. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> QuiverOfPathAlgebra(fq);
  <quiver with 2 vertices and 4 arrows>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{.}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X7821AC097821AC09}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{.({\slshape FQ, element})\index{.@\texttt{.}}
\label{.}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{.} operates on a path algebra \mbox{\texttt{\slshape FQ}} and an element \mbox{\texttt{\slshape element}}, which is a vertex or an arrow in the quiver Q. It returns the generator as
an element of the path algebra. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> fq.v;
  (Z(23)^0)*v
  gap> fq.b;
  (Z(23)^0)*b
\end{Verbatim}
 {\textgreater}OrderingOfAlgebra( \mbox{\texttt{\slshape path algebra}} ) returns the ordering of the quiver of the path algebra. }

 
\section{\textcolor{Chapter }{Operations on Path Algebra Elements}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X7CEF60107CE4616B}{}
{
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape a, b})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{{\textless}} operates on elements \mbox{\texttt{\slshape a}} and \mbox{\texttt{\slshape b}} of a path algebra $FQ$, and they are compared using the ordering for the path algebra. See Section \ref{qpa:Orderings} for more information on orderings. }

 

\subsection{\textcolor{Chapter }{LeadingTerm}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X84C98E687A3A84D8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingTerm({\slshape element})\index{LeadingTerm@\texttt{LeadingTerm}}
\label{LeadingTerm}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Tip({\slshape element})\index{Tip@\texttt{Tip}}
\label{Tip}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{LeadingTerm} or equivalently \texttt{Tip} operates on an \mbox{\texttt{\slshape x}} in a path algebra, and it returns is the term in \mbox{\texttt{\slshape element}} whose monomial is largest among those monomials that have nonzero
coefficients; this term is known as the *tip* of \mbox{\texttt{\slshape element}}. }

 

\subsection{\textcolor{Chapter }{LeadingCoefficient}}
\logpage{[ 3, 5, 3 ]}\nobreak
\hyperdef{L}{X80710E9B7D8340BD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingCoefficient({\slshape element})\index{LeadingCoefficient@\texttt{LeadingCoefficient}}
\label{LeadingCoefficient}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipCoefficient({\slshape element})\index{TipCoefficient@\texttt{TipCoefficient}}
\label{TipCoefficient}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{LeadingCoefficient} or equivalently \texttt{TipCoefficient} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it returns the coefficient of the tip of \mbox{\texttt{\slshape element}}. This is an element of the field. }

 

\subsection{\textcolor{Chapter }{LeadingMonomial}}
\logpage{[ 3, 5, 4 ]}\nobreak
\hyperdef{L}{X7B3EAE41795598A5}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LeadingMonomial({\slshape element})\index{LeadingMonomial@\texttt{LeadingMonomial}}
\label{LeadingMonomial}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipMonomial({\slshape element})\index{TipMonomial@\texttt{TipMonomial}}
\label{TipMonomial}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{LeadingMonomial} or equivalently \texttt{TipMonomial} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it returns the monomial of the tip of \mbox{\texttt{\slshape element}}; it is the largest monomial occurring in \mbox{\texttt{\slshape element}} with a nonzero coefficient. This is an element of the underlying quiver, not
of the path algebra. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> elem := fq.a*fq.b*fq.c + fq.b*fq.d*fq.c+fq.d*fq.d;
  (Z(23)^0)*d^2+(Z(23)^0)*a*b*c+(Z(23)^0)*b*d*c
  gap> LeadingTerm(elem);
  (Z(23)^0)*b*d*c
  gap> LeadingCoefficient(elem);
  Z(23)^0
  gap> LeadingMonomial(elem);
  b*d*c
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsLeftUniform}}
\logpage{[ 3, 5, 5 ]}\nobreak
\hyperdef{L}{X853C8B0B8665BFBB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsLeftUniform({\slshape element})\index{IsLeftUniform@\texttt{IsLeftUniform}}
\label{IsLeftUniform}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{IsLeftUniform} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it returns true if each monomial in \mbox{\texttt{\slshape element}} has the same source vertex. }

 

\subsection{\textcolor{Chapter }{IsRightUniform}}
\logpage{[ 3, 5, 6 ]}\nobreak
\hyperdef{L}{X7C06BE7483992634}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsRightUniform({\slshape element})\index{IsRightUniform@\texttt{IsRightUniform}}
\label{IsRightUniform}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{IsRightUniform} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it returns true if each monomial in \mbox{\texttt{\slshape element}} has the same target vertex. }

 

\subsection{\textcolor{Chapter }{IsUniform}}
\logpage{[ 3, 5, 7 ]}\nobreak
\hyperdef{L}{X8735FBE180797557}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsUniform({\slshape element})\index{IsUniform@\texttt{IsUniform}}
\label{IsUniform}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{IsUniform} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it returns true if each monomial in \mbox{\texttt{\slshape element}} has both the same source vertex and the same target vertex. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsLeftUniform(elem);
  false
  gap> IsRightUniform(elem);
  false
  gap> IsUniform(elem);
  false
  gap> another := fq.a*fq.b + fq.b*fq.d*fq.c*fq.b*fq.d;
  (Z(23)^0)*a*b+(Z(23)^0)*b*d*c*b*d
  gap> IsLeftUniform(another);
  true
  gap> IsRightUniform(another);
  true
  gap> IsUniform(another);
  true
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{MappedExpression}}
\logpage{[ 3, 5, 8 ]}\nobreak
\hyperdef{L}{X796249A682818750}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MappedExpression({\slshape expr, gens1, gens2})\index{MappedExpression@\texttt{MappedExpression}}
\label{MappedExpression}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{MappedExpression} operates on \mbox{\texttt{\slshape expr}} from a path algebra and and two equal-length lists of generators \mbox{\texttt{\slshape gens1}} and \mbox{\texttt{\slshape gens2}} for subalgebras. The \mbox{\texttt{\slshape expr}} must be in the subalgebra generated by \mbox{\texttt{\slshape gens1}}. The lists define a mapping of each generator in \mbox{\texttt{\slshape gens1}} to the corresponding generator in \mbox{\texttt{\slshape gens2}}. The value returned is the evaluation of the mapping at \mbox{\texttt{\slshape expr}}. }

 }

 
\section{\textcolor{Chapter }{Constructing Quotients of Path Algebras}}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7F0D555379C97A6E}{}
{
 See Chapter "ref:algebras" on how to construct an ideal and a quotient of an
algebra. When the quotient is constructed, it is still a path algebra and thus
the same commands may be used with quotients. Also since a quotient is still
an algebra, refer to "ref:algebras". 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);
  <two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,
    (2 generators)>
  gap> GeneratorsOfIdeal(I);
  [ (Z(23)^0)*a*b, (Z(23)^11)*b*c+(Z(23)^0)*d^2 ]
  gap> quot := fq/I;
  <algebra-with-one over GF(23), with 6 generators>
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes of Ideals}}\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X85D4E72B787B1C49}{}
{
 Groebner Basis Of an Ideal: For many of the functions related to quotients,
you will need to compute a Groebner basis of the ideal. Refer to the chapters
"qpa:groebner basis" and "qpa:using opal with gap" to learn more. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> J := Ideal(fq,[fq.a*fq.b]);
  <two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,
    (1 generators)>
  gap> anotherquot := fq/J;
  <algebra-with-one over GF(23), with 6 generators>
  gap> gb := GroebnerBasis(J,[fq.a*fq.b]);
  <complete two-sided Groebner basis containing 1 elements>
  gap> SetIsCompleteGroebnerBasis(gb, true);
  gap> IsCompleteGroebnerBasis(gb);
  true
  gap> gb = GroebnerBasisOfIdeal(J);
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Categories and Properties of Quotients of Path Algebras}}\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X7A3CA333873389AD}{}
{
 

\subsection{\textcolor{Chapter }{IsSubalgebraFpPathAlgebra}}
\logpage{[ 3, 8, 1 ]}\nobreak
\hyperdef{L}{X78476A128036573F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSubalgebraFpPathAlgebra({\slshape object})\index{IsSubalgebraFpPathAlgebra@\texttt{IsSubalgebraFpPathAlgebra}}
\label{IsSubalgebraFpPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a quotient of a path algebra. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsSubalgebraFpPathAlgebra(quot);
  true
  gap> IsSubalgebraFpPathAlgebra(fq);
  false
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Quotients of Path Algebras}}\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X86647D317A961513}{}
{
 

\subsection{\textcolor{Chapter }{NormalFormFunction}}
\logpage{[ 3, 9, 1 ]}\nobreak
\hyperdef{L}{X826641507CFBE943}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NormalFormFunction({\slshape object})\index{NormalFormFunction@\texttt{NormalFormFunction}}
\label{NormalFormFunction}
}\hfill{\scriptsize (attribute)}}\\


 is a function that can compute normal forms for elements of \mbox{\texttt{\slshape object}}. It may be supplied by the user. }

 

\subsection{\textcolor{Chapter }{IsElementOfFpPathAlgebra}}
\logpage{[ 3, 9, 2 ]}\nobreak
\hyperdef{L}{X815D8565802928FE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsElementOfFpPathAlgebra({\slshape object})\index{IsElementOfFpPathAlgebra@\texttt{IsElementOfFpPathAlgebra}}
\label{IsElementOfFpPathAlgebra}
}\hfill{\scriptsize (property)}}\\


 is true if \mbox{\texttt{\slshape object}} is an element of some quotient of a path algebra. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> this := anotherquot.a*anotherquot.b;
  [(Z(23)^0)*a*b]
  gap> IsElementOfFpPathAlgebra(this);
  true
  gap> IsElementOfFpPathAlgebra(fq);
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Coefficients}}
\logpage{[ 3, 9, 3 ]}\nobreak
\hyperdef{L}{X80B32F667BF6AFD8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Coefficients({\slshape element})\index{Coefficients@\texttt{Coefficients}}
\label{Coefficients}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{Coefficients} operates on an \mbox{\texttt{\slshape element}} of a quotient of a path algebra, and it returns the coefficients of the \mbox{\texttt{\slshape element}} in terms of its canonical basis. Question: Does this only take one argument? }

 

\subsection{\textcolor{Chapter }{IsSelfinjective}}
\logpage{[ 3, 9, 4 ]}\nobreak
\hyperdef{L}{X7D96F5437F867D00}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsSelfinjective({\slshape A})\index{IsSelfinjective@\texttt{IsSelfinjective}}
\label{IsSelfinjective}
}\hfill{\scriptsize (operation)}}\\


 The function checks if the algebra \mbox{\texttt{\slshape A}} is finite dimensional (not implemented yet), and returns true or false
accorgin to whether \mbox{\texttt{\slshape A}} is selfinjective or not. }

 

\subsection{\textcolor{Chapter }{LoewyLength}}
\logpage{[ 3, 9, 5 ]}\nobreak
\hyperdef{L}{X7BEA44FB819910B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LoewyLength({\slshape A})\index{LoewyLength@\texttt{LoewyLength}}
\label{LoewyLength}
}\hfill{\scriptsize (operation)}}\\


 The function returns the Loewy length of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. }

 

\subsection{\textcolor{Chapter }{CartanMatrix}}
\logpage{[ 3, 9, 6 ]}\nobreak
\hyperdef{L}{X84E3FEF587CB66C3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CartanMatrix({\slshape A})\index{CartanMatrix@\texttt{CartanMatrix}}
\label{CartanMatrix}
}\hfill{\scriptsize (operation)}}\\


 This function returns the Cartan matrix of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. }

 

\subsection{\textcolor{Chapter }{CoxeterMatrix}}
\logpage{[ 3, 9, 7 ]}\nobreak
\hyperdef{L}{X815CB1D47CB174ED}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoxeterMatrix({\slshape A})\index{CoxeterMatrix@\texttt{CoxeterMatrix}}
\label{CoxeterMatrix}
}\hfill{\scriptsize (operation)}}\\


 This function returns the Coxeter matrix of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. }

 

\subsection{\textcolor{Chapter }{CoxeterPolynomial}}
\logpage{[ 3, 9, 8 ]}\nobreak
\hyperdef{L}{X7F6F526C86052150}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoxeterPolynomial({\slshape A})\index{CoxeterPolynomial@\texttt{CoxeterPolynomial}}
\label{CoxeterPolynomial}
}\hfill{\scriptsize (operation)}}\\


 This function returns the Coxeter polynomial of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra. }

 

\subsection{\textcolor{Chapter }{Centre/Center}}
\logpage{[ 3, 9, 9 ]}\nobreak
\hyperdef{L}{X80E403A8855F6F7A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Centre/Center({\slshape A})\index{Centre/Center@\texttt{Centre/Center}}
\label{Centre/Center}
}\hfill{\scriptsize (operation)}}\\


 This function returns the centre of the algebra \mbox{\texttt{\slshape A}}, after having checked that \mbox{\texttt{\slshape A}} is a finite dimensional quotient of a path algebra (the check is not
implemented and also not implemented for path algebras). }

 }

 
\section{\textcolor{Chapter }{Attributes and Operations on Elements of Quotients of Path Algebra}}\logpage{[ 3, 10, 0 ]}
\hyperdef{L}{X7BD7DB497917893C}{}
{
 

\subsection{\textcolor{Chapter }{IsNormalForm}}
\logpage{[ 3, 10, 1 ]}\nobreak
\hyperdef{L}{X8271E6F27C2C826E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsNormalForm({\slshape element})\index{IsNormalForm@\texttt{IsNormalForm}}
\label{IsNormalForm}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{IsNormalForm} operates on an \mbox{\texttt{\slshape element}} from a path algebra, and it is true if \mbox{\texttt{\slshape element}} is known to be in normal form. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> IsNormalForm(this); 
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 3, 10, 2 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape a, b})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{{\textless}} operates on two elements \mbox{\texttt{\slshape a}} and \mbox{\texttt{\slshape b}} from a path algebra $FQ$, and it compares them using the ordering for the path algebra. }

 

\subsection{\textcolor{Chapter }{ElementOfFpPathAlgebra}}
\logpage{[ 3, 10, 3 ]}\nobreak
\hyperdef{L}{X868C9F9981388DAA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ElementOfFpPathAlgebra({\slshape family, element, computenormal})\index{ElementOfFpPathAlgebra@\texttt{ElementOfFpPathAlgebra}}
\label{ElementOfFpPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{ElementOfFpPathAlgebra} operates on an \mbox{\texttt{\slshape element}} in a path algebra, and it projects it into the quotient given by \mbox{\texttt{\slshape family}}. If \mbox{\texttt{\slshape computenormal}} is true, then the normal form of the projection of \mbox{\texttt{\slshape element}} is returned. }

 

\subsection{\textcolor{Chapter }{OriginalPathAlgebra}}
\logpage{[ 3, 10, 4 ]}\nobreak
\hyperdef{L}{X8088721187BA8D82}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{OriginalPathAlgebra({\slshape algebra})\index{OriginalPathAlgebra@\texttt{OriginalPathAlgebra}}
\label{OriginalPathAlgebra}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{OriginalPathAlgebra} operates on an \mbox{\texttt{\slshape algebra}}. If it is a quotient of a path algebra or just a path algebra itself, it
returns the path algebra it was constructed from. Otherwise it returns an
error saying that the algebra entered was not a quotient of a path algebra. }

 }

 
\section{\textcolor{Chapter }{Predefined classes of quotient of path algebras}}\label{qpa:predefinedalgebras}
\logpage{[ 3, 11, 0 ]}
\hyperdef{L}{X7E7FA56079CF78D1}{}
{
 

\subsection{\textcolor{Chapter }{NakayamaAlgebra}}
\logpage{[ 3, 11, 1 ]}\nobreak
\hyperdef{L}{X7C678A08836F77CC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NakayamaAlgebra({\slshape admiss-seq, field})\index{NakayamaAlgebra@\texttt{NakayamaAlgebra}}
\label{NakayamaAlgebra}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
the Nakayama algebra corresponding to the addmissible sequence \mbox{\texttt{\slshape admiss-seq}} over the field \mbox{\texttt{\slshape field}}, or \texttt{the admissible sequence entered} if entered sequence is not an admissible sequence.



 This function creates a Nakayama algebra from an admissible sequence over a
field. }

 }

 
\section{\textcolor{Chapter }{Tensor products of path algebras}}\label{qpa:patensor}
\logpage{[ 3, 12, 0 ]}
\hyperdef{L}{X842527EC7F90C8C5}{}
{
  If $\Lambda$ and $\Gamma$ are quotients of path algebras over the same field $F$, then their tensor product $\Lambda \tensor_F \Gamma$ is also a quotient of a path algebra over $F$.

 The quiver for the tensor product path algebra is the \texttt{QuiverProduct} (\ref{QuiverProduct}) of the quivers of the original algebras.

 The operation \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras}) computes the tensor products of two quotients of path algebras as a quotient
of a path algebra. 

\subsection{\textcolor{Chapter }{QuiverProduct}}
\logpage{[ 3, 12, 1 ]}\nobreak
\hyperdef{L}{X835BBBE18104654A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverProduct({\slshape Q1, Q2})\index{QuiverProduct@\texttt{QuiverProduct}}
\label{QuiverProduct}
}\hfill{\scriptsize (operation)}}\\


 Creates the product quiver $\mbox{\texttt{\slshape Q1}} \quiverproduct \mbox{\texttt{\slshape Q2}}$. A vertex in $\mbox{\texttt{\slshape Q1}} \quiverproduct \mbox{\texttt{\slshape Q2}}$ which is made by combining a vertex named \texttt{u} in \mbox{\texttt{\slshape Q1}} with a vertex \texttt{v} in \mbox{\texttt{\slshape Q2}} is named \texttt{u{\textunderscore}v}. Arrows are named similarly (they are made by combining an arrow from one
quiver with a vertex from the other). }

 

\subsection{\textcolor{Chapter }{QuiverProductDecomposition}}
\logpage{[ 3, 12, 2 ]}\nobreak
\hyperdef{L}{X858517C18242C2F1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{QuiverProductDecomposition({\slshape Q})\index{QuiverProductDecomposition@\texttt{QuiverProductDecomposition}}
\label{QuiverProductDecomposition}
}\hfill{\scriptsize (attribute)}}\\


 Contains the original quivers \mbox{\texttt{\slshape Q}} is a product of, if \mbox{\texttt{\slshape Q}} was created by the \texttt{QuiverProduct} (\ref{QuiverProduct}) operation. The value of this attribute is an object in the category \texttt{IsQuiverProductDecomposition} (\ref{IsQuiverProductDecomposition}). }

 

\subsection{\textcolor{Chapter }{IsQuiverProductDecomposition}}
\logpage{[ 3, 12, 3 ]}\nobreak
\hyperdef{L}{X80E3731882B80106}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsQuiverProductDecomposition\index{IsQuiverProductDecomposition@\texttt{IsQuiverProductDecomposition}}
\label{IsQuiverProductDecomposition}
}\hfill{\scriptsize (filter)}}\\


 Category for objects containing information about the relation between a
product quiver and the quivers it is a product of. The quiver factors can be
extracted from the decomposition object by using the [] notation (like
accessing elements of a list). The decomposition object is also used by the
operations \texttt{IncludeInProductQuiver} (\ref{IncludeInProductQuiver}) and \texttt{ProjectFromProductQuiver} (\ref{ProjectFromProductQuiver}). }

 

\subsection{\textcolor{Chapter }{IncludeInProductQuiver}}
\logpage{[ 3, 12, 4 ]}\nobreak
\hyperdef{L}{X856E8B5B7F550647}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IncludeInProductQuiver({\slshape L, Q})\index{IncludeInProductQuiver@\texttt{IncludeInProductQuiver}}
\label{IncludeInProductQuiver}
}\hfill{\scriptsize (operation)}}\\


 Includes paths $q_1$ and $q_2$ from two quivers into the product of these quivers. If at least one of $q_1$ and $q_2$ is a vertex, there is exactly one possible inclusion. If they are both
non-trivial paths, there are several possibilities. This operation constructs
the path which is the inclusion of $q_1$ at the source of $q_2$ multiplied with the inclusion of $q_2$ at the target of $q_1$.

 The argument \mbox{\texttt{\slshape L}} is a list containing the paths $q_1$ and $q_2$ to be included; $Q$ is the product quiver to include them in. }

 

\subsection{\textcolor{Chapter }{ProjectFromProductQuiver}}
\logpage{[ 3, 12, 5 ]}\nobreak
\hyperdef{L}{X8455692C7E282C6C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ProjectFromProductQuiver({\slshape i, p})\index{ProjectFromProductQuiver@\texttt{ProjectFromProductQuiver}}
\label{ProjectFromProductQuiver}
}\hfill{\scriptsize (operation)}}\\


 Returns the projection of the product quiver path \mbox{\texttt{\slshape p}} to one of the factors. Which factor it should be projected to is specified by
the argument \mbox{\texttt{\slshape i}}. }

 The following example shows how the operations related to quiver products are
used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
  <quiver with 2 vertices and 1 arrows>
  gap> q2 := Quiver( [ "v1", "v2", "v3" ],
                        [ [ "v1", "v2", "b" ],
                          [ "v2", "v3", "c" ] ] );
  <quiver with 3 vertices and 2 arrows>
  gap> q1_q2 := QuiverProduct( q1, q2 );
  <quiver with 6 vertices and 7 arrows>
  gap> q1_q2.u1_b * q1_q2.a_v2;
  u1_b*a_v2
  gap> IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );
  a_v1*u2_b*u2_c
  gap> ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );
  b*c
  gap> q1_q2_dec := QuiverProductDecomposition( q1_q2 );
  <object>
  gap> q1_q2_dec[ 1 ];
  <quiver with 2 vertices and 1 arrows>
  gap> q1_q2_dec[ 1 ] = q1;
  true
    
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TensorProductOfAlgebras}}
\logpage{[ 3, 12, 6 ]}\nobreak
\hyperdef{L}{X7A9026937BDDFA6C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TensorProductOfAlgebras({\slshape FQ1, FQ2})\index{TensorProductOfAlgebras@\texttt{TensorProductOfAlgebras}}
\label{TensorProductOfAlgebras}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{TensorProductOfAlgebras} produces the tensor product of two (quotients of) path algebras \mbox{\texttt{\slshape FQ1}} and \mbox{\texttt{\slshape FQ2}}. The result is a quotient of a path algebra, whose quiver is the \texttt{QuiverProduct} (\ref{QuiverProduct}) of the quivers of the operands. }

 

\subsection{\textcolor{Chapter }{SimpleTensor}}
\logpage{[ 3, 12, 7 ]}\nobreak
\hyperdef{L}{X7B31F4F680135E72}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SimpleTensor({\slshape L, T})\index{SimpleTensor@\texttt{SimpleTensor}}
\label{SimpleTensor}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{SimpleTensor} produces a simple tensor $x \tensor y$ in the tensor product of two path algebras. The argument \mbox{\texttt{\slshape L}} is a list containing the elements $x$ and $y$. These should be elements of two (quotients of) path algebras, and \mbox{\texttt{\slshape T}} the tensor product of these algebras (produced by \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras})). }

 

\subsection{\textcolor{Chapter }{TensorProductDecomposition}}
\logpage{[ 3, 12, 8 ]}\nobreak
\hyperdef{L}{X7F0EBF88866A537D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TensorProductDecomposition({\slshape T})\index{TensorProductDecomposition@\texttt{TensorProductDecomposition}}
\label{TensorProductDecomposition}
}\hfill{\scriptsize (attribute)}}\\


 For a tensor product of quotients of path algebras (produced by \texttt{TensorProductOfAlgebras} (\ref{TensorProductOfAlgebras})), this attribute contains a list of the factors in the tensor product. }

 The following example shows how the operations for tensor products of
quotients of path algebras are used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
  <quiver with 2 vertices and 1 arrows>
  gap> q2 := Quiver( [ "v1", "v2", "v3", "v4" ],
                        [ [ "v1", "v2", "b" ],
                          [ "v1", "v3", "c" ],
                          [ "v2", "v4", "d" ],
                          [ "v3", "v4", "e" ] ] );
  <quiver with 4 vertices and 4 arrows>
  gap> fq1 := PathAlgebra( Rationals, q1 );
  <algebra-with-one over Rationals, with 3 generators>
  gap> fq2 := PathAlgebra( Rationals, q2 );
  <algebra-with-one over Rationals, with 8 generators>
  gap> I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );
  <two-sided ideal in <algebra-with-one over Rationals, with 8 generators>,
   (1 generators)>
  gap> quot := fq2 / I;
  <algebra-with-one over Rationals, with 8 generators>
  gap> t := TensorProductOfAlgebras( fq1, quot );
  <algebra-with-one over Rationals, with 20 generators>
  gap> SimpleTensor( [ fq1.a, quot.b ], t );
  [(1)*a_v1*u2_b]
  gap> t_dec := TensorProductDecomposition( t );
  [ <algebra-with-one over Rationals, with 3 generators>, 
    <algebra-with-one over Rationals, with 8 generators> ]
  gap> t_dec[ 1 ] = fq1;
  true
    
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{EnvelopingAlgebra}}
\logpage{[ 3, 12, 9 ]}\nobreak
\hyperdef{L}{X820195C47E2BE7E0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EnvelopingAlgebra({\slshape FQ})\index{EnvelopingAlgebra@\texttt{EnvelopingAlgebra}}
\label{EnvelopingAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Produces the enveloping algebra $\mbox{\texttt{\slshape FQ}}^\text{e} = \mbox{\texttt{\slshape FQ}} \tensor \mbox{\texttt{\slshape FQ}}^\text{op}$ of \mbox{\texttt{\slshape FQ}}, which should be (a quotient of) a path algebra. }

 

\subsection{\textcolor{Chapter }{IsEnvelopingAlgebra}}
\logpage{[ 3, 12, 10 ]}\nobreak
\hyperdef{L}{X7AE13B567B5F72FC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsEnvelopingAlgebra({\slshape A})\index{IsEnvelopingAlgebra@\texttt{IsEnvelopingAlgebra}}
\label{IsEnvelopingAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 True if and only if \mbox{\texttt{\slshape A}} is the result of a call to \texttt{EnvelopingAlgebra} (\ref{EnvelopingAlgebra}). }

 }

 }

 
\chapter{\textcolor{Chapter }{Groebner Basis}}\label{Groebner-Basis}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X8371E66387CB2E49}{}
{
 This chapter contains the declarations and implementations needed for Groebner
basis. Currently, we do not provide algorithms to actually compute Groebner
basis; instead, the declarations and implementations are provided here for GAP
objects and the actual elements of Groebner basis are expected to be computed
by external packages such as `Opal' and `Groebner'. 
\section{\textcolor{Chapter }{Constructing a Groebner Basis}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X850B47047FD4D709}{}
{
 

\subsection{\textcolor{Chapter }{InfoGroebnerBasis}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X8451936885F68598}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoGroebnerBasis\index{InfoGroebnerBasis@\texttt{InfoGroebnerBasis}}
\label{InfoGroebnerBasis}
}\hfill{\scriptsize (info class)}}\\


 is the info class for functions dealing with Groebner basis. }

 

\subsection{\textcolor{Chapter }{GroebnerBasis}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7A43611E876B7560}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GroebnerBasis({\slshape A, rels})\index{GroebnerBasis@\texttt{GroebnerBasis}}
\label{GroebnerBasis}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 an object in the `IsGroebnerBasis' category.



 The `GroebnerBasis' global function takes an algebra $A$ and a list of relations $rels \in A$ and creates an object in the `IsGroebnerBasis' category. There are absolutely
no checks for correctness in this function. Giving a set of relations that
does not form a Groebner basis may result in incorrect answers or unexpected
errors. This function is intended to be used by packages providing access to
external Groebner basis programs. }

 }

 
\section{\textcolor{Chapter }{Categories and Properties of Groebner Basis}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X79C7DC5D873A14D0}{}
{
 

\subsection{\textcolor{Chapter }{IsGroebnerBasis}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7BFD28E687AADFBB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGroebnerBasis({\slshape object})\index{IsGroebnerBasis@\texttt{IsGroebnerBasis}}
\label{IsGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a Groebner basis and 'false' otherwise. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsTipReducedGroebnerBasis}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X8592E4C87E41A15A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsTipReducedGroebnerBasis({\slshape object})\index{IsTipReducedGroebnerBasis@\texttt{IsTipReducedGroebnerBasis}}
\label{IsTipReducedGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a Groebner basis which is tip reduced. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsCompletelyReducedGroebnerBasis}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X85C0C1CD87C70AAA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCompletelyReducedGroebnerBasis({\slshape object})\index{IsCompletelyReducedGroebnerBasis@\texttt{IsCompletelyReducedGroebnerBasis}}
\label{IsCompletelyReducedGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a Groebner basis which is completely reduced. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsHomogenousGroebnerBasis}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X846E8A4984A9FBF3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsHomogenousGroebnerBasis({\slshape object})\index{IsHomogenousGroebnerBasis@\texttt{IsHomogenousGroebnerBasis}}
\label{IsHomogenousGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a Groebnerbasis which is homogenous. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsCompleteGroebnerBasis}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X86E7D0AE87CA048D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsCompleteGroebnerBasis({\slshape object})\index{IsCompleteGroebnerBasis@\texttt{IsCompleteGroebnerBasis}}
\label{IsCompleteGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} is a complete Groebner basis. While philosophically something that isn't a
complete Groebner basis isn't a Groebner basis at all, this property can be
used in conjuction with other properties to see if the the Groebner basis
contains enough information for computations. An example of a system that
creates incomplete Groebner basis is `Opal'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Attributes and Operations for Groebner Basis}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X84EF455882169920}{}
{
 

\subsection{\textcolor{Chapter }{CompletelyReduce}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X878AC1107E9671BA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CompletelyReduce({\slshape GB, a})\index{CompletelyReduce@\texttt{CompletelyReduce}}
\label{CompletelyReduce}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{CompletelyReduce} operates on an element \mbox{\texttt{\slshape a}} in a path algebra, and it reduces \mbox{\texttt{\slshape a}} by the Groebner basis \mbox{\texttt{\slshape GB}}. The reduced element is returned. If \mbox{\texttt{\slshape a}} is already completely reduced, the original element \mbox{\texttt{\slshape a}} is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{CompletelyReduceGroebnerBasis}}
\logpage{[ 4, 3, 2 ]}\nobreak
\hyperdef{L}{X7FF28B7B80759D24}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CompletelyReduceGroebnerBasis({\slshape GB})\index{CompletelyReduceGroebnerBasis@\texttt{CompletelyReduceGroebnerBasis}}
\label{CompletelyReduceGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{CompletelyReduceGroebnerBasis} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it modifies a Groebner basis $GB$ such that each relation in $GB$ is completely reduced. The `IsCompletelyReducedGroebnerBasis' and
`IsTipReducedGroebnerBasis' properties are set as a result of this operation.
The resulting relations will be placed in sorted order according to the
ordering of $GB$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TipReduce}}
\logpage{[ 4, 3, 3 ]}\nobreak
\hyperdef{L}{X7C6CD739788E7F59}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipReduce({\slshape GB, a})\index{TipReduce@\texttt{TipReduce}}
\label{TipReduce}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{TipReduce} operates on an element \mbox{\texttt{\slshape a}} in a path algebra, and it tip reduced by the Groebner basis $GB$. If $a$ is already tip reduced, then the original $a$ is returned. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{TipReduceGroebnerBasis}}
\logpage{[ 4, 3, 4 ]}\nobreak
\hyperdef{L}{X7B4F38D6852DF8B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TipReduceGroebnerBasis({\slshape GB})\index{TipReduceGroebnerBasis@\texttt{TipReduceGroebnerBasis}}
\label{TipReduceGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{TipReduceGroebnerBasis} operates on Groebner basis \mbox{\texttt{\slshape GB}}, and it returns an equivalent Groebner basis to $GB$ such that each relation generating $GB$ is tip reduced. If $GB$ is already tip reduced, this function returns the original object $GB$, possibly with the addition of the `IsTipReduced`' property set. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Iterator}}
\logpage{[ 4, 3, 5 ]}\nobreak
\hyperdef{L}{X83ADF8287ED0668E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Iterator({\slshape GB})\index{Iterator@\texttt{Iterator}}
\label{Iterator}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{Iterator} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it creates an iterator that iterates over the relations making up the
Groebner basis. These relations are iterated over in ascending order with
respect to the ordering for the family the elements are contained in. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Enumerator}}
\logpage{[ 4, 3, 6 ]}\nobreak
\hyperdef{L}{X7EF8910F82B45EC7}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Enumerator({\slshape GB})\index{Enumerator@\texttt{Enumerator}}
\label{Enumerator}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{Enumerator} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it creates an enumerator that enumerates the relations making up the
Groebner basis. These relations should are enumerated in ascending order with
respect to the ordering for the family the elements are contained in. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Nontips}}
\logpage{[ 4, 3, 7 ]}\nobreak
\hyperdef{L}{X7EAA029F8071ACC6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Nontips({\slshape GB})\index{Nontips@\texttt{Nontips}}
\label{Nontips}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{Nontips} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it returns a list of nontip elements for a Groebner basis. In order to
compute the nontip elements, the Groebner basis must be complete and tip
reduced, and there must be a finite number of nontips. If there are an
infinite number of nontips, the operation returns `fail'. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{AdmitsFinitelyManyNontips}}
\logpage{[ 4, 3, 8 ]}\nobreak
\hyperdef{L}{X8722C1577C236116}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AdmitsFinitelyManyNontips({\slshape GB})\index{AdmitsFinitelyManyNontips@\texttt{AdmitsFinitelyManyNontips}}
\label{AdmitsFinitelyManyNontips}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{AdmitsFinitelyManyNontips} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it returns `true' if the Groebner basis admits only finitely many
nontips and `false' otherwise. This operation only applies to complete
Groebner basis. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{NontipSize}}
\logpage{[ 4, 3, 9 ]}\nobreak
\hyperdef{L}{X7840F54D8240C288}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NontipSize({\slshape GB})\index{NontipSize@\texttt{NontipSize}}
\label{NontipSize}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{NontipSize} operates on a Groebner basis \mbox{\texttt{\slshape GB}}, and it returns the number of nontips admitted by the Groebner basis $GB$. This operation is available only to complete basis. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{IsPrefixOfTipInTipIdeal}}
\logpage{[ 4, 3, 10 ]}\nobreak
\hyperdef{L}{X8137C99A7934C1CA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPrefixOfTipInTipIdeal({\slshape GB, R})\index{IsPrefixOfTipInTipIdeal@\texttt{IsPrefixOfTipInTipIdeal}}
\label{IsPrefixOfTipInTipIdeal}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{IsPrefixOfTipInTipIdeal} operates on a Groebner basis \mbox{\texttt{\slshape GB}} and a relation \mbox{\texttt{\slshape R}}, and it checks the tip of a relation $R$ to see if it is in the tip ideal generated by the tips of $GB$. This is used mainly for the construction of right Groebner basis, but is
made available for general use in case there are other unforseen applications. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Right Groebner Basis}}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X82C1C09486934532}{}
{
 In this section we support right Groebner basis for two-sided ideals with
Groebner basis. More general cases may be supported in the future. 

\subsection{\textcolor{Chapter }{IsRightGroebnerBasis}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X86EC39527F33EABE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsRightGroebnerBasis({\slshape object})\index{IsRightGroebnerBasis@\texttt{IsRightGroebnerBasis}}
\label{IsRightGroebnerBasis}
}\hfill{\scriptsize (property)}}\\


 is true when \mbox{\texttt{\slshape object}} a right Groebner basis. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap>
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{RightGroebnerBasisOfIdeal}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X812BFF79867FF73A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightGroebnerBasisOfIdeal({\slshape object})\index{RightGroebnerBasisOfIdeal@\texttt{RightGroebnerBasisOfIdeal}}
\label{RightGroebnerBasisOfIdeal}
}\hfill{\scriptsize (attribute)}}\\


 An attribute. Stores a right Groebner basis of a right ideal, \mbox{\texttt{\slshape object}}, is one has been computed. }

 

\subsection{\textcolor{Chapter }{RightGroebnerBasis}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X7B29B9207D20EA9E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightGroebnerBasis({\slshape R})\index{RightGroebnerBasis@\texttt{RightGroebnerBasis}}
\label{RightGroebnerBasis}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{RightGroebnerBasis} operates on a right ideal \mbox{\texttt{\slshape R}} in a path algebra, and it constructs a right Groebner basis for the right
ideal, $R$, which must support a right Groebner basis theory. Right now, this requires
that R have a complete Groebner basis. }

 }

 }

 
\chapter{\textcolor{Chapter }{Using GBNP with Gap}}\label{GBNP}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X83BD16BB7FF08CD1}{}
{
 
\section{\textcolor{Chapter }{GBNP}}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7C8F0BF282342E3A}{}
{
 \textsf{GBNP} is a non-commutative Groebner Basis package which assumes that all algebras
involved will be free algebras over a finite number of non-commuting
generators. It also assumes that the ordering on the monomials is left
length-lexicographic. }

 
\section{\textcolor{Chapter }{Setting up GBNP}}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X86408B737FFF9279}{}
{
 in progress... }

 
\section{\textcolor{Chapter }{Relevant GBNP internals}}\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X78E3029087911EF4}{}
{
 in progress... }

 
\section{\textcolor{Chapter }{Communicating with GBNP}}\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X7A26A6DF791985FE}{}
{
 in progress... }

 }

 
\chapter{\textcolor{Chapter }{Right Modules over Path Algebras}}\label{Right-Modules}
\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X87EFC38F7BC77B27}{}
{
 There are two implementations of right modules over path algebras. The first
type are matrix modules that are defined by vector spaces and linear
transformations. The second type are presentations defined by vertex
projective modules. 
\section{\textcolor{Chapter }{Matrix Modules}}\logpage{[ 6, 1, 0 ]}
\hyperdef{L}{X7D4882837C7EE06C}{}
{
 The first implementation of right modules over path algebras views them as a
collection of vector spaces and linear transformations. Each vertex in the
path algebra is associated with a vector space over the field of the algebra.
For each vertex $v$ of the algebra there is a vector space $V$. Arrows of the algebra are then associated with linear transformations which
map the vector space of the source vertex to the vector space of the target
vertex. For example, if $a$ is an arrow from $v$ to $w$ then there is a transformation from vector space $V$ to $W$. In practice when creating the modules all we need to know is the
transformations and we can create the vector spaces of the correct dimension,
and check to make sure the dimensions all agree. We can create a module in
this way as follows.

 

\subsection{\textcolor{Chapter }{RightModuleOverPathAlgebra}}
\logpage{[ 6, 1, 1 ]}\nobreak
\hyperdef{L}{X82DAF2167E65C4A8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleOverPathAlgebra({\slshape A, mats})\index{RightModuleOverPathAlgebra@\texttt{RightModuleOverPathAlgebra}}
\label{RightModuleOverPathAlgebra}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleOverQuotientOfPathAlgebra({\slshape A, mats})\index{RightModuleOverQuotientOfPathAlgebra@\texttt{RightModuleOverQuotientOfPathAlgebra}}
\label{RightModuleOverQuotientOfPathAlgebra}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a representation over a path algebra.



 In the function call, \mbox{\texttt{\slshape A}} is a (quotient of a ) path algebra. The list of matrices \mbox{\texttt{\slshape mats}} can take on three different forms.

 1) The argument \mbox{\texttt{\slshape mats}} can be a list of blocks of matrices where each block is of the form, `["name
of arrow",matrix]'. So if you named your arrows when you created the quiver,
then you can associate a matrix with that arrow explicitly.

 2) The argument \mbox{\texttt{\slshape mats}} is just a list of matrices, and the matrices will be associated to the arrows
in the order of arrow creation. If when creating the quiver, the arrow $a$ was created first, then $a$ would be associated with the first matrix.

 3) The method is very much the same as the second method. If \mbox{\texttt{\slshape arrows}} is a list of the arrows of the quiver (obtained for instance through \texttt{arrows := ArrowsOfQuiver(Q);}), the argument \mbox{\texttt{\slshape mats}} can have the format \texttt{[[arrows[1],matrix{\textunderscore}1],[arrows[2],matrix{\textunderscore}2],....
].}

 If you would like the trivial vector space at any vertex, then for each
incoming arrow "a", associate it with a list of the form \texttt{["a",[n,0]]} where n is the dimension of the vector space at the source vertex of the
arrow. Likewise for all outgoing arrows "b", associate them to a block of form \texttt{["b",[0,n]]} where n is the dimension of the vector space at the target vertex of the
arrow.

 A warning though, the function assumes that you do not mix the styles of
inputting the matrices/linear transformations associated to the arrows in the
quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise an
error will be returned. The function verifies that the dimensions of the
matrices and vector spaces are correct and match, and that each arrow has only
one matrix assigned to it.

 }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); 
  <quiver with 2 vertices and 3 arrows>
  gap> P := PathAlgebra(Rationals, Q);
  <algebra-with-one over Rationals, with 5 generators>
  gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
  > ["c", [[0,0],[1,0]]]];
  [ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
    [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
    [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
  gap> M := RightModuleOverPathAlgebra(P,matrices);
  <right-module over <algebra-with-one over Rationals, with 5
  generators>> 
  gap> mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; 
  gap> N := RightModuleOverPathAlgebra(P,mats); 
  <right-module over <algebra-with-one over Rationals, with 5
  generators>> 
  gap> arrows := ArrowsOfQuiver(Q);
  [ a, b, c ]
  gap> mats := [[arrows[1], [[1,0,0],[0,1,0]]], 
  > [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;
  gap> N := RightModuleOverPathAlgebra(P,mats); 
  <right-module over <algebra-with-one over Rationals, with 5
  generators>>
  gap> # Next we give the vertex simple associate to vertex 1. 
  gap> M :=
  RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);
  <right-module over <algebra-with-one over Rationals, with 5
  					generators>> 
  gap> # Finally, the next defines the zero representation of the quiver.
  gap> M :=
  RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);
  <right-module over <algebra-with-one over Rationals, with 5
  					generators>> 
  gap> Dimension(M);
  0
  gap> Basis(M);
  Basis( <
  0-dimensional right-module over <algebra-with-one over Rationals, with 
  5 generators>>, [  ] )
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Categories Of Matrix Modules}}\logpage{[ 6, 2, 0 ]}
\hyperdef{L}{X869F4DD2877A99BA}{}
{
 

\subsection{\textcolor{Chapter }{IsPathAlgebraMatModule}}
\logpage{[ 6, 2, 1 ]}\nobreak
\hyperdef{L}{X8710CC447F1F7B17}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebraMatModule({\slshape object})\index{IsPathAlgebraMatModule@\texttt{IsPathAlgebraMatModule}}
\label{IsPathAlgebraMatModule}
}\hfill{\scriptsize (filter)}}\\


 These matrix modules fall under the category `IsAlgebraModule' with the added
filter of `IsPathAlgebraMatModule'. Operations available for algebra modules
can be applied to path algebra modules. See "ref:representations of algebras"
for more details. These modules are also vector spaces over the field of the
path algebra. So refer to "ref:vector spaces" for descriptions of the basis
and elementwise operations available. }

 }

 
\section{\textcolor{Chapter }{Acting on Module Elements}}\logpage{[ 6, 3, 0 ]}
\hyperdef{L}{X862F510485ADBC67}{}
{
 

\subsection{\textcolor{Chapter }{\texttt{\symbol{94}}}}
\logpage{[ 6, 3, 1 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{94}}({\slshape m, p})\index{^@\texttt{\texttt{\symbol{94}}}}
\label{^}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{\texttt{\symbol{94}}} operates on an element \mbox{\texttt{\slshape m}} in a module and a path \mbox{\texttt{\slshape p}} in a path algebra, and it returns the element \mbox{\texttt{\slshape m}} multiplied with \mbox{\texttt{\slshape p}}. When you act on an module element $m$ by an arrow $a$ from $v$ to $w$, the component of $m$ from $V$ is acted on by $L$ the transformation associated to $a$ and placed in the component $W$ . All other components are given the value $0$. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> # Using the path algebra P from the above example. 
  gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
  > ["c", [[0,0],[1,0]]]];
  [ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
    [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
    [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
  gap> M := RightModuleOverPathAlgebra(P,matrices);
  <right-module over <algebra-with-one over Rationals, with 5
  generators>> 
  gap> B:=BasisVectors(Basis(M));
  [ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
    [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
    [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
  gap> B[1]+B[3];
  [ [ 1, 0 ], [ 1, 0, 0 ] ]
  gap> 4*B[2];
  [ [ 0, 4 ], [ 0, 0, 0 ] ]
  gap> m:=5*B[1]+2*B[4]+B[5];
  [ [ 5, 0 ], [ 0, 2, 1 ] ]
  gap> m^(P.a*P.b-P.c);
  [ [ 0, 5 ], [ 0, 0, 0 ] ]
  gap> B[1]^P.a;
  [ [ 0, 0 ], [ 1, 0, 0 ] ]
  gap> B[2]^P.b;
  [ [ 0, 0 ], [ 0, 0, 0 ] ]
  gap> B[4]^(P.b*P.c);
  [ [ 0, 0 ], [ 0, 0, 0 ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Operations on representations}}\logpage{[ 6, 4, 0 ]}
\hyperdef{L}{X7E5B84B1832D839E}{}
{
 

\subsection{\textcolor{Chapter }{DimensionVector}}
\logpage{[ 6, 4, 1 ]}\nobreak
\hyperdef{L}{X7B5EA4B0820DE28C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DimensionVector({\slshape M})\index{DimensionVector@\texttt{DimensionVector}}
\label{DimensionVector}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the dimension vector of the representation \mbox{\texttt{\slshape M}}. The argument \mbox{\texttt{\slshape M}} must be a \texttt{PathAlgebraMatModule}. 



 A shortcoming of this that it is not defined for modules of quotients of path
algebras. }

 

\subsection{\textcolor{Chapter }{LoewyLength}}
\logpage{[ 6, 4, 2 ]}\nobreak
\hyperdef{L}{X7BEA44FB819910B6}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LoewyLength({\slshape M})\index{LoewyLength@\texttt{LoewyLength}}
\label{LoewyLength}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the Loewy length of the module \mbox{\texttt{\slshape M}}.



 The function checks that the module \mbox{\texttt{\slshape M}} is a module over a finite dimensional quotient of a path algebra, and returns
fail otherwise (This is not implemented yet). }

 

\subsection{\textcolor{Chapter }{RadicalOfRep}}
\logpage{[ 6, 4, 3 ]}\nobreak
\hyperdef{L}{X836C258381A956AB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalOfRep({\slshape M})\index{RadicalOfRep@\texttt{RadicalOfRep}}
\label{RadicalOfRep}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the radical of the module \mbox{\texttt{\slshape M}}.



 This returns only the representation given by the radical of the module \mbox{\texttt{\slshape M}}. The operation \texttt{RadicalOfRepInclusion} (\ref{RadicalOfRepInclusion}) computes the inclusion of the radical of \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}. }

 

\subsection{\textcolor{Chapter }{RadicalSeries}}
\logpage{[ 6, 4, 4 ]}\nobreak
\hyperdef{L}{X7929281B848A9FBE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalSeries({\slshape M})\index{RadicalSeries@\texttt{RadicalSeries}}
\label{RadicalSeries}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the radical series of the module \mbox{\texttt{\slshape M}}.



 The function gives the radical series as a list of vectors \texttt{[n{\textunderscore}1,...,n{\textunderscore}s]}, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of
each simple. The first vector listed corresponds to the top layer, and so on. }

 

\subsection{\textcolor{Chapter }{SocleSeries}}
\logpage{[ 6, 4, 5 ]}\nobreak
\hyperdef{L}{X84A724267E6F136D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleSeries({\slshape M})\index{SocleSeries@\texttt{SocleSeries}}
\label{SocleSeries}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the socle series of the module \mbox{\texttt{\slshape M}}.



 The function gives the socle series as a list of vectors \texttt{[n{\textunderscore}1,...,n{\textunderscore}s]}, where the algebra has $s$ isomorphism classes of simple modules and the numbers give the multiplicity of
each simple. The last vector listed corresponds to the socle layer, and so on
backwards. }

 

\subsection{\textcolor{Chapter }{SocleOfPathAlgebraMatModule}}
\logpage{[ 6, 4, 6 ]}\nobreak
\hyperdef{L}{X79FD8317809E5A65}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleOfPathAlgebraMatModule({\slshape M})\index{SocleOfPathAlgebraMatModule@\texttt{SocleOfPathAlgebraMatModule}}
\label{SocleOfPathAlgebraMatModule}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the socle of the module \mbox{\texttt{\slshape M}}.



 This operation only return the representation given by the socle of the module \mbox{\texttt{\slshape M}}. The inclusion the socle of \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}} can be computed using \texttt{SocleOfPathAlgebraMatModuleInclusion} (\ref{SocleOfPathAlgebraMatModuleInclusion}). }

 

\subsection{\textcolor{Chapter }{SubRep}}
\logpage{[ 6, 4, 7 ]}\nobreak
\hyperdef{L}{X80298D0987B1882B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SubRep({\slshape M, gens})\index{SubRep@\texttt{SubRep}}
\label{SubRep}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the submodule of the module \mbox{\texttt{\slshape M}} generated by the elements \mbox{\texttt{\slshape gens}}.



 The function checks if \mbox{\texttt{\slshape gens}} are elements in \mbox{\texttt{\slshape M}}, and returns an error message otherwise. The inclusion of the submodule
generated by the elements \mbox{\texttt{\slshape gens}} into \mbox{\texttt{\slshape M}} can be computed using \texttt{SubRepInclusion} (\ref{SubRepInclusion}). }

 

\subsection{\textcolor{Chapter }{TopOfRep}}
\logpage{[ 6, 4, 8 ]}\nobreak
\hyperdef{L}{X7FE6863F81D84464}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TopOfRep({\slshape M})\index{TopOfRep@\texttt{TopOfRep}}
\label{TopOfRep}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the top of the module \mbox{\texttt{\slshape M}}.



 This returns only the representation given by the top of the module \mbox{\texttt{\slshape M}}. The operation \texttt{TopOfRepProjection} (\ref{TopOfRepProjection}) computes the projection of the module \mbox{\texttt{\slshape M}} onto the top of the module \mbox{\texttt{\slshape M}}. }

 

\subsection{\textcolor{Chapter }{GeneratorsOfRep}}
\logpage{[ 6, 4, 9 ]}\nobreak
\hyperdef{L}{X8742104E7F6A64D5}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GeneratorsOfRep({\slshape M})\index{GeneratorsOfRep@\texttt{GeneratorsOfRep}}
\label{GeneratorsOfRep}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a minimal generator set of the module \mbox{\texttt{\slshape M}} as a module of the path algebra it is defined over.

}

 

\subsection{\textcolor{Chapter }{MatricesOfPathAlgebraMatModule}}
\logpage{[ 6, 4, 10 ]}\nobreak
\hyperdef{L}{X7E676BA9848F4D84}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatricesOfPathAlgebraMatModule({\slshape M})\index{MatricesOfPathAlgebraMatModule@\texttt{MatricesOfPathAlgebraMatModule}}
\label{MatricesOfPathAlgebraMatModule}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a list of the matrices that defines the representation \mbox{\texttt{\slshape M}} as a right module of the acting path algebra. The argument \mbox{\texttt{\slshape M}} must be a \texttt{PathAlgebraMatModule}. 



 The list of matrices that are returned are not the same identical to the
matrices entered to define the representation if there is zero vector space in
at least one vertex. Then zero matrices of the appropriate size are returned.
A shortcoming of this that it is not defined for modules of quotients of path
algebras. }

 }

 
\section{\textcolor{Chapter }{Special representations}}\logpage{[ 6, 5, 0 ]}
\hyperdef{L}{X7919F94382D9B38B}{}
{
 Here we collect the predefined representations/modules over a finite
dimensional quotient of a path algebra. 

\subsection{\textcolor{Chapter }{IndecomposableProjectiveRepresentations}}
\logpage{[ 6, 5, 1 ]}\nobreak
\hyperdef{L}{X82637AE885576148}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IndecomposableProjectiveRepresentations({\slshape A[, list]})\index{IndecomposableProjectiveRepresentations@\texttt{IndecomposableProjectiveRepresentations}}
\label{IndecomposableProjectiveRepresentations}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a list of all the indecomposable projective representations over a finite
dimensional (quotient of a) path algebra \mbox{\texttt{\slshape A}}, when only one argument is supplied. The second argument should be a list of
integers, for example [1, 3, 4], which will return the indecomposable
projective corresponding to vertex 1, 3 and 4, in this order. 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{IndecomposableInjectiveRepresentations}}
\logpage{[ 6, 5, 2 ]}\nobreak
\hyperdef{L}{X78829EE8850BCD9F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IndecomposableInjectiveRepresentations({\slshape A[, list]})\index{IndecomposableInjectiveRepresentations@\texttt{IndecomposableInjectiveRepresentations}}
\label{IndecomposableInjectiveRepresentations}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a list of all the indecomposable injective representations over a finite
dimensional (quotient of a) path algebra \mbox{\texttt{\slshape A}}, when only one argument is supplied. The second argument should be a list of
integers, for example [1, 3, 4], which will return the indecomposable
injective corresponding to vertex 1, 3 and 4, in this order. 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{VertexSimpleRepresentations}}
\logpage{[ 6, 5, 3 ]}\nobreak
\hyperdef{L}{X7B0AD1CB7F3D0D3C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{VertexSimpleRepresentations({\slshape A})\index{VertexSimpleRepresentations@\texttt{VertexSimpleRepresentations}}
\label{VertexSimpleRepresentations}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a list of all the simple representations over a finite dimensional (quotient
of a) path algebra \mbox{\texttt{\slshape A}} . 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 

\subsection{\textcolor{Chapter }{ZeroRepresentation}}
\logpage{[ 6, 5, 4 ]}\nobreak
\hyperdef{L}{X8106F9C681CE5E49}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ZeroRepresentation({\slshape A})\index{ZeroRepresentation@\texttt{ZeroRepresentation}}
\label{ZeroRepresentation}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the zero representation over a finite dimensional (quotient of a) path algebra \mbox{\texttt{\slshape A}} . 



 The function checks if the algebra \mbox{\texttt{\slshape A}} is a finite dimensional (quotient of a) path algebra, and returns an error
message otherwise. }

 }

 
\section{\textcolor{Chapter }{Functors on representations}}\logpage{[ 6, 6, 0 ]}
\hyperdef{L}{X7D99BF5A87DDC099}{}
{
 

\subsection{\textcolor{Chapter }{DualOfPathAlgebraMatModule}}
\logpage{[ 6, 6, 1 ]}\nobreak
\hyperdef{L}{X807D065C7AD70C6F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualOfPathAlgebraMatModule({\slshape M})\index{DualOfPathAlgebraMatModule@\texttt{DualOfPathAlgebraMatModule}}
\label{DualOfPathAlgebraMatModule}
}\hfill{\scriptsize (operation)}}\\


 Takes the a representation \mbox{\texttt{\slshape M}} of a path algebra $KQ$ and produces the dual of this representation over the opposite path algebra \mbox{\texttt{\slshape KQ{\textunderscore}op}}. }

 

\subsection{\textcolor{Chapter }{DualOfPathAlgebraMatModuleMap}}
\logpage{[ 6, 6, 2 ]}\nobreak
\hyperdef{L}{X86846EFE7FD4E643}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DualOfPathAlgebraMatModuleMap({\slshape f})\index{DualOfPathAlgebraMatModuleMap@\texttt{DualOfPathAlgebraMatModuleMap}}
\label{DualOfPathAlgebraMatModuleMap}
}\hfill{\scriptsize (operation)}}\\


 Takes the a map \mbox{\texttt{\slshape f}} between two representations \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} over a path algebra $A$ and produces the dual of this map over the opposite path algebra \mbox{\texttt{\slshape A\texttt{\symbol{94}}op}}. }

 }

 
\section{\textcolor{Chapter }{Vertex Projective Presentations}}\logpage{[ 6, 7, 0 ]}
\hyperdef{L}{X8097F19E8228B68C}{}
{
 In general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a projective module of $R$. Then we can form a direct sum of these projective modules together to form
larger projective module. One can construct more general modules by providing
a \mbox{\texttt{\slshape vertex projective presentation}}. In this case, $M$ is the cokernel as given by the following exact sequence: $\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R \rightarrow{M}
\rightarrow 0$ for some map between $\oplus_{j=1}^{r} w(j)R$ and $\oplus_{i=1}^{g} v(i)R$. The maps $w$ and $v$ map the integers to some idempotent in $R$. 

\subsection{\textcolor{Chapter }{RightProjectiveModule}}
\logpage{[ 6, 7, 1 ]}\nobreak
\hyperdef{L}{X79175B097A0718FE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightProjectiveModule({\slshape A, verts})\index{RightProjectiveModule@\texttt{RightProjectiveModule}}
\label{RightProjectiveModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the right projective module over \mbox{\texttt{\slshape A}} which is the direct sum of projective modules of the form \mbox{\texttt{\slshape vA}} where the vertices are taken from the list of vertices \mbox{\texttt{\slshape verts}}.



 In this implemenation the algebra can be a quotient of a path algebra. So if
the list was $[v,w]$ then the module created will be the direct sum $vA \oplus wA$, in that order. Elements of the modules are vectors of algebra elements, and
in each component, each path begins with the vertex in that position in the
list of vertices. Right projective modules are implementated as algebra
modules (see "ref:Representations of Algebras") and all operations for algebra
modules are applicable to right projective modules. In particular, one can
construct submodules using `SubAlgebraModule'. }

 Here we create the right projective module $P = vA \oplus vA \oplus wA$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> F:=GF(11);
  GF(11)
  gap> Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
  <quiver with 3 vertices and 3 arrows>
  gap> A:=PathAlgebra(F,Q);
  <algebra-with-one over GF(11), with 6 generators>
  gap> P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
  <right-module over <algebra-with-one over GF(11), with 6 generators>>
  gap> Dimension(P);
  12
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{Vectorize}}
\logpage{[ 6, 7, 2 ]}\nobreak
\hyperdef{L}{X78E05C8F7ADE2BCD}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Vectorize({\slshape M, components})\index{Vectorize@\texttt{Vectorize}}
\label{Vectorize}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
a vector in the module \mbox{\texttt{\slshape M}} from a list of path algebra elements \mbox{\texttt{\slshape components}}, which defines the components in the resulting vector.



 The returned vector is normalized, so the vector's components may not match
the input components. }

 In the following example, we create two elements in $P$, perform some elementwise operations, and then construct a submodule using
the two elements as generators.

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
  [ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
  gap> p2:=Vectorize(P,[A.a,A.b,A.w]);
  [ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
  gap> 2*p1 + p2;
  [ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ]
  gap> S:=SubAlgebraModule(P,[p1,p2]);
  <right-module over <algebra-with-one of dimension 8 over GF(11)>>
  gap> Dimension(S);
  3
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{\texttt{\symbol{94}}}}
\logpage{[ 6, 7, 3 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{94}}({\slshape m, a})\index{^@\texttt{\texttt{\symbol{94}}}}
\label{^}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{\texttt{\symbol{94}}} operates on an element \mbox{\texttt{\slshape m}} in a module and an element \mbox{\texttt{\slshape a}} in a path algebra, and it returns the element \mbox{\texttt{\slshape m}} multiplied with \mbox{\texttt{\slshape a}}. This action is defined by multiplying each component in \mbox{\texttt{\slshape m}} by \mbox{\texttt{\slshape a}} on the right. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p2^(A.c - A.w);
  [ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
    (Z(11)^5)*w+(Z(11)^0)*c ]
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{{\textless}}}
\logpage{[ 6, 7, 4 ]}\nobreak
\hyperdef{L}{X871A3B1D871A3B1D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{{\textless}({\slshape m1, m2})\index{<@\texttt{{\textless}}}
\label{<}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{{\textless}} operates on elements \mbox{\texttt{\slshape m1}} and \mbox{\texttt{\slshape m2}} in ????, and it compares them. The result is `true' if \mbox{\texttt{\slshape m1}} is less than \mbox{\texttt{\slshape m2}} and false otherwise. Elements are compared componentwise from left to right
using the ordering of the underlying algebra. The element \mbox{\texttt{\slshape m1}} is less than \mbox{\texttt{\slshape m2}} if the first time components are not equal, the component of \mbox{\texttt{\slshape m1}} is less than the corresponding component of \mbox{\texttt{\slshape m2}}. }

 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> p1 < p2;
  false
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{/}}
\logpage{[ 6, 7, 5 ]}\nobreak
\hyperdef{L}{X8123456781234567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{/({\slshape M, N})\index{/@\texttt{/}}
\label{/}
}\hfill{\scriptsize (operation)}}\\


 The operation \texttt{/} operates on two finite dimensional modules \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} over a path algebra?, and it constructs the factor module $M/N$. This module is again a right algebra module, and all applicable methods and
operations are available for the resulting factor module. Furthermore, the
resulting module is a vector space, so operations for computing bases and
dimensions are also available. }

 This 
\begin{Verbatim}[fontsize=\small,frame=single,label=Example]
  gap> PS := P/S;
  <9-dimensional right-module over <algebra-with-one of dimension
  8 over GF(11)>> 
  gap> Basis(PS);
  Basis( <9-dimensional right-module over <algebra-with-one of dimension 
  8 over GF(11)>>, [ [ [ <zero> of ..., <zero> of ...,
  (Z(11)^0)*w ] ],  
    [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], 
    [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*b, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], 
    [ [ <zero> of ..., (Z(11)^0)*b*c, <zero> of ... ] ], 
    [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], 
    [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ] ] )
\end{Verbatim}
 }

 }

 
\chapter{\textcolor{Chapter }{Homomorphisms of Right Modules over Path Algebras}}\label{Homomorphisms}
\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7C049EFC82A7CAA7}{}
{
 This chapter describes the categories, representations, attributes, and
operations on homomorphisms between representations of quivers. 
\section{\textcolor{Chapter }{Categories and representation of homomorphisms}}\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X7B18E84678FA5EE0}{}
{
 

\subsection{\textcolor{Chapter }{IsPathAlgebraMatModuleMap}}
\logpage{[ 7, 1, 1 ]}\nobreak
\hyperdef{L}{X7B5879BF7BDF08BA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsPathAlgebraMatModuleMap({\slshape object})\index{IsPathAlgebraMatModuleMap@\texttt{IsPathAlgebraMatModuleMap}}
\label{IsPathAlgebraMatModuleMap}
}\hfill{\scriptsize (filter)}}\\


 The homomorphisms between modules over a path algebra belongs to the
categories \texttt{IsAdditiveElementWithZero}, \texttt{IsGeneralMapping}, \texttt{RespectsScalarMultiplication}, \texttt{IsTotal} and \texttt{IsSingleValued} with the added filter of \texttt{IsPathAlgebraMatModuleMap} }

 

\subsection{\textcolor{Chapter }{RightModuleHomOverPathAlgebra}}
\logpage{[ 7, 1, 2 ]}\nobreak
\hyperdef{L}{X85614C9E85E173F9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RightModuleHomOverPathAlgebra({\slshape M, N, mats})\index{RightModuleHomOverPathAlgebra@\texttt{RightModuleHomOverPathAlgebra}}
\label{RightModuleHomOverPathAlgebra}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a homomorphism from the module \mbox{\texttt{\slshape M}} to the module \mbox{\texttt{\slshape N}} given by the matrices \mbox{\texttt{\slshape mats}}.



 The arguments \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}} are two modules over the same algebra (this is checked), and \mbox{\texttt{\slshape mats}} is a list \texttt{DimensionVector(M)[i]} by \texttt{DimensionVector(N)[i]} matrices, where \texttt{i} runs over all the vertices in the underlying quiver. The function checks if \mbox{\texttt{\slshape mats}} is a homomorphism from the module \mbox{\texttt{\slshape M}} to the module \mbox{\texttt{\slshape N}} by checking that the matrices given in \mbox{\texttt{\slshape mats}} have the correct size and satisfy the appropriate commutativity conditions
with the matrices in the representations given by \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}. The source (or domain) and the range (or codomain) of the homomorphism
constructed can by obtained again by \texttt{Range} (\ref{Range}) and by \texttt{Source} (\ref{Source}), respectively. }

 }

 
\section{\textcolor{Chapter }{Generalities of homomorphisms}}\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X830529F9800BF688}{}
{
 

\subsection{\textcolor{Chapter }{Range}}
\logpage{[ 7, 2, 1 ]}\nobreak
\hyperdef{L}{X829F76BB80BD55DB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Range({\slshape f})\index{Range@\texttt{Range}}
\label{Range}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the range (or codomain) the homomorphism \mbox{\texttt{\slshape f}}.

}

 

\subsection{\textcolor{Chapter }{Source}}
\logpage{[ 7, 2, 2 ]}\nobreak
\hyperdef{L}{X7DE8173F80E07AB1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Source({\slshape f})\index{Source@\texttt{Source}}
\label{Source}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the source (or domain) the homomorphism \mbox{\texttt{\slshape f}}.

}

 

\subsection{\textcolor{Chapter }{PreImageElm}}
\logpage{[ 7, 2, 3 ]}\nobreak
\hyperdef{L}{X7D212F727CAE971A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PreImageElm({\slshape f, elem})\index{PreImageElm@\texttt{PreImageElm}}
\label{PreImageElm}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
a preimage of an element \mbox{\texttt{\slshape elem}} in the range (or codomain) the homomorphism \mbox{\texttt{\slshape f}}.



 The functions checks if \mbox{\texttt{\slshape elem}} is an element in the range of \mbox{\texttt{\slshape f}}, and it returns a preimage of \mbox{\texttt{\slshape elem}} one exists, and otherwise it returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{ImageElm}}
\logpage{[ 7, 2, 4 ]}\nobreak
\hyperdef{L}{X7CFAB0157BFB1806}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageElm({\slshape f, elem})\index{ImageElm@\texttt{ImageElm}}
\label{ImageElm}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the image of the element \mbox{\texttt{\slshape elem}} in the source (or domain) of the homomorphism \mbox{\texttt{\slshape f}}.



 The functions checks if \mbox{\texttt{\slshape elem}} is an element in the source of \mbox{\texttt{\slshape f}}, and it returns an error message otherwise. }

 

\subsection{\textcolor{Chapter }{ImagesSet}}
\logpage{[ 7, 2, 5 ]}\nobreak
\hyperdef{L}{X8781348F7F5796A0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImagesSet({\slshape f, elts})\index{ImagesSet@\texttt{ImagesSet}}
\label{ImagesSet}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the non-zero images of a set elements \mbox{\texttt{\slshape elts}} in the source (or domain) of the homomorphism \mbox{\texttt{\slshape f}}, or if \mbox{\texttt{\slshape elts}} is a submodule of the source of \mbox{\texttt{\slshape f}}, it returns a basis of the non-zero elements in the image of the homomorphism
restricted to the submodule.



 The functions checks if the set of elements \mbox{\texttt{\slshape elts}} consists of elements in the source of \mbox{\texttt{\slshape f}}, and it returns an error message otherwise. }

 

\subsection{\textcolor{Chapter }{Zero}}
\logpage{[ 7, 2, 6 ]}\nobreak
\hyperdef{L}{X804B376481243046}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Zero({\slshape f})\index{Zero@\texttt{Zero}}
\label{Zero}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the zero map between \texttt{Source(f)} and \texttt{Range(f)}.

}

 

\subsection{\textcolor{Chapter }{ZeroMap}}
\logpage{[ 7, 2, 7 ]}\nobreak
\hyperdef{L}{X8377BC22879E9177}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ZeroMap({\slshape M, N})\index{ZeroMap@\texttt{ZeroMap}}
\label{ZeroMap}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the zero map between \mbox{\texttt{\slshape M}} and \mbox{\texttt{\slshape N}}.

}

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}= (maps)}}
\logpage{[ 7, 2, 8 ]}\nobreak
\hyperdef{L}{X7E8438F77ECB778E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}= (maps)({\slshape f, g})\index{= (maps)@\texttt{\texttt{\symbol{92}}= (maps)}}
\label{= (maps)}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
true, if \texttt{Source(f)=Source(g)}, \texttt{Range(f)=Range(g)}, the matrices defining the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}} coincide.

}

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}+ (maps)}}
\logpage{[ 7, 2, 9 ]}\nobreak
\hyperdef{L}{X7FA09A067BE00277}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}+ (maps)({\slshape f, g})\index{+ (maps)@\texttt{\texttt{\symbol{92}}+ (maps)}}
\label{+ (maps)}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the sum \mbox{\texttt{\slshape f+g}} of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}.



The functions checks if the maps have the same source and the same range, and
returns an error message otherwise. }

 

\subsection{\textcolor{Chapter }{\texttt{\symbol{92}}* (maps)}}
\logpage{[ 7, 2, 10 ]}\nobreak
\hyperdef{L}{X7E8438F77ECB778E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{\texttt{\symbol{92}}* (maps)({\slshape f, g})\index{* (maps)@\texttt{\texttt{\symbol{92}}* (maps)}}
\label{* (maps)}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the composition \mbox{\texttt{\slshape fg}} of the maps \mbox{\texttt{\slshape f}} and \mbox{\texttt{\slshape g}}, if the input are maps between representations of the same quivers. If \mbox{\texttt{\slshape f}} or \mbox{\texttt{\slshape g}} is a scalar, it returns the natural action of scalars on the maps between
representations.



The functions checks if the maps are composable, in the first case and in the
second case it checks if the scalar is in the correct field, and returns an
error message otherwise. }

 

\subsection{\textcolor{Chapter }{IsOneToOne}}
\logpage{[ 7, 2, 11 ]}\nobreak
\hyperdef{L}{X7918D18A7AB257EE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsOneToOne({\slshape f})\index{IsOneToOne@\texttt{IsOneToOne}}
\label{IsOneToOne}
}\hfill{\scriptsize (attribute)}}\\


 This returns \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is one-to-one. }

 

\subsection{\textcolor{Chapter }{IsOnto}}
\logpage{[ 7, 2, 12 ]}\nobreak
\hyperdef{L}{X81612A8E86D37A94}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsOnto({\slshape f})\index{IsOnto@\texttt{IsOnto}}
\label{IsOnto}
}\hfill{\scriptsize (attribute)}}\\


 This returns \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is onto. }

 

\subsection{\textcolor{Chapter }{IsIsom}}
\logpage{[ 7, 2, 13 ]}\nobreak
\hyperdef{L}{X860BF6DA791315D2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsIsom({\slshape f})\index{IsIsom@\texttt{IsIsom}}
\label{IsIsom}
}\hfill{\scriptsize (attribute)}}\\


 This returns \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is an isomorphism. }

 

\subsection{\textcolor{Chapter }{IsZeroMap}}
\logpage{[ 7, 2, 14 ]}\nobreak
\hyperdef{L}{X784852E07D3D1E0D}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsZeroMap({\slshape f})\index{IsZeroMap@\texttt{IsZeroMap}}
\label{IsZeroMap}
}\hfill{\scriptsize (attribute)}}\\


 This returns \texttt{true} if the homomorphism \mbox{\texttt{\slshape f}} is zero homomorphism. }

 

\subsection{\textcolor{Chapter }{KernelOfWhat}}
\logpage{[ 7, 2, 15 ]}\nobreak
\hyperdef{L}{X7EF520F67BA7F082}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KernelOfWhat({\slshape f})\index{KernelOfWhat@\texttt{KernelOfWhat}}
\label{KernelOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 If the homomorphism \mbox{\texttt{\slshape f}} has been computed as the kernel of an other homomorphism \mbox{\texttt{\slshape g}}, then \mbox{\texttt{\slshape g}} is returned. }

 

\subsection{\textcolor{Chapter }{ImageOfWhat}}
\logpage{[ 7, 2, 16 ]}\nobreak
\hyperdef{L}{X78EE24857C79789E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImageOfWhat({\slshape f})\index{ImageOfWhat@\texttt{ImageOfWhat}}
\label{ImageOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 If the homomorphism \mbox{\texttt{\slshape f}} has been computed as the image projection or image inclusion of an other
homomorphism \mbox{\texttt{\slshape g}}, then \mbox{\texttt{\slshape g}} is returned. }

 

\subsection{\textcolor{Chapter }{CoKernelOfWhat}}
\logpage{[ 7, 2, 17 ]}\nobreak
\hyperdef{L}{X7F6E2378786AC02A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CoKernelOfWhat({\slshape f})\index{CoKernelOfWhat@\texttt{CoKernelOfWhat}}
\label{CoKernelOfWhat}
}\hfill{\scriptsize (attribute)}}\\


 If the homomorphism \mbox{\texttt{\slshape f}} has been computed as the cokernel of an other homomorphism \mbox{\texttt{\slshape g}}, then \mbox{\texttt{\slshape g}} is returned. }

 }

 
\section{\textcolor{Chapter }{Homomorphisms and modules constructed from homomorphisms and modules}}\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X7E8D1A3F7C03CFF1}{}
{
 

\subsection{\textcolor{Chapter }{Ker}}
\logpage{[ 7, 3, 1 ]}\nobreak
\hyperdef{L}{X875B49CA80228AC9}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Ker({\slshape f})\index{Ker@\texttt{Ker}}
\label{Ker}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{KerInclusion({\slshape M})\index{KerInclusion@\texttt{KerInclusion}}
\label{KerInclusion}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the kernel of a homomorphism \mbox{\texttt{\slshape f}} between two representations of a quiver.



 The first variant \texttt{Ker} returns the kernel of the homomorphism \mbox{\texttt{\slshape f}} as a representation of the quiver, while the latter one returns the inclusion
homomorphism of the kernel into the source of the homomorphism \mbox{\texttt{\slshape f}}. }

 

\subsection{\textcolor{Chapter }{Im}}
\logpage{[ 7, 3, 2 ]}\nobreak
\hyperdef{L}{X7E2D2D80781D3D91}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Im({\slshape f})\index{Im@\texttt{Im}}
\label{Im}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImProjection({\slshape f})\index{ImProjection@\texttt{ImProjection}}
\label{ImProjection}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImInclusion({\slshape })\index{ImInclusion@\texttt{ImInclusion}}
\label{ImInclusion}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{ImProjectionInclusion({\slshape })\index{ImProjectionInclusion@\texttt{ImProjectionInclusion}}
\label{ImProjectionInclusion}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the image of a homomorphism \mbox{\texttt{\slshape f}} between two representations of a quiver.



 The first variant \texttt{Im} returns the image of the homomorphism \mbox{\texttt{\slshape f}} as a representation of the quiver. The second returns the projection from the
source of \mbox{\texttt{\slshape f}} to the image into the source of the homomorphism \mbox{\texttt{\slshape f}}. The third returns the inclusion of the image into the range of the
homomorphism \mbox{\texttt{\slshape f}}. The last one returns both the projection and the inclusion. }

 

\subsection{\textcolor{Chapter }{Coker}}
\logpage{[ 7, 3, 3 ]}\nobreak
\hyperdef{L}{X82386871781E4113}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Coker({\slshape f})\index{Coker@\texttt{Coker}}
\label{Coker}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CokerProjection({\slshape f})\index{CokerProjection@\texttt{CokerProjection}}
\label{CokerProjection}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the cokernel of a homomorphism \mbox{\texttt{\slshape f}} between two representations of a quiver.



 The first variant \texttt{Coker} returns the cokernel of the homomorphism \mbox{\texttt{\slshape f}} as a representation of the quiver, while the latter one returns the projection
homomorphism from the range of the homomorphism \mbox{\texttt{\slshape f}} to the cokernel of the homomorphism \mbox{\texttt{\slshape f}}. }

 

\subsection{\textcolor{Chapter }{SubRepInclusion}}
\logpage{[ 7, 3, 4 ]}\nobreak
\hyperdef{L}{X78E1E77C82F97B42}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SubRepInclusion({\slshape M, gens})\index{SubRepInclusion@\texttt{SubRepInclusion}}
\label{SubRepInclusion}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the inclusion of the submodule generated by the generators \mbox{\texttt{\slshape gens}} into the module \mbox{\texttt{\slshape M}}



 The function checks if \mbox{\texttt{\slshape gens}} are elements in \mbox{\texttt{\slshape M}}, and returns an error message otherwise. The representation given by the
submodule generated by the generators \mbox{\texttt{\slshape gens}} can be accessed using \texttt{Source}. }

 

\subsection{\textcolor{Chapter }{RadicalOfRepInclusion}}
\logpage{[ 7, 3, 5 ]}\nobreak
\hyperdef{L}{X7DCDCB088064BA30}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{RadicalOfRepInclusion({\slshape M})\index{RadicalOfRepInclusion@\texttt{RadicalOfRepInclusion}}
\label{RadicalOfRepInclusion}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the inclusion of the radical of the module \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}.



 The representation given by the submodule generated by the generators \mbox{\texttt{\slshape gens}} can be accessed using \texttt{Source}. }

 

\subsection{\textcolor{Chapter }{SocleOfPathAlgebraMatModuleInclusion}}
\logpage{[ 7, 3, 6 ]}\nobreak
\hyperdef{L}{X830578BB804B6752}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SocleOfPathAlgebraMatModuleInclusion({\slshape M})\index{SocleOfPathAlgebraMatModuleInclusion@\texttt{SocleOfPathAlgebraMatModuleInclusion}}
\label{SocleOfPathAlgebraMatModuleInclusion}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the inclusion of the socle of the module \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}.



 The representation given by the socle of \mbox{\texttt{\slshape M}} can be accessed using \texttt{Source}, or it can be computed directly via the command \texttt{SocleOfPathAlgebraMatModule} (\ref{SocleOfPathAlgebraMatModule}). }

 

\subsection{\textcolor{Chapter }{TopOfRepProjection}}
\logpage{[ 7, 3, 7 ]}\nobreak
\hyperdef{L}{X7C74AA0679E85F60}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{TopOfRepProjection({\slshape M})\index{TopOfRepProjection@\texttt{TopOfRepProjection}}
\label{TopOfRepProjection}
}\hfill{\scriptsize (operation)}}\\
\textbf{\indent Returns:\ }
the projection from the module \mbox{\texttt{\slshape M}} to the top of the module \mbox{\texttt{\slshape M}} into \mbox{\texttt{\slshape M}}.



 The representation given by the top of the module \mbox{\texttt{\slshape M}} can be accessed using \texttt{Range} of the homomorphism. }

 }

 }

 

\appendix


\chapter{\textcolor{Chapter }{An Appendix}}\label{Appendix}
\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X7B53252784137533}{}
{
  \label{ElevenBack} This is an appendix. }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
