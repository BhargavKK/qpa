<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (QPA documentation) - Chapter 3: Path Algebras</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap4.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X7E8A43A484CE0BA8" name="X7E8A43A484CE0BA8"></a></p>
<div class="ChapSects"><a href="chap3.html#X7E8A43A484CE0BA8">3 <span class="Heading">Path Algebras</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7DFB63A97E67C0A1">3.1 <span class="Heading">Introduction</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C19179882715B18">3.1-1 InfoPathAlgebra</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X848A225A84A15B1E">3.2 <span class="Heading">Constructing Path Algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7CA1C87B8202C2E9">3.2-1 PathAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83E498008233E2DD">3.2-2 OrderedBy</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X85A3A8767E7C11AD">3.3 <span class="Heading">Categories and Properties of Path Algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8255FDF78315E1B3">3.3-1 IsPathAlgebra</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7DE2F2A48492041A">3.4 <span class="Heading">Attributes and Operations for Path Algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X83FBA499856580B0">3.4-1 QuiverOfPathAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7821AC097821AC09">3.4-2 .</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7CEF60107CE4616B">3.5 <span class="Heading">Operations on Path Algebra Elements</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X871A3B1D871A3B1D">3.5-1 &lt;</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84C98E687A3A84D8">3.5-2 LeadingTerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80710E9B7D8340BD">3.5-3 LeadingCoefficient</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B3EAE41795598A5">3.5-4 LeadingMonomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X853C8B0B8665BFBB">3.5-5 IsLeftUniform</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C06BE7483992634">3.5-6 IsRightUniform</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8735FBE180797557">3.5-7 IsUniform</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8172B40181E1B7D2">3.5-8 MakeUniformOnRight</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X796249A682818750">3.5-9 MappedExpression</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7F0D555379C97A6E">3.6 <span class="Heading">Constructing Quotients of Path Algebras</span></a>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X83629803819C4A6F">3.7 <span class="Heading">Ideals</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X812C0F8D7E4B1134">3.7-1 <span class="Heading">Ideals and operations
    on ideals</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82ACACDD7D8E9B25">3.7-2 Ideal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X830187497E0BD4F0">3.7-3 nthPowerOfArrowIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X824D550E8371098C">3.7-4 AddNthPowerToRelations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X85D4E72B787B1C49">3.7-5 <span class="Heading">Attributes of ideals</span></a>
</span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A3CA333873389AD">3.8 <span class="Heading">Categories and Properties of Quotients of Path Algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X78476A128036573F">3.8-1 IsSubalgebraFpPathAlgebra</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X86647D317A961513">3.9 <span class="Heading">Attributes and Operations for Quotients of Path
    Algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X826641507CFBE943">3.9-1 NormalFormFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X815D8565802928FE">3.9-2 IsElementOfFpPathAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80B32F667BF6AFD8">3.9-3 Coefficients</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D96F5437F867D00">3.9-4 IsSelfinjective</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BEA44FB819910B6">3.9-5 LoewyLength</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84E3FEF587CB66C3">3.9-6 CartanMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X815CB1D47CB174ED">3.9-7 CoxeterMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F6F526C86052150">3.9-8 CoxeterPolynomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E403A8855F6F7A">3.9-9 Centre/Center</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BD7DB497917893C">3.10 <span class="Heading">Attributes and Operations on Elements
of Quotients of Path Algebra</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8271E6F27C2C826E">3.10-1 IsNormalForm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X871A3B1D871A3B1D">3.10-2 &lt;</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X868C9F9981388DAA">3.10-3 ElementOfFpPathAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8088721187BA8D82">3.10-4 OriginalPathAlgebra</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X7E7FA56079CF78D1">3.11 <span class="Heading">Predefined classes
  of quotient of path algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7C678A08836F77CC">3.11-1 NakayamaAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EF1AE62790D7486">3.11-2 TruncatedPathAlgebra</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap3.html#X842527EC7F90C8C5">3.12 <span class="Heading">Tensor products of path algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X835BBBE18104654A">3.12-1 QuiverProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X858517C18242C2F1">3.12-2 QuiverProductDecomposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E3731882B80106">3.12-3 IsQuiverProductDecomposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X856E8B5B7F550647">3.12-4 IncludeInProductQuiver</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8455692C7E282C6C">3.12-5 ProjectFromProductQuiver</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A9026937BDDFA6C">3.12-6 TensorProductOfAlgebras</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B31F4F680135E72">3.12-7 SimpleTensor</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F0EBF88866A537D">3.12-8 TensorProductDecomposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X820195C47E2BE7E0">3.12-9 EnvelopingAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AE13B567B5F72FC">3.12-10 IsEnvelopingAlgebra</a></span>
</div>
</div>

<h3>3 <span class="Heading">Path Algebras</span></h3>

<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>

<h4>3.1 <span class="Heading">Introduction</span></h4>

<p>A path algebra is an algebra constructed from a field $F$ and a quiver $Q$. The path algebra $FQ$ contains all finite linear combinations of elements of $Q$. This chapter describes the functions in <strong class="pkg">QPA</strong> that deal with path algebras and quotients of path algebras. Path algebras are algebras so see Chapter "ref:algebras" for functionality such as generators, basis functions, and mappings.</p>

<p><a id="X7C19179882715B18" name="X7C19179882715B18"></a></p>

<h5>3.1-1 InfoPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InfoPathAlgebra</code></td><td class="tdright">( info class )</td></tr></table></div>
<p>is the info class for functions dealing with path algebras.</p>

<p><a id="X848A225A84A15B1E" name="X848A225A84A15B1E"></a></p>

<h4>3.2 <span class="Heading">Constructing Path Algebras</span></h4>

<p><a id="X7CA1C87B8202C2E9" name="X7CA1C87B8202C2E9"></a></p>

<h5>3.2-1 PathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PathAlgebra</code>( <var class="Arg">F, Q</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>the path algebra $FG$ of <var class="Arg">Q</var> over the field <var class="Arg">F</var>.</p>


<table class="example">
<tr><td><pre> 
gap&gt; q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; f := FiniteField(23);
GF(23)
gap&gt; fq := PathAlgebra(f,q);
&lt;algebra-with-one over GF(23), with 6 generators&gt;
</pre></td></tr></table>

<p>\* NO: the FOLLOWING is not true:</p>

<p><a id="X83E498008233E2DD" name="X83E498008233E2DD"></a></p>

<h5>3.2-2 OrderedBy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; OrderedBy</code>( <var class="Arg">path, algebra, ordering</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a copy of <var class="Arg">path algebra</var> whose elements are ordered by <var class="Arg">ordering</var>. See Section <a href="chap2.html#X78BBB63B828EB9FB"><b>2.4</b></a> for more information on orderings.</p>

<p><a id="X85A3A8767E7C11AD" name="X85A3A8767E7C11AD"></a></p>

<h4>3.3 <span class="Heading">Categories and Properties of Path Algebras</span></h4>

<p><a id="X8255FDF78315E1B3" name="X8255FDF78315E1B3"></a></p>

<h5>3.3-1 IsPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsPathAlgebra</code>( <var class="Arg">object</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>is true when <var class="Arg">object</var> is a path algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; IsPathAlgebra(fq);
true
gap&gt; IsPathAlgebra(q);
false
</pre></td></tr></table>

<p><a id="X7DE2F2A48492041A" name="X7DE2F2A48492041A"></a></p>

<h4>3.4 <span class="Heading">Attributes and Operations for Path Algebras</span></h4>

<p><a id="X83FBA499856580B0" name="X83FBA499856580B0"></a></p>

<h5>3.4-1 QuiverOfPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuiverOfPathAlgebra</code>( <var class="Arg">object</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>An attribute. Returns the quiver from which <var class="Arg">object</var> was constructed.</p>


<table class="example">
<tr><td><pre>
gap&gt; QuiverOfPathAlgebra(fq);
&lt;quiver with 2 vertices and 4 arrows&gt;
</pre></td></tr></table>

<p><a id="X7821AC097821AC09" name="X7821AC097821AC09"></a></p>

<h5>3.4-2 .</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; .</code>( <var class="Arg">FQ, element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">.</code> operates on a path algebra <var class="Arg">FQ</var> and an element <var class="Arg">element</var>, which is a vertex or an arrow in the quiver Q. It returns the generator as an element of the path algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; fq.v;
(Z(23)^0)*v
gap&gt; fq.b;
(Z(23)^0)*b
</pre></td></tr></table>

<p>&gt;OrderingOfAlgebra( <var class="Arg">path algebra</var> ) returns the ordering of the quiver of the path algebra.</p>

<p><a id="X7CEF60107CE4616B" name="X7CEF60107CE4616B"></a></p>

<h4>3.5 <span class="Heading">Operations on Path Algebra Elements</span></h4>

<p><a id="X871A3B1D871A3B1D" name="X871A3B1D871A3B1D"></a></p>

<h5>3.5-1 &lt;</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; &lt;</code>( <var class="Arg">a, b</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">&lt;</code> operates on elements <var class="Arg">a</var> and <var class="Arg">b</var> of a path algebra $FQ$, and they are compared using the ordering for the path algebra. See Section <a href="chap2.html#X78BBB63B828EB9FB"><b>2.4</b></a> for more information on orderings.</p>

<p><a id="X84C98E687A3A84D8" name="X84C98E687A3A84D8"></a></p>

<h5>3.5-2 LeadingTerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LeadingTerm</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Tip</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">LeadingTerm</code> or equivalently <code class="func">Tip</code> operates on an <var class="Arg">x</var> in a path algebra, and it returns is the term in <var class="Arg">element</var> whose monomial is largest among those monomials that have nonzero coefficients; this term is known as the *tip* of <var class="Arg">element</var>.</p>

<p><a id="X80710E9B7D8340BD" name="X80710E9B7D8340BD"></a></p>

<h5>3.5-3 LeadingCoefficient</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LeadingCoefficient</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TipCoefficient</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">LeadingCoefficient</code> or equivalently <code class="func">TipCoefficient</code> operates on an <var class="Arg">element</var> in a path algebra, and it returns the coefficient of the tip of <var class="Arg">element</var>. This is an element of the field.</p>

<p><a id="X7B3EAE41795598A5" name="X7B3EAE41795598A5"></a></p>

<h5>3.5-4 LeadingMonomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LeadingMonomial</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TipMonomial</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">LeadingMonomial</code> or equivalently <code class="func">TipMonomial</code> operates on an <var class="Arg">element</var> in a path algebra, and it returns the monomial of the tip of <var class="Arg">element</var>; it is the largest monomial occurring in <var class="Arg">element</var> with a nonzero coefficient. This is an element of the underlying quiver, not of the path algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; elem := fq.a*fq.b*fq.c + fq.b*fq.d*fq.c+fq.d*fq.d;
(Z(23)^0)*d^2+(Z(23)^0)*a*b*c+(Z(23)^0)*b*d*c
gap&gt; LeadingTerm(elem);
(Z(23)^0)*b*d*c
gap&gt; LeadingCoefficient(elem);
Z(23)^0
gap&gt; LeadingMonomial(elem);
b*d*c
</pre></td></tr></table>

<p><a id="X853C8B0B8665BFBB" name="X853C8B0B8665BFBB"></a></p>

<h5>3.5-5 IsLeftUniform</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLeftUniform</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">IsLeftUniform</code> operates on an <var class="Arg">element</var> in a path algebra, and it returns true if each monomial in <var class="Arg">element</var> has the same source vertex.</p>

<p><a id="X7C06BE7483992634" name="X7C06BE7483992634"></a></p>

<h5>3.5-6 IsRightUniform</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsRightUniform</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">IsRightUniform</code> operates on an <var class="Arg">element</var> in a path algebra, and it returns true if each monomial in <var class="Arg">element</var> has the same target vertex.</p>

<p><a id="X8735FBE180797557" name="X8735FBE180797557"></a></p>

<h5>3.5-7 IsUniform</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsUniform</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">IsUniform</code> operates on an <var class="Arg">element</var> in a path algebra, and it returns true if each monomial in <var class="Arg">element</var> has both the same source vertex and the same target vertex.</p>

<p><a id="X8172B40181E1B7D2" name="X8172B40181E1B7D2"></a></p>

<h5>3.5-8 MakeUniformOnRight</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MakeUniformOnRight</code>( <var class="Arg">elems</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">MakeUniformOnRight</code> operates on a list <var class="Arg">elems</var> of elements in a path algebra, and it returns a list of right uniform elements generated by each element of <var class="Arg">elems</var>.</p>


<table class="example">
<tr><td><pre>
gap&gt; IsLeftUniform(elem);
false
gap&gt; IsRightUniform(elem);
false
gap&gt; IsUniform(elem);
false
gap&gt; another := fq.a*fq.b + fq.b*fq.d*fq.c*fq.b*fq.d;
(Z(23)^0)*a*b+(Z(23)^0)*b*d*c*b*d
gap&gt; IsLeftUniform(another);
true
gap&gt; IsRightUniform(another);
true
gap&gt; IsUniform(another);
true
</pre></td></tr></table>

<p><a id="X796249A682818750" name="X796249A682818750"></a></p>

<h5>3.5-9 MappedExpression</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MappedExpression</code>( <var class="Arg">expr, gens1, gens2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">MappedExpression</code> operates on <var class="Arg">expr</var> from a path algebra and and two equal-length lists of generators <var class="Arg">gens1</var> and <var class="Arg">gens2</var> for subalgebras. The <var class="Arg">expr</var> must be in the subalgebra generated by <var class="Arg">gens1</var>. The lists define a mapping of each generator in <var class="Arg">gens1</var> to the corresponding generator in <var class="Arg">gens2</var>. The value returned is the evaluation of the mapping at <var class="Arg">expr</var>.</p>

<p><a id="X7F0D555379C97A6E" name="X7F0D555379C97A6E"></a></p>

<h4>3.6 <span class="Heading">Constructing Quotients of Path Algebras</span></h4>

<p>See Chapter "ref:algebras" on how to construct an ideal and a quotient of an algebra. When the quotient is constructed, it is still a path algebra and thus the same commands may be used with quotients. Also since a quotient is still an algebra, refer to "ref:algebras".</p>


<table class="example">
<tr><td><pre>
gap&gt; I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);
&lt;two-sided ideal in &lt;algebra-with-one over GF(23), with 6 generators&gt;,
  (2 generators)&gt;
gap&gt; GeneratorsOfIdeal(I);
[ (Z(23)^0)*a*b, (Z(23)^11)*b*c+(Z(23)^0)*d^2 ]
gap&gt; quot := fq/I;
&lt;algebra-with-one over GF(23), with 6 generators&gt;
</pre></td></tr></table>

<p><a id="X83629803819C4A6F" name="X83629803819C4A6F"></a></p>

<h4>3.7 <span class="Heading">Ideals</span></h4>

<p><a id="X812C0F8D7E4B1134" name="X812C0F8D7E4B1134"></a></p>

<h5>3.7-1 <span class="Heading">Ideals and operations
    on ideals</span></h5>

<p><a id="X82ACACDD7D8E9B25" name="X82ACACDD7D8E9B25"></a></p>

<h5>3.7-2 Ideal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Ideal</code>( <var class="Arg">KQ, elems</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">Ideal</code> defines the ideal generated by <var class="Arg">elems</var> in the path algebra <var class="Arg">KQ</var> (See Ideals in the reference manual of GAP).</p>

<p><a id="X830187497E0BD4F0" name="X830187497E0BD4F0"></a></p>

<h5>3.7-3 nthPowerOfArrowIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; nthPowerOfArrowIdeal</code>( <var class="Arg">KQ, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">nthPowerOfArrowIdeal</code> defines the ideal generated all the paths of length <var class="Arg">n</var> in the path algebra <var class="Arg">KQ</var>.</p>

<p><a id="X824D550E8371098C" name="X824D550E8371098C"></a></p>

<h5>3.7-4 AddNthPowerToRelations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AddNthPowerToRelations</code>( <var class="Arg">KQ, rels, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">AddNthPowerToRelations</code> append the list <var class="Arg">rels</var> the paths of length <var class="Arg">n</var> in the path algebra <var class="Arg">KQ</var>. The object <var class="Arg">rels</var> must be a list of elements in the path algebra <var class="Arg">KQ</var>, and <var class="Arg">n</var> must be a positive integer.</p>

<p><a id="X85D4E72B787B1C49" name="X85D4E72B787B1C49"></a></p>

<h5>3.7-5 <span class="Heading">Attributes of ideals</span></h5>

<p>Groebner Basis Of an Ideal: For many of the functions related to quotients, you will need to compute a Groebner basis of the ideal. Refer to the chapters "qpa:groebner basis" and "qpa:using opal with gap" to learn more.</p>


<table class="example">
<tr><td><pre>
gap&gt; J := Ideal(fq,[fq.a*fq.b]);
&lt;two-sided ideal in &lt;algebra-with-one over GF(23), with 6 generators&gt;,
  (1 generators)&gt;
gap&gt; anotherquot := fq/J;
&lt;algebra-with-one over GF(23), with 6 generators&gt;
gap&gt; gb := GroebnerBasis(J,[fq.a*fq.b]);
&lt;complete two-sided Groebner basis containing 1 elements&gt;
gap&gt; SetIsCompleteGroebnerBasis(gb, true);
gap&gt; IsCompleteGroebnerBasis(gb);
true
gap&gt; gb = GroebnerBasisOfIdeal(J);
true
</pre></td></tr></table>

<p><a id="X7A3CA333873389AD" name="X7A3CA333873389AD"></a></p>

<h4>3.8 <span class="Heading">Categories and Properties of Quotients of Path Algebras</span></h4>

<p><a id="X78476A128036573F" name="X78476A128036573F"></a></p>

<h5>3.8-1 IsSubalgebraFpPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSubalgebraFpPathAlgebra</code>( <var class="Arg">object</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>is true when <var class="Arg">object</var> is a quotient of a path algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; IsSubalgebraFpPathAlgebra(quot);
true
gap&gt; IsSubalgebraFpPathAlgebra(fq);
false
</pre></td></tr></table>

<p><a id="X86647D317A961513" name="X86647D317A961513"></a></p>

<h4>3.9 <span class="Heading">Attributes and Operations for Quotients of Path
    Algebras</span></h4>

<p><a id="X826641507CFBE943" name="X826641507CFBE943"></a></p>

<h5>3.9-1 NormalFormFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NormalFormFunction</code>( <var class="Arg">object</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>is a function that can compute normal forms for elements of <var class="Arg">object</var>. It may be supplied by the user.</p>

<p><a id="X815D8565802928FE" name="X815D8565802928FE"></a></p>

<h5>3.9-2 IsElementOfFpPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsElementOfFpPathAlgebra</code>( <var class="Arg">object</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>is true if <var class="Arg">object</var> is an element of some quotient of a path algebra.</p>


<table class="example">
<tr><td><pre>
gap&gt; this := anotherquot.a*anotherquot.b;
[(Z(23)^0)*a*b]
gap&gt; IsElementOfFpPathAlgebra(this);
true
gap&gt; IsElementOfFpPathAlgebra(fq);
false
</pre></td></tr></table>

<p><a id="X80B32F667BF6AFD8" name="X80B32F667BF6AFD8"></a></p>

<h5>3.9-3 Coefficients</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Coefficients</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">Coefficients</code> operates on an <var class="Arg">element</var> of a quotient of a path algebra, and it returns the coefficients of the <var class="Arg">element</var> in terms of its canonical basis. Question: Does this only take one argument?</p>

<p><a id="X7D96F5437F867D00" name="X7D96F5437F867D00"></a></p>

<h5>3.9-4 IsSelfinjective</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSelfinjective</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The function checks if the algebra <var class="Arg">A</var> is finite dimensional (not implemented yet), and returns true or false accorgin to whether <var class="Arg">A</var> is selfinjective or not.</p>

<p><a id="X7BEA44FB819910B6" name="X7BEA44FB819910B6"></a></p>

<h5>3.9-5 LoewyLength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LoewyLength</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The function returns the Loewy length of the algebra <var class="Arg">A</var>, after having checked that <var class="Arg">A</var> is a finite dimensional quotient of a path algebra.</p>

<p><a id="X84E3FEF587CB66C3" name="X84E3FEF587CB66C3"></a></p>

<h5>3.9-6 CartanMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CartanMatrix</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function returns the Cartan matrix of the algebra <var class="Arg">A</var>, after having checked that <var class="Arg">A</var> is a finite dimensional quotient of a path algebra.</p>

<p><a id="X815CB1D47CB174ED" name="X815CB1D47CB174ED"></a></p>

<h5>3.9-7 CoxeterMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CoxeterMatrix</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function returns the Coxeter matrix of the algebra <var class="Arg">A</var>, after having checked that <var class="Arg">A</var> is a finite dimensional quotient of a path algebra.</p>

<p><a id="X7F6F526C86052150" name="X7F6F526C86052150"></a></p>

<h5>3.9-8 CoxeterPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CoxeterPolynomial</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function returns the Coxeter polynomial of the algebra <var class="Arg">A</var>, after having checked that <var class="Arg">A</var> is a finite dimensional quotient of a path algebra.</p>

<p><a id="X80E403A8855F6F7A" name="X80E403A8855F6F7A"></a></p>

<h5>3.9-9 Centre/Center</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Centre/Center</code>( <var class="Arg">A</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function returns the centre of the algebra <var class="Arg">A</var>, after having checked that <var class="Arg">A</var> is a finite dimensional quotient of a path algebra (the check is not implemented and also not implemented for path algebras).</p>

<p><a id="X7BD7DB497917893C" name="X7BD7DB497917893C"></a></p>

<h4>3.10 <span class="Heading">Attributes and Operations on Elements
of Quotients of Path Algebra</span></h4>

<p><a id="X8271E6F27C2C826E" name="X8271E6F27C2C826E"></a></p>

<h5>3.10-1 IsNormalForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsNormalForm</code>( <var class="Arg">element</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">IsNormalForm</code> operates on an <var class="Arg">element</var> from a path algebra, and it is true if <var class="Arg">element</var> is known to be in normal form.</p>


<table class="example">
<tr><td><pre>
gap&gt; IsNormalForm(this); 
false
</pre></td></tr></table>

<p><a id="X871A3B1D871A3B1D" name="X871A3B1D871A3B1D"></a></p>

<h5>3.10-2 &lt;</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; &lt;</code>( <var class="Arg">a, b</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">&lt;</code> operates on two elements <var class="Arg">a</var> and <var class="Arg">b</var> from a path algebra $FQ$, and it compares them using the ordering for the path algebra.</p>

<p><a id="X868C9F9981388DAA" name="X868C9F9981388DAA"></a></p>

<h5>3.10-3 ElementOfFpPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ElementOfFpPathAlgebra</code>( <var class="Arg">family, element, computenormal</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">ElementOfFpPathAlgebra</code> operates on an <var class="Arg">element</var> in a path algebra, and it projects it into the quotient given by <var class="Arg">family</var>. If <var class="Arg">computenormal</var> is true, then the normal form of the projection of <var class="Arg">element</var> is returned.</p>

<p><a id="X8088721187BA8D82" name="X8088721187BA8D82"></a></p>

<h5>3.10-4 OriginalPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; OriginalPathAlgebra</code>( <var class="Arg">algebra</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">OriginalPathAlgebra</code> operates on an <var class="Arg">algebra</var>. If it is a quotient of a path algebra or just a path algebra itself, it returns the path algebra it was constructed from. Otherwise it returns an error saying that the algebra entered was not a quotient of a path algebra.</p>

<p><a id="X7E7FA56079CF78D1" name="X7E7FA56079CF78D1"></a></p>

<h4>3.11 <span class="Heading">Predefined classes
  of quotient of path algebras</span></h4>

<p><a id="X7C678A08836F77CC" name="X7C678A08836F77CC"></a></p>

<h5>3.11-1 NakayamaAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NakayamaAlgebra</code>( <var class="Arg">admiss-seq, field</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>the Nakayama algebra corresponding to the addmissible sequence <var class="Arg">admiss-seq</var> over the field <var class="Arg">field</var>, or <code class="keyw">the admissible sequence entered</code> if entered sequence is not an admissible sequence.</p>

<p>This function creates a Nakayama algebra from an admissible sequence over a field.</p>

<p><a id="X7EF1AE62790D7486" name="X7EF1AE62790D7486"></a></p>

<h5>3.11-2 TruncatedPathAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TruncatedPathAlgebra</code>( <var class="Arg">K, Q, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>the truncated path algebra <var class="Arg">KQ/I</var>, where <var class="Arg">I</var> is the ideal generated by all paths of length <var class="Arg">n</var> in <var class="Arg">KQ</var>. The object <var class="Arg">K</var> must be a field, <var class="Arg">Q</var> a quiver and <var class="Arg">n</var> a positive integer.</p>

<p><a id="X842527EC7F90C8C5" name="X842527EC7F90C8C5"></a></p>

<h4>3.12 <span class="Heading">Tensor products of path algebras</span></h4>

<p>If Lambda and Gamma are quotients of path algebras over the same field F, then their tensor product Lambda tensor_F Gamma is also a quotient of a path algebra over F.</p>

<p>The quiver for the tensor product path algebra is the <code class="func">QuiverProduct</code> (<a href="chap3.html#X835BBBE18104654A"><b>3.12-1</b></a>) of the quivers of the original algebras.</p>

<p>The operation <code class="func">TensorProductOfAlgebras</code> (<a href="chap3.html#X7A9026937BDDFA6C"><b>3.12-6</b></a>) computes the tensor products of two quotients of path algebras as a quotient of a path algebra.</p>

<p><a id="X835BBBE18104654A" name="X835BBBE18104654A"></a></p>

<h5>3.12-1 QuiverProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuiverProduct</code>( <var class="Arg">Q1, Q2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Creates the product quiver <var class="Arg">Q1</var> quiverproduct <var class="Arg">Q2</var>. A vertex in <var class="Arg">Q1</var> quiverproduct <var class="Arg">Q2</var> which is made by combining a vertex named <code class="code">u</code> in <var class="Arg">Q1</var> with a vertex <code class="code">v</code> in <var class="Arg">Q2</var> is named <code class="code">u_v</code>. Arrows are named similarly (they are made by combining an arrow from one quiver with a vertex from the other).</p>

<p><a id="X858517C18242C2F1" name="X858517C18242C2F1"></a></p>

<h5>3.12-2 QuiverProductDecomposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; QuiverProductDecomposition</code>( <var class="Arg">Q</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Contains the original quivers <var class="Arg">Q</var> is a product of, if <var class="Arg">Q</var> was created by the <code class="func">QuiverProduct</code> (<a href="chap3.html#X835BBBE18104654A"><b>3.12-1</b></a>) operation. The value of this attribute is an object in the category <code class="func">IsQuiverProductDecomposition</code> (<a href="chap3.html#X80E3731882B80106"><b>3.12-3</b></a>).</p>

<p><a id="X80E3731882B80106" name="X80E3731882B80106"></a></p>

<h5>3.12-3 IsQuiverProductDecomposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsQuiverProductDecomposition</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>Category for objects containing information about the relation between a product quiver and the quivers it is a product of. The quiver factors can be extracted from the decomposition object by using the [] notation (like accessing elements of a list). The decomposition object is also used by the operations <code class="func">IncludeInProductQuiver</code> (<a href="chap3.html#X856E8B5B7F550647"><b>3.12-4</b></a>) and <code class="func">ProjectFromProductQuiver</code> (<a href="chap3.html#X8455692C7E282C6C"><b>3.12-5</b></a>).</p>

<p><a id="X856E8B5B7F550647" name="X856E8B5B7F550647"></a></p>

<h5>3.12-4 IncludeInProductQuiver</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IncludeInProductQuiver</code>( <var class="Arg">L, Q</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Includes paths q_1 and q_2 from two quivers into the product of these quivers. If at least one of q_1 and q_2 is a vertex, there is exactly one possible inclusion. If they are both non-trivial paths, there are several possibilities. This operation constructs the path which is the inclusion of q_1 at the source of q_2 multiplied with the inclusion of q_2 at the target of q_1.</p>

<p>The argument <var class="Arg">L</var> is a list containing the paths q_1 and q_2 to be included; Q is the product quiver to include them in.</p>

<p><a id="X8455692C7E282C6C" name="X8455692C7E282C6C"></a></p>

<h5>3.12-5 ProjectFromProductQuiver</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ProjectFromProductQuiver</code>( <var class="Arg">i, p</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns the projection of the product quiver path <var class="Arg">p</var> to one of the factors. Which factor it should be projected to is specified by the argument <var class="Arg">i</var>.</p>

<p>The following example shows how the operations related to quiver products are used.</p>


<table class="example">
<tr><td><pre>
gap&gt; q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q2 := Quiver( [ "v1", "v2", "v3" ],
                      [ [ "v1", "v2", "b" ],
                        [ "v2", "v3", "c" ] ] );
&lt;quiver with 3 vertices and 2 arrows&gt;
gap&gt; q1_q2 := QuiverProduct( q1, q2 );
&lt;quiver with 6 vertices and 7 arrows&gt;
gap&gt; q1_q2.u1_b * q1_q2.a_v2;
u1_b*a_v2
gap&gt; IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );
a_v1*u2_b*u2_c
gap&gt; ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );
b*c
gap&gt; q1_q2_dec := QuiverProductDecomposition( q1_q2 );
&lt;object&gt;
gap&gt; q1_q2_dec[ 1 ];
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q1_q2_dec[ 1 ] = q1;
true
  </pre></td></tr></table>

<p><a id="X7A9026937BDDFA6C" name="X7A9026937BDDFA6C"></a></p>

<h5>3.12-6 TensorProductOfAlgebras</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TensorProductOfAlgebras</code>( <var class="Arg">FQ1, FQ2</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">TensorProductOfAlgebras</code> produces the tensor product of two (quotients of) path algebras <var class="Arg">FQ1</var> and <var class="Arg">FQ2</var>. The result is a quotient of a path algebra, whose quiver is the <code class="func">QuiverProduct</code> (<a href="chap3.html#X835BBBE18104654A"><b>3.12-1</b></a>) of the quivers of the operands.</p>

<p><a id="X7B31F4F680135E72" name="X7B31F4F680135E72"></a></p>

<h5>3.12-7 SimpleTensor</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SimpleTensor</code>( <var class="Arg">L, T</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>The operation <code class="func">SimpleTensor</code> produces a simple tensor x tensor y in the tensor product of two path algebras. The argument <var class="Arg">L</var> is a list containing the elements x and y. These should be elements of two (quotients of) path algebras, and <var class="Arg">T</var> the tensor product of these algebras (produced by <code class="func">TensorProductOfAlgebras</code> (<a href="chap3.html#X7A9026937BDDFA6C"><b>3.12-6</b></a>)).</p>

<p><a id="X7F0EBF88866A537D" name="X7F0EBF88866A537D"></a></p>

<h5>3.12-8 TensorProductDecomposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TensorProductDecomposition</code>( <var class="Arg">T</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For a tensor product of quotients of path algebras (produced by <code class="func">TensorProductOfAlgebras</code> (<a href="chap3.html#X7A9026937BDDFA6C"><b>3.12-6</b></a>)), this attribute contains a list of the factors in the tensor product.</p>

<p>The following example shows how the operations for tensor products of quotients of path algebras are used.</p>


<table class="example">
<tr><td><pre>
gap&gt; q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q2 := Quiver( [ "v1", "v2", "v3", "v4" ],
                      [ [ "v1", "v2", "b" ],
                        [ "v1", "v3", "c" ],
                        [ "v2", "v4", "d" ],
                        [ "v3", "v4", "e" ] ] );
&lt;quiver with 4 vertices and 4 arrows&gt;
gap&gt; fq1 := PathAlgebra( Rationals, q1 );
&lt;algebra-with-one over Rationals, with 3 generators&gt;
gap&gt; fq2 := PathAlgebra( Rationals, q2 );
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );
&lt;two-sided ideal in &lt;algebra-with-one over Rationals, with 8 generators&gt;,
 (1 generators)&gt;
gap&gt; quot := fq2 / I;
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; t := TensorProductOfAlgebras( fq1, quot );
&lt;algebra-with-one over Rationals, with 20 generators&gt;
gap&gt; SimpleTensor( [ fq1.a, quot.b ], t );
[(1)*a_v1*u2_b]
gap&gt; t_dec := TensorProductDecomposition( t );
[ &lt;algebra-with-one over Rationals, with 3 generators&gt;, 
  &lt;algebra-with-one over Rationals, with 8 generators&gt; ]
gap&gt; t_dec[ 1 ] = fq1;
true
  </pre></td></tr></table>

<p><a id="X820195C47E2BE7E0" name="X820195C47E2BE7E0"></a></p>

<h5>3.12-9 EnvelopingAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; EnvelopingAlgebra</code>( <var class="Arg">FQ</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Produces the enveloping algebra <var class="Arg">FQ</var>^e = <var class="Arg">FQ</var> tensor <var class="Arg">FQ</var>^op of <var class="Arg">FQ</var>, which should be (a quotient of) a path algebra.</p>

<p><a id="X7AE13B567B5F72FC" name="X7AE13B567B5F72FC"></a></p>

<h5>3.12-10 IsEnvelopingAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsEnvelopingAlgebra</code>( <var class="Arg">A</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>True if and only if <var class="Arg">A</var> is the result of a call to <code class="func">EnvelopingAlgebra</code> (<a href="chap3.html#X820195C47E2BE7E0"><b>3.12-9</b></a>).</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap2.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap4.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
