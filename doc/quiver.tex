%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QPA Project User Documentation
% DESCRIPTION: quiver.tex
%
% Copyright, 1998, 1999 Virginia Polytechnic Institute and State University.
% Copyright, 1998, 1999 Virginia Tech Path Algebra Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: quiver.tex,v 1.1 2010/05/07 13:16:24 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Quivers}

A quiver $Q$ is a set derived from a labeled directed multigraph
with loops $\Gamma$.
An element of $Q$ is called a *path*,
and falls into one of three classes.
The first class is the set of *vertices* of $\Gamma$.
The second class is the set of *walks* in $\Gamma$ of length at least one,
each of which is represented
by the corresponding sequence of *arrows* in $\Gamma$.
The third class is the singleton set containing the distinguished *zero path*,
usually denoted $0$.
An associative multiplication is defined on $Q$.

This chapter describes the functions in {\QPA} that deal with paths
and quivers.
The functions for constructing paths in Section "Constructing Paths"
are normally not useful in isolation;
typically,
they are invoked by the functions for constructing quivers
in Section "Constructing Quivers".

\>InfoQuiver V

is the info class for functions dealing with quivers.

%%  The quiver functionality was designed and implemented by Craig A. Struble.

\Section{Constructing Quivers}

\>Quiver( <N>, [ <arrow1>, <arrow2>, ... ] ) F
\>Quiver( [ <vertex1>, <vertex2>, ... ], [ <arrow1>, <arrow2>, ... ] ) F
\>Quiver( <adjacencymatrix> ) F

The first construction takes the number <N> of vertices
and a list of arrows to specify the graph $\Gamma$
and hence the quiver.
The second construction takes a list of vertex names
and a list of arrows for the same purpose.
The third construction takes an adjacency matrix
for the graph $\Gamma$.

In the first and third constructions,
the vertices are named `v1, v2, ...'.
In the second construction,
unique vertex names are given as strings
in the list that is the first parameter.
Each arrow is a list consisting of a source vertex and a target vertex,
followed optionally by an arrow name as a string.

Vertices and arrows are referenced as record components
using the dot (`.') operator.

\beginexample 
gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> VerticesOfQuiver(q1);
[ u, v ]
gap> ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap> q2 := Quiver(2,[[1,1],[2,1],[1,2]]);
<quiver with 2 vertices and 3 arrows>
gap> ArrowsOfQuiver(q2);
[ a1, a2, a3 ]
gap> VerticesOfQuiver(q2);
[ v1, v2 ]
gap> q3 := Quiver(2,[[1,1,"a"],[2,1,"b"],[1,2,"c"]]);
<quiver with 2 vertices and 3 arrows>
gap> ArrowsOfQuiver(q3);
[ a, b, c ]
gap> q4 := Quiver([[1,1],[2,1]]);
<quiver with 2 vertices and 5 arrows>
gap> VerticesOfQuiver(q4);
[ v1, v2 ]
gap> ArrowsOfQuiver(q4);
[ a1, a2, a3, a4, a5 ]
gap> SourceOfPath(q4.a2);
v1
gap> TargetOfPath(q4.a2);
v2
\endexample

\>`OrderedBy( <quiver>, <ordering> )'{Quivers:OrderedBy} F

returns a copy of <quiver> whose elements are ordered
by <ordering>. The default ordering of a quiver
is length left lexicographic.
See "qpa:Orderings" for more information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Section{Categories and Properties of Quivers}

\>IsQuiver( <object> ) P

is true when <object> is a quiver.

\>`IsAcyclic( <quiver> )'{Quivers:IsAcyclic} P

is true when <quiver> contains no cycles.

\>`IsFinite( <quiver> )'{Quivers:IsFinite} P

is true when <quiver> is a finite set.
Synonymous with `IsAcyclic'.

\beginexample
gap> quiver1 := Quiver(2,[[1,2]]);
<quiver with 2 vertices and 1 arrows>
gap> IsQuiver("v1");
false
gap> IsQuiver(quiver1);
true
gap> IsAcyclic(quiver1);
true
gap> quiver2 := Quiver(["u","v"],[["u","v"],["v","u"]]);
<quiver with 2 vertices and 2 arrows>
gap> IsAcyclic(quiver2);
false
gap> IsFinite(quiver1);
true
gap> IsFinite(quiver2);
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Operations for Quivers}

\>`<Q>.<element>'{quiver record access} O

allows access to generators of the quiver, be it a vertex or an arrow.  If you have named your vertices
and arrows the the access looks like `<Q>.<name of element>'.  If you have not named the elements of the 
quiver then the default names are v1, v2 ... and a1 a2 ... in the order they are created.

\>VerticesOfQuiver( <quiver> ) A

returns a list of paths that are vertices in <quiver>.

\>ArrowsOfQuiver( <quiver> ) A

returns a list of paths that are arrows in <quiver>.

\>AdjacencyMatrixOfQuiver( <quiver> ) A

returns the adjacency matrix of <quiver>.

\>GeneratorsOfQuiver( <quiver> ) A

returns a list of the vertices and arrows in <quiver>.

\>OrderOfQuiver( <quiver> ) A

returns the number of vertices in <quiver>.

\>SizeOfQuiver( <quiver> ) A

returns the number of arrows in <quiver>.

\>OrderingOfQuiver( <quiver> ) A

returns the ordering used to order elements in <quiver>.
See "qpa:Orderings" for more information.

\beginexample
gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> q1.a;
a
gap> q1.v;
v
gap> VerticesOfQuiver(q1);
[ u, v ]
gap> ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap> AdjacencyMatrixOfQuiver(q1);
[ [ 1, 1 ], [ 1, 1 ] ]
gap> GeneratorsOfQuiver(q1);
[ u, v, a, b, c, d ]
gap> OrderOfQuiver(q1);
2
gap> SizeOfQuiver(q1);
4
gap> OrderingOfQuiver(q1);
<length left lexicographic ordering>
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories and Properties of Paths}

\>IsPath( <object> ) C

All path objects are in this category.

\>IsVertex( <path> ) C

All vertices are in this category.

\>IsArrow( <path> ) C

All arrows are in this category.

\>IsZeroPath( <path> ) P

returns whether <path> is the zero path.

\beginexample
gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> IsPath(q1.b);
true
gap> IsPath(q1.u);
true
gap> IsVertex(q1.c);
false
gap> IsZeroPath(q1.d);
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Operations of Paths}

\>SourceOfPath( <path> ) A

returns the source (first) vertex of <path>.

\>TargetOfPath( <path> ) A

returns the target (last) vertex of <path>.

\>LengthOfPath( <path> ) A

returns the length of <path>.

\>WalkOfPath( <path> ) A

returns a list of the arrows that constitute <path>,
in order.

\>`<path-one> * <path-two>'{multiplication} O

Multiplication of two paths in the same quiver is always defined.
If the multiplication of two paths should give a zero path,
but the paths are not in a common quiver,
then an error is returned.
If the target of <path-one> differs from the source of <path-two>,
then the result is the zero path.
Otherwise,
if either path is a vertex,
then the result is the other path.
Finally,
if both are paths of length at least 1,
then the result is the concatenation of the walks
of the two paths.

\beginexample
gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> SourceOfPath(q1.v);                                                       
v
gap> p1:=q1.a*q1.b*q1.d*q1.d;
a*b*d^2
gap> TargetOfPath(p1);
v
gap> p2:=q1.b*q1.b;
0
gap> WalkOfPath(p1);
[ a, b, d, d ]
gap> WalkOfPath(q1.a);
[ a ]
gap> LengthOfPath(p1);
4
gap> LengthOfPath(q1.v);
0
\endexample

\>`<p> = <q>'{equality} O

Compare paths <p> and <q> for equality.
Two paths are equal if they have the same source
and the same target and if they have the same walks.
The paths <p> and <q> must be in the same quiver.


\>`<p> \< <q>'{lessthan} O

Two paths are compared using the ordering
of the quiver.
This is meaningful only if
<p> and <q> are in the same quiver.

\beginexample
gap> q1.a=q1.b;
false
gap> q1.a < q1.v;
false
gap> q1.a < q1.c;
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes of Vertices}

\>IncomingArrowsOfVertex( <vertex> ) A

returns a list of arrows having <vertex> as target.
Only meaningful if <vertex> is in a quiver.

\>OutgoingArrowsOfVertex( <vertex> ) A

returns a list of arrows having <vertex> as source.

\>InDegreeOfVertex( <vertex> ) A

returns the number of arrows having <vertex> as target.
Only meaningful if <vertex> is in a quiver.

\>OutDegreeOfVertex( <vertex> ) A

returns the number of arrows having <vertex> as source.

\>NeighborsOfVertex( <vertex> ) A

returns a list of neighbors of <vertex>,
that is,
vertices that are targets of arrows having <vertex> as source.

\beginexample
gap> q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> OutgoingArrowsOfVertex(q1.u);
[ a, b ]
gap> InDegreeOfVertex(q1.u);
2
gap> NeighborsOfVertex(q1.v);
[ u, v ]
\endexample




