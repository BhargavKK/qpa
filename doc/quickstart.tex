%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QPA Project User Documentation
% DESCRIPTION: quickstart.tex
%
% Copyright, 2007 Virginia Polytechnic Institute and State University.
% Copyright, 2007 Virginia Tech Path Algebra Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: quickstart.tex,v 1.1 2010/05/07 13:16:24 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Quick Start}

This chapter is intended for those who would like to get started with {\QPA}
right away by playing with a few examples.  A simple example is presented first:

% Example 9 from GBNP:
\Section{Example 1}

We construct a quiver $q$, i.e. a finite directed graph, with one
vertex and two loops:

\beginexample 
gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
<quiver with 1 vertices and 2 arrows>
\endexample

We can request the list of vertices and the list of arrows for $q$:

\beginexample 
gap> VerticesOfQuiver(q);
[ u ]
gap> ArrowsOfQuiver(q);
[ a, b ]
\endexample

Next we create the path algebra $pa$ from $q$ over the rational numbers:

\beginexample 
gap> pa := PathAlgebra(Rationals,q);
<algebra-with-one over Rationals, with 3 generators>
\endexample

In this case it is interesting to note that we've created an algebra isomorphic
to the free algebra on two generators.  We now retrieve and label the
generators and multiplicative identity for $pa$:

\beginexample
gap> gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*a, (1)*b ]
gap> u := gens[1];
(1)*u
gap> a := gens[2];
(1)*a
gap> b := gens[3];
(1)*b
gap> id := One(pa);
(1)*u
\endexample

As we expect, in this case, the multiplicative identity for $pa$ and the single
vertex $u$ are one in the same:

\beginexample 
gap> u = id;
true
\endexample

We now create a list of generators for an ideal and ask for its Groebner basis:
\beginexample
gap> polys := [a*b*a-b,b*a*b-b];
[ (-1)*b+(1)*a*b*a, (-1)*b+(1)*b*a*b ]
gap> gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*a*b+(1)*b*a, (-1)*a*b+(1)*b^2, (-1)*b+(1)*a^2*b ]
\endexample

Next, we create an ideal $I$ in {\GAP} using the Groebner basis $gb$ found above,
and then the quotient $pa/I$:
\beginexample
gap> I := Ideal(pa,gb);
<two-sided ideal in <algebra-with-one over Rationals, with 3 generators>,
 (3 generators)>
\endexample

\*\*\*This is not clear as to usefulness at this point:
Create Groebner Basis object and attach it to the ideal I
(normally we would've first created the ideal I from the set `polys',
then attached gb later):
\beginexample
gap> grb := GroebnerBasis(I,gb);    
<partial two-sided Groebner basis containing 3 elements>
\endexample


\Section{Example 2}

In this next example we create another path algebra that is essentially
the free algebra on six generators.  We then find the Groebner basis
for a commutative example from (create bibliographic reference here)
the book "Some Tapas of Computer Algebra" by A.M. Cohen, H. Cuypers, H. Sterk.

We create the underlying quiver, and from it the path algebra over
the rational numbers:
\beginexample 
gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
>                    ["u","u","d"],["u","u","e"],["u","u","f"]]);
<quiver with 1 vertices and 6 arrows>
gap> fq := PathAlgebra(Rationals,q);
<algebra-with-one over Rationals, with 7 generators>
\endexample

Next, the generators are labeled and the list of polynomials is
entered:
\beginexample
gap> gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e, (1)*f ]
gap> u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
gap> d := gens[5];; e := gens[6];; f := gens[7];;
gap> 
gap> polys := [ e*a,
>            a^3 + f*a,
>            a^9 + c*a^3,
>            a^81 + c*a^9 + d*a^3,
>            a^27 + d*a^81 + e*a^9 + f*a^3,
>            b + c*a^27 + e*a^81 + f*a^9,
>            c*b + d*a^27 + f*a^81,
>            a + d*b + e*a^27,
>            c*a + e*b + f*a^27,
>            d*a + f*b,
>            b^3 - b,
>            a*b - b*a, a*c - c*a,
>            a*d - d*a, a*e - e*a,
>            a*f - f*a, b*c - c*b,
>            b*d - d*b, b*e - e*b,
>            b*f - f*b, c*d - d*c,
>            c*e - e*c, c*f - f*c,
>            d*e - e*d, d*f - f*d,
>            e*f - f*e
> ];;
\endexample

Finally, the Groebner basis is found:
\beginexample
gap> gb := GBNPGroebnerBasis(polys,fq);
[ (1)*a, (1)*b, (-1)*c*d+(1)*d*c, (-1)*c*e+(1)*e*c, (-1)*d*e+(1)*e*d,
  (-1)*c*f+(1)*f*c, (-1)*d*f+(1)*f*d, (-1)*e*f+(1)*f*e ]
\endexample


\Section{Example 3}

The next example is from B. Keller's PhD thesis, p. 26:
(need to flesh out this example, provide better description)

\beginexample
gap> q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
<quiver with 2 vertices and 3 arrows>
gap> pa := PathAlgebra(Rationals,q);
<algebra-with-one over Rationals, with 5 generators>
gap> 
gap> # Get generators of path algebra:
gap> gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*v, (1)*c, (1)*b, (1)*a ]
gap> u := gens[1];
(1)*u
gap> v := gens[2];
(1)*v
gap> c := gens[3];
(1)*c
gap> b := gens[4];
(1)*b
gap> a := gens[5];
(1)*a
gap> id := One(pa);
(1)*u+(1)*v
gap> 
gap> polys := [a*b*c+b*a*b+a+c];
[ (1)*c+(1)*a+(1)*b*a*b+(1)*a*b*c ]
gap> gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*b*c+(1)*a*c, (1)*a+(1)*b*a*b, (1)*c+(1)*a*b*c, (-1)*b*a^2+(1)*a^2*b ]
\endexample


\Section{Example 4}

Here's an example that doesn't meet our necessary criteria
that all elements in a generating set have monomials in the
arrow ideal.  Since the given path algebra is isomorphic to a free algebra,
the single vertex is sent to the identity and there are
no complications.

First, we set up the algebra and generating set:
\beginexample
gap> q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
<quiver with 1 vertices and 2 arrows>
gap> f := Rationals;
Rationals
gap> fq := PathAlgebra(f,q);
<algebra-with-one over Rationals, with 3 generators>
gap> 
gap> # Get generators of path algebra:
gap> gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*x, (1)*y ]
gap> u := gens[1];
(1)*u
gap> x := gens[2];
(1)*x
gap> y := gens[3]; 
(1)*y
gap> id := One(fq);
(1)*u
gap> 
gap> polys := [x*y-y*x,x^2*y-id,x*y^2-id];
[ (1)*x*y+(-1)*y*x, (-1)*u+(1)*x^2*y, (-1)*u+(1)*x*y^2 ]
\endexample

Then we ask GBNP for its Groebner basis:

\beginexample
gap> gb := GBNPGroebnerBasisNC(polys,fq);
The given path algebra is isomorphic to a free algebra.
[ (-1)*x+(1)*y, (-1)*u+(1)*x^3 ]
\endexample

NOTE: It is important to realize that we've used the routine
`GBNPGroebnerBasisNC' which doesn't check that all elements in a
given list have non-vertex monomials.

So, if we run the standard QPA Groebner basis routine on this example,
we get the following:

\beginexample
gap> GBNPGroebnerBasis(polys,pa);
Please make sure all elements are in the given path algebra, 
and each summand of each element is not (only) a vertex.
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
