<?xml version="1.0" encoding="UTF-8"?>

<!-- $Id: qpadocumentation.xml,v 1.22 2012/02/02 10:07:31 sunnyquiver Exp $ -->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<!-- [ <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">--&gt;</Alt>'>
 ]> -->

<?LaTeX ExtraPreamble="
\newcommand{\tensor}{\otimes}
\newcommand{\quiverproduct}{\times}
"?>

<Book Name="QPA documentation">

<TitlePage>
  <Title>QPA</Title>
  <Subtitle>Quivers and Path Algebras</Subtitle>
  <Version>Version <#Include SYSTEM "../version"></Version>
  <TitleComment>
  We can add a comment here.
  </TitleComment>
  <Author>The QPA-team<Br/>
          <URL>http://sourceforge.net/projects/quiverspathalg/</URL><Br/>
          (See also <URL>http://www.math.ntnu.no/~oyvinso/QPA/</URL>) 
  </Author>
  <Date>September 2010</Date>
  <Address>
  Virginia Tech, Blacksburg, USA<Br/>
  NTNU, Trondheim, Norway<Br/> 
  </Address>
  <Abstract>
    
      
  </Abstract>
  <Copyright>&copyright; 2010-2020 The QPA-team. 
  </Copyright>
  <Acknowledgements>The system design of <Package>QPA</Package> was initiated by
Edward L. Green, Lenwood S. Heath, and Craig A. Struble.  It was
continued and completed by Randall Cone and Edward Green.  We would
like to thank the following people for their contributions:

<Table Align="ll">
<Row><Item>Gerard Brunick</Item><Item>Quivers, path algebras</Item></Row>
<Row><Item>Randall Cone</Item><Item>Code modernization and cleanup,
GBNP interface (for Groebner bases),</Item></Row> 
<Row><Item> </Item><Item>projective resolutions, user documentation</Item></Row>
<Row><Item>George Yuhasz</Item><Item>User documentation, matrix
    representations of path algebras</Item></Row>
</Table>
  </Acknowledgements>
  <Colophon>This is the Colophon page.
  </Colophon>
</TitlePage>

<TableOfContents/>

<Body>

<Chapter Label="Quickstart"><Heading>Quick Start</Heading>

This chapter is intended for those who would like to get started with
<Package>QPA</Package> right away by playing with a few examples.  A
simple example is presented first:

<!-- Example 9 from GBNP: -->
<Section Label="Example 1"><Heading>Example 1</Heading>

We construct a quiver <Math>q</Math>, i.e. a finite directed graph, with one
vertex and two loops:

<Example><![CDATA[
gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
<quiver with 1 vertices and 2 arrows>
]]></Example>

We can request the list of vertices and the list of arrows
for <Math>q</Math>:

<Example> 
gap&gt; VerticesOfQuiver(q);
[ u ]
gap&gt; ArrowsOfQuiver(q);
[ a, b ]
</Example>

Next we create the path algebra <Math>pa</Math> from <Math>q</Math>
over the rational numbers:

<Example> 
gap&gt; pa := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 3 generators&gt;
</Example>

In this case it is interesting to note that we've created an algebra
isomorphic to the free algebra on two generators.  We now retrieve and
label the generators and multiplicative identity for <Math>pa</Math>:

<Example>
gap&gt; gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*a, (1)*b ]
gap&gt; u := gens[1];
(1)*u
gap&gt; a := gens[2];
(1)*a
gap&gt; b := gens[3];
(1)*b
gap&gt; id := One(pa);
(1)*u
</Example>

As we expect, in this case, the multiplicative identity
for <Math>pa</Math> and the single vertex <Math>u</Math> are one in
the same:

<Example> 
gap&gt; u = id;
true
</Example>

We now create a list of generators for an ideal and ask for its
Groebner basis: 
<Example>
gap&gt; polys := [a*b*a-b,b*a*b-b];
[ (-1)*b+(1)*a*b*a, (-1)*b+(1)*b*a*b ]
gap&gt; gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*a*b+(1)*b*a, (-1)*a*b+(1)*b^2, (-1)*b+(1)*a^2*b ]
</Example>

Next, we create an ideal <Math>I</Math> in {\GAP} using the Groebner
basis <Math>gb</Math> found above, and then the
quotient <Math>pa/I</Math>:
<Example>
gap&gt; I := Ideal(pa,gb);
&lt;two-sided ideal in &lt;algebra-with-one over Rationals, with 3
generators&gt;, 
 (3 generators)&gt;
</Example>

Once we have the generators for a Groebner basis, we set the
appropriate property for the ideal <Math>I</Math>:
<Example>
gap&gt; grb := GroebnerBasis(I,gb);    
&lt;partial two-sided Groebner basis containing 3 elements&gt;
</Example>
</Section>

<Section><Heading>Example 2</Heading>

In this next example we create another path algebra that is
essentially the free algebra on six generators.  We then find the
Groebner basis for a commutative example from (create bibliographic
reference here) the book "Some Tapas of Computer Algebra" by
A.M. Cohen, H. Cuypers, H. Sterk.

We create the underlying quiver, and from it the path algebra over
the rational numbers:
<Example> 
gap&gt; q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
&gt;                    ["u","u","d"],["u","u","e"],["u","u","f"]]);
&lt;quiver with 1 vertices and 6 arrows&gt;
gap&gt; fq := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 7 generators&gt;
</Example>

Next, the generators are labeled and the list of polynomials is
entered:
<Example>
gap&gt; gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e, (1)*f ]
gap&gt; u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
gap&gt; d := gens[5];; e := gens[6];; f := gens[7];;
gap&gt; polys := [ e*a,
&gt;            a^3 + f*a,
&gt;            a^9 + c*a^3,
&gt;            a^81 + c*a^9 + d*a^3,
&gt;            a^27 + d*a^81 + e*a^9 + f*a^3,
&gt;            b + c*a^27 + e*a^81 + f*a^9,
&gt;            c*b + d*a^27 + f*a^81,
&gt;            a + d*b + e*a^27,
&gt;            c*a + e*b + f*a^27,
&gt;            d*a + f*b,
&gt;            b^3 - b,
&gt;            a*b - b*a, a*c - c*a,
&gt;            a*d - d*a, a*e - e*a,
&gt;            a*f - f*a, b*c - c*b,
&gt;            b*d - d*b, b*e - e*b,
&gt;            b*f - f*b, c*d - d*c,
&gt;            c*e - e*c, c*f - f*c,
&gt;            d*e - e*d, d*f - f*d,
&gt;            e*f - f*e
&gt; ];;
</Example>

Finally, the Groebner basis is found:
<Example>
gap&gt; gb := GBNPGroebnerBasis(polys,fq);
[ (1)*a, (1)*b, (-1)*c*d+(1)*d*c, (-1)*c*e+(1)*e*c, (-1)*d*e+(1)*e*d,
  (-1)*c*f+(1)*f*c, (-1)*d*f+(1)*f*d, (-1)*e*f+(1)*f*e ]
</Example>
</Section>

<Section><Heading>Example 3</Heading>

The next example is from B. Keller's PhD thesis, p. 26:

<Example>
gap&gt; q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; pa := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 5 generators&gt;
gap&gt; 
gap&gt; # Get generators of path algebra:
gap&gt; gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*v, (1)*c, (1)*b, (1)*a ]
gap&gt; u := gens[1];; v := gens[2];; c := gens[3];;
gap&gt; b := gens[4];; a := gens[5];; id := One(pa);;
gap&gt; 
gap&gt; polys := [a*b*c+b*a*b+a+c];
[ (1)*c+(1)*a+(1)*b*a*b+(1)*a*b*c ]
gap&gt; gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*b*c+(1)*a*c, (1)*a+(1)*b*a*b, (1)*c+(1)*a*b*c, (-1)*b*a^2+(1)*a^2*b ]
</Example>
</Section>

<Section><Heading>Example 4</Heading>

Here's an example that doesn't meet our necessary criteria that all
elements in a generating set have monomials in the arrow ideal.  Since
the given path algebra is isomorphic to a free algebra, the single
vertex is sent to the identity and there are no complications.

First, we set up the algebra and generating set:
<Example>
gap&gt; q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
&lt;quiver with 1 vertices and 2 arrows&gt;
gap&gt; f := Rationals;
Rationals
gap&gt; fq := PathAlgebra(f,q);
&lt;algebra-with-one over Rationals, with 3 generators&gt;
gap&gt; 
gap&gt; # Get generators of path algebra:
gap&gt; gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*x, (1)*y ]
gap&gt; u := gens[1];; x := gens[2];; y := gens[3];; id := One(fq);;
gap&gt; polys := [x*y-y*x,x^2*y-id,x*y^2-id];
[ (1)*x*y+(-1)*y*x, (-1)*u+(1)*x^2*y, (-1)*u+(1)*x*y^2 ]
</Example>

Then we ask GBNP for its Groebner basis:

<Example>
gap&gt; gb := GBNPGroebnerBasisNC(polys,fq);
The given path algebra is isomorphic to a free algebra.
[ (-1)*x+(1)*y, (-1)*u+(1)*x^3 ]
</Example>

NOTE: It is important to realize that we've used the routine
`GBNPGroebnerBasisNC' which doesn't check that all elements in a given
list have non-vertex monomials.

So, if we run the standard <Package>QPA</Package> Groebner basis
routine on this example, we get the following:

<Example>
gap&gt; GBNPGroebnerBasis(polys,pa);
Please make sure all elements are in the given path algebra, 
and each summand of each element is not (only) a vertex.
false
</Example>
</Section>
</Chapter>

<Chapter Label="Quivers"><Heading>Quivers</Heading>

<Section><Heading>Information class, Quivers</Heading>

A quiver <Math>Q</Math> is a set derived from a labeled directed
multigraph with loops <Math>\Gamma</Math>.  An element
of <Math>Q</Math> is called a *path*, and falls into one of three
classes.  The first class is the set of *vertices* of
<Math>\Gamma</Math>.  The second class is the set of *walks*
in <Math>\Gamma</Math> of length at least one, each of which is
represented by the corresponding sequence of *arrows*
in <Math>\Gamma</Math>.  The third class is the singleton set
containing the distinguished *zero path*, usually
denoted <Math>0</Math>.  An associative multiplication is defined
on <Math>Q</Math>.<P/>

This chapter describes the functions in <Package>QPA</Package> that
deal with paths and quivers.  The functions for constructing paths in
Section <Ref Sect="Constructing Paths"/> are normally not useful in
isolation; typically, they are invoked by the functions for
constructing quivers in Section <Ref Sect="Constructing Quivers"/>.

  <ManSection>
   <InfoClass Name="InfoQuiver" Comm="InfoClass for functions dealing
   with quivers"/> 
   <Description>
     is the info class for functions dealing with quivers.
   </Description>
  </ManSection>

<!-- The quiver functionality was designed and implemented by Craig --
  -- A. Struble. --> 
</Section> 

<Section  Label="Constructing Quivers"><Heading>Constructing Quivers</Heading>
  <ManSection>
   <Func Name="Quiver" Arg="N, [arrow1, arrow2, ... ]" 
	 Comm="creates a quiver"/>
   <Func Name="Quiver" Arg="[vertex1, vertex2, ... ],
	 [arrow1, arrow2, ... ]" 
	 Comm="creates a quiver"/>
   <Func Name="Quiver" Arg="adjacencymatrix" 
	 Comm="creates a quiver"/>
   <Returns>a quiver, which satisfies the property
   <Ref Prop="IsQuiver"/>.</Returns> 
   <Description>
The first construction takes the number <Arg>N</Arg> of vertices and a
list of arrows to specify the graph <Math>\Gamma</Math> and hence the
quiver.  The second construction takes a list of vertex names and a
list of arrows for the same purpose.  The third construction takes an
adjacency matrix for the graph <Math>\Gamma</Math>.<P/>

In the first and third constructions, the vertices are named `v1, v2,
...'.  In the second construction, unique vertex names are given as
strings in the list that is the first parameter.  Each arrow is a list
consisting of a source vertex and a target vertex, followed optionally
by an arrow name as a string.<P/>

Vertices and arrows are referenced as record components using the dot
(`.') operator.
   </Description>
  </ManSection>

<Example> 
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; VerticesOfQuiver(q1);
[ u, v ]
gap&gt; ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap&gt; q2 := Quiver(2,[[1,1],[2,1],[1,2]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; ArrowsOfQuiver(q2);
[ a1, a2, a3 ]
gap&gt; VerticesOfQuiver(q2);
[ v1, v2 ]
gap&gt; q3 := Quiver(2,[[1,1,"a"],[2,1,"b"],[1,2,"c"]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; ArrowsOfQuiver(q3);
[ a, b, c ]
gap&gt; q4 := Quiver([[1,1],[2,1]]);
&lt;quiver with 2 vertices and 5 arrows&gt;
gap&gt; VerticesOfQuiver(q4);
[ v1, v2 ]
gap&gt; ArrowsOfQuiver(q4);
[ a1, a2, a3, a4, a5 ]
gap&gt; SourceOfPath(q4.a2);
v1
gap&gt; TargetOfPath(q4.a2);
v2
</Example>

  <ManSection>
   <Func Name="OrderedBy" Arg="quiver, ordering" 
	 Comm="Quivers:OrderedBy"/>
   <Returns>a copy of <Arg>quiver</Arg> whose elements are ordered
     by <Arg>ordering</Arg>. The default ordering of a quiver is
     length left lexicographic.  See Section
     <Ref Sect="qpa:Orderings"/> for more information.</Returns>
   <Description>
   </Description>
  </ManSection>
</Section>

<Section><Heading>Categories and Properties of Quivers</Heading>

  <ManSection>
   <Prop Name="IsQuiver" Arg="object" Comm="property, whether object
   is a quiver"/>
   <Description>
     is true when <Arg>object</Arg> is a quiver.
   </Description>
  </ManSection>

  <ManSection>
   <Prop Name="IsAcyclic" Arg="object" Comm="property, whether object
   is a quiver with no cycles"/>
   <Description>
     is true when <Arg>object</Arg> is a quiver with no cycles.
   </Description>
  </ManSection>

  <ManSection>
   <Prop Name="IsFinite" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a finite set. Synonymous with
     `IsAcyclic'. 
   </Description>
  </ManSection>

<Example>
gap&gt; quiver1 := Quiver(2,[[1,2]]);
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; IsQuiver("v1");
false
gap&gt; IsQuiver(quiver1);
true
gap&gt; IsAcyclic(quiver1);
true
gap&gt; quiver2 := Quiver(["u","v"],[["u","v"],["v","u"]]);
&lt;quiver with 2 vertices and 2 arrows&gt;
gap&gt; IsAcyclic(quiver2);
false
gap&gt; IsFinite(quiver1);
true
gap&gt; IsFinite(quiver2);
false
</Example>
</Section>

<Section Label="qpa:Orderings"><Heading>Orderings of paths in a
    quiver</Heading> 

  To be written. 

</Section>

<Section><Heading>Attributes and Operations for Quivers</Heading>

  <ManSection>
   <Oper Name="." Arg="Q, element" Comm=""/>
   <Description>
    The operation <Ref Oper="."/> operates on <Arg>Q</Arg>, a quiver,
    and an element, a vertex or an arrow, to allow access to
    generators of the quiver. If you have named your vertices and
    arrows the the access looks like `<Arg>Q</Arg>.<Arg>name of
    element</Arg>'.  If you have not named the elements of the quiver
    then the default names are v1, v2, ... and a1, a2, ... in the order
    they are created.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="VerticesOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of paths that are vertices
    in <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="ArrowsOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of paths that are arrows
    in <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="AdjacencyMatrixOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the adjacency matrix of <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="GeneratorsOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of the vertices and the arrows
    in <Arg>object</Arg>. 
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="OrderOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the number of vertices in <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="SizeOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the number of arrows in <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="OrderingOfQuiver" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the ordering used to order elements
    in <Arg>object</Arg>. See Section <Ref Sect="qpa:Orderings"/> for
    more information.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="OppositeOfQuiver" Arg="Q" Comm=""/>
   <Description>
     This takes the quiver <Arg>Q</Arg> and produces the opposite
     quiver, where the vertices are labelled "name in original
     quiver" + "_op" and the arrows are labelled "name in orginal
     quiver" + "_op". 
   </Description>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; q1.a;
a
gap&gt; q1.v;
v
gap&gt; VerticesOfQuiver(q1);
[ u, v ]
gap&gt; ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap&gt; AdjacencyMatrixOfQuiver(q1);
[ [ 1, 1 ], [ 1, 1 ] ]
gap&gt; GeneratorsOfQuiver(q1);
[ u, v, a, b, c, d ]
gap&gt; OrderOfQuiver(q1);
2
gap&gt; SizeOfQuiver(q1);
4
gap&gt; OrderingOfQuiver(q1);
&lt;length left lexicographic ordering&gt;
gap&gt; q1_op := OppositeOfQuiver(q1);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; VerticesOfQuiver(q1);
[ u_op, v_op ]
gap&gt; ArrowsOfQuiver(q1);
[ a_op, b_op, c_op, d_op ]
</Example>
</Section>

<Section><Heading>Categories and Properties of Paths</Heading>

<ManSection>
   <Filt Name="IsPath" Arg="object" Comm="" Type="category"/>
   <Description>
      All path objects are in this category.
   </Description>
  </ManSection>

<ManSection>
   <Filt Name="IsVertex" Arg="object" Comm="" Type="category"/>
   <Description>
      All vertices are in this category.
   </Description>
  </ManSection>

<ManSection>
   <Filt Name="IsArrow" Arg="object" Comm="" Type="category"/>
   <Description>
      All arrows are in this category.
   </Description>
  </ManSection>


  <ManSection>
   <Prop Name="IsZeroPath" Arg="object" Comm="checks if object is zero"/>
   <Description>
     is true when <Arg>object</Arg> is the zero path.
   </Description>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; IsPath(q1.b);
true
gap&gt; IsPath(q1.u);
true
gap&gt; IsVertex(q1.c);
false
gap&gt; IsZeroPath(q1.d);
false
</Example>
</Section>

<Section><Heading>Attributes and Operations of Paths</Heading>

  <ManSection>
   <Attr Name="SourceOfPath" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the source (first) vertex of <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="TargetOfPath" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the target (last) vertex of <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="LengthOfPath" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the length of <Arg>object</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="WalkOfPath" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of the arrows that
    constitue <Arg>object</Arg> in order.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="*" Arg="p, q" Comm=""/>
   <Description>
    The operation <Ref Oper="*"/> operates on <Arg>p</Arg>
    and <Arg>q</Arg>, which are two paths in the same quiver. It
    returns the multiplication of the paths. If the paths are not in
    the same quiver an error is returned. If the target
    of <Arg>p</Arg> differs from the source of <Arg>q</Arg>, then the
    result is the zero path.  Otherwise, if either path is a vertex,
    then the result is the other path.  Finally, if both are paths of
    length at least 1, then the result is the concatenation of the
    walks of the two paths.
    </Description>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; SourceOfPath(q1.v);                                                       
v
gap&gt; p1:=q1.a*q1.b*q1.d*q1.d;
a*b*d^2
gap&gt; TargetOfPath(p1);
v
gap&gt; p2:=q1.b*q1.b;
0
gap&gt; WalkOfPath(p1);
[ a, b, d, d ]
gap&gt; WalkOfPath(q1.a);
[ a ]
gap&gt; LengthOfPath(p1);
4
gap&gt; LengthOfPath(q1.v);
0
</Example>

  <ManSection>
   <Oper Name="=" Arg="p, q" Comm="equality"/>
   <Description>
    The operation <Ref Oper="="/> operates on two paths <Arg>p</Arg>
    and <Arg>q</Arg>, and compares the paths for equality. Two paths
    are equal if they have the same source and the same target and if
    they have the same walks.  The paths <Arg>p</Arg> and <Arg>q</Arg>
    must be in the same quiver.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="&lt;" Arg="p, q" Comm="lessthan"/>
   <Description>
    The operation <Ref Oper="&lt;"/> operates on two
    paths <Arg>p</Arg> and <Arg>q</Arg>, and compares them with
    respect to the ordering of the quiver. This is meaningful only if
    <Arg>p</Arg> and <Arg>q</Arg> are in the same quiver.
   </Description>
  </ManSection>

<Example>
gap&gt; q1.a=q1.b;
false
gap&gt; q1.a &lt; q1.v;
false
gap&gt; q1.a &lt; q1.c;
true
</Example>
</Section>

<Section><Heading>Attributes of Vertices</Heading>

  <ManSection>
   <Attr Name="IncomingArrowsOfVertex" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of arrows having <Arg>object</Arg> as
    target. Only meaningful if <Arg>object</Arg> is in a quiver.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="OutgoingArrowsOfVertex" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of arrows having <Arg>object</Arg> as
    source.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="InDegreeOfVertex" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the number of arrows
    having <Arg>object</Arg> as target. Only meaningful
    if <Arg>object</Arg> is in a quiver. 
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="OutDegreeOfVertex" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the number of arrows
    having <Arg>object</Arg> as source.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="NeighborsOfVertex" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns a list of neighbors of <Arg>object</Arg>,
    that is, vertices that are targets of arrows
    having <Arg>object</Arg> as source. 
    </Description>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; OutgoingArrowsOfVertex(q1.u);
[ a, b ]
gap&gt; InDegreeOfVertex(q1.u);
2
gap&gt; NeighborsOfVertex(q1.v);
[ u, v ]
</Example>
</Section>
</Chapter>

<Chapter Label="PathAlgebras"><Heading>Path Algebras</Heading>
<Section><Heading>Introduction</Heading> 

A path algebra is an algebra constructed from a field <Math>F</Math>
and a quiver <Math>Q</Math>.  The path algebra <Math>FQ</Math>
contains all finite linear combinations of elements
of <Math>Q</Math>.

This chapter describes the functions in <Package>QPA</Package> that
deal with path algebras and quotients of path algebras.  Path algebras
are algebras so see Chapter "ref:algebras" for functionality such as
generators, basis functions, and mappings.

<ManSection>
   <InfoClass Name="InfoPathAlgebra" Comm=""/>
   <Description>
      is the info class for functions dealing with path algebras.
   </Description>
</ManSection>



</Section>

<Section Label="Constructing Paths"><Heading>Constructing Path Algebras</Heading> 
  <ManSection>
   <Func Name="PathAlgebra" Arg="F, Q" Comm=""/>
   <Returns>the path algebra <Math>FG</Math> of <Arg>Q</Arg> over the
   field <Arg>F</Arg>.</Returns>
   <Description>
   </Description>
  </ManSection>

<Example> 
gap&gt; q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; f := FiniteField(23);
GF(23)
gap&gt; fq := PathAlgebra(f,q);
&lt;algebra-with-one over GF(23), with 6 generators&gt;
</Example>

\* NO: the FOLLOWING is not true:

  <ManSection>
   <Func Name="OrderedBy" Arg="path algebra, ordering" Comm="Path Algebras:OrderedBy"/>
   <Returns> a copy of <Arg>path algebra</Arg> whose elements are
      ordered by <Arg>ordering</Arg>.  See Section
      <Ref Sect="qpa:Orderings"/> for more information on
      orderings.</Returns>
   <Description>
   </Description>
  </ManSection>
</Section>

<Section><Heading>Categories and Properties of Path Algebras</Heading>

  <ManSection>
   <Prop Name="IsPathAlgebra" Arg="object" Comm="checks if object is a path algebra"/>
   <Description>
     is true when <Arg>object</Arg> is a path algebra.
   </Description>
  </ManSection>

<Example>
gap&gt; IsPathAlgebra(fq);
true
gap&gt; IsPathAlgebra(q);
false
</Example>
</Section>

<Section><Heading>Attributes and Operations for Path Algebras</Heading>

  <ManSection>
   <Attr Name="QuiverOfPathAlgebra" Arg="object" Comm=""/>
   <Description>
    An attribute. Returns the quiver from which <Arg>object</Arg> was
    constructed.
   </Description>
  </ManSection>

<Example>
gap&gt; QuiverOfPathAlgebra(fq);
&lt;quiver with 2 vertices and 4 arrows&gt;
</Example>

  <ManSection>
   <Oper Name="." Arg="FQ, element" Comm="path algebra record access"/>
   <Description>
    The operation <Ref Oper="."/> operates on a path
    algebra <Arg>FQ</Arg> and an element <Arg>element</Arg>, which is
    a vertex or an arrow in the quiver Q. It returns the generator as
    an element of the path algebra. 
   </Description>
  </ManSection>

<Example>
gap&gt; fq.v;
(Z(23)^0)*v
gap&gt; fq.b;
(Z(23)^0)*b
</Example>

&gt;OrderingOfAlgebra( <Arg>path algebra</Arg> )
returns the ordering of the quiver of the path algebra.
</Section>

<Section><Heading>Operations on Path Algebra Elements</Heading>

  <ManSection>
   <Oper Name="&lt;" Arg="a, b" Comm="PathAlgebra:lessthan"/>
   <Description>
    The operation <Ref Oper="&lt;"/> operates on elements <Arg>a</Arg>
    and <Arg>b</Arg> of a path algebra <Math>FQ</Math>, and they are
    compared using the ordering for the path algebra. See
    Section <Ref Sect="qpa:Orderings"/> for more information on orderings.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IsLeftUniform" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="IsLeftUniform"/> operates on
    an <Arg>element</Arg> in a path algebra, and it returns true if
    each monomial in <Arg>element</Arg> has the same source vertex.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IsRightUniform" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="IsRightUniform"/> operates on
    an <Arg>element</Arg> in a path algebra, and it returns true if
    each monomial in <Arg>element</Arg> has the same target vertex.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IsUniform" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="IsUniform"/> operates on
    an <Arg>element</Arg> in a path algebra, and it returns true if
    each monomial in <Arg>element</Arg> has both the same source
    vertex and the same target vertex.
   </Description>
  </ManSection>

<Example>
gap&gt; IsLeftUniform(elem);
false
gap&gt; IsRightUniform(elem);
false
gap&gt; IsUniform(elem);
false
gap&gt; another := fq.a*fq.b + fq.b*fq.d*fq.c*fq.b*fq.d;
(Z(23)^0)*a*b+(Z(23)^0)*b*d*c*b*d
gap&gt; IsLeftUniform(another);
true
gap&gt; IsRightUniform(another);
true
gap&gt; IsUniform(another);
true
</Example>

  <ManSection>
   <Oper Name="LeadingTerm" Arg="element" Comm=""/>
   <Oper Name="Tip" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="LeadingTerm"/> or equivalently
    <Ref Oper="Tip"/> operates on an <Arg>x</Arg> in a path algebra,
    and it returns is the term in <Arg>element</Arg> whose monomial is
    largest among those monomials that have nonzero coefficients; this
    term is known as the *tip* of <Arg>element</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="LeadingCoefficient" Arg="element" Comm=""/>
   <Oper Name="TipCoefficient" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="LeadingCoefficient"/> or equivalently
    <Ref Oper="TipCoefficient"/> operates on an <Arg>element</Arg> in
    a path algebra, and it returns the coefficient of the tip
    of <Arg>element</Arg>.  This is an element of the field.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="LeadingMonomial" Arg="element" Comm=""/>
   <Oper Name="TipMonomial" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="LeadingMonomial"/> or equivalently
    <Ref Oper="TipMonomial"/> operates on an <Arg>element</Arg> in a
    path algebra, and it returns the monomial of the tip
    of <Arg>element</Arg>; it is the largest monomial occurring
    in <Arg>element</Arg> with a nonzero coefficient.  This is an
    element of the underlying quiver, not of the path algebra.
   </Description>
  </ManSection>

<Example>
gap&gt; elem := fq.a*fq.b*fq.c + fq.b*fq.d*fq.c+fq.d*fq.d;
(Z(23)^0)*d^2+(Z(23)^0)*a*b*c+(Z(23)^0)*b*d*c
gap&gt; LeadingTerm(elem);
(Z(23)^0)*b*d*c
gap&gt; LeadingCoefficient(elem);
Z(23)^0
gap&gt; LeadingMonomial(elem);
b*d*c
</Example>


  <ManSection>
   <Oper Name="MakeUniformOnRight" Arg="elems" Comm=""/>
   <Description>
    The operation <Ref Oper="MakeUniformOnRight"/> operates on a
    list <Arg>elems</Arg> of elements in a path algebra, and it
    returns a list of right uniform elements generated by each
    element of <Arg>elems</Arg>. 
   </Description>
  </ManSection>



  <ManSection>
   <Oper Name="MappedExpression" Arg="expr, gens1, gens2"  Comm=""/>
   <Description>
    The operation <Ref Oper="MappedExpression"/> operates
    on <Arg>expr</Arg> from a path algebra and and two equal-length
    lists of generators <Arg>gens1</Arg> and <Arg>gens2</Arg> for
    subalgebras.  The <Arg>expr</Arg> must be in the subalgebra
    generated by <Arg>gens1</Arg>.  The lists define a mapping of each
    generator in <Arg>gens1</Arg> to the corresponding generator
    in <Arg>gens2</Arg>.  The value returned is the evaluation of the
    mapping at <Arg>expr</Arg>.
   </Description>
  </ManSection>

  <ManSection>
   <Func Name="VertexPosition" Arg="elm" Comm=""/>
   <Returns>the position of the vertex <Arg>v</Arg> in the list of
   vertices of which the element <Arg>elm</Arg> is a multiplum of.</Returns>
   <Description>
    The function assumes that a multiplum of a trivial path is
    entered. 
   </Description>
  </ManSection>

</Section>

<Section><Heading>Constructing Quotients of Path Algebras</Heading>
See Chapter "ref:algebras" on how to construct an ideal and a quotient of
an algebra.  When the quotient is constructed, it is still a path algebra and
thus the same commands may be used with quotients.  Also since a quotient is 
still an algebra, refer to "ref:algebras".

<Example>
gap&gt; I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);
&lt;two-sided ideal in &lt;algebra-with-one over GF(23), with 6 generators&gt;,
  (2 generators)&gt;
gap&gt; GeneratorsOfIdeal(I);
[ (Z(23)^0)*a*b, (Z(23)^11)*b*c+(Z(23)^0)*d^2 ]
gap&gt; quot := fq/I;
&lt;algebra-with-one over GF(23), with 6 generators&gt;
</Example>
</Section>

<Section><Heading>Ideals</Heading> 

<Subsection Label="IdealsAndOperations"><Heading>Ideals and operations
    on ideals</Heading>
</Subsection>

  <ManSection>
   <Oper Name="Ideal" Arg="KQ, elems" Comm=""/>
   <Description>
    The operation <Ref Oper="Ideal"/> defines the ideal generated by 
    <Arg>elems</Arg> in the path algebra <Arg>KQ</Arg> (See Ideals in
    the reference manual of GAP). 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="nthPowerOfArrowIdeal" Arg="KQ, n" Comm=""/>
   <Description>
    The operation <Ref Oper="nthPowerOfArrowIdeal"/> defines the ideal
    generated all the paths of length <Arg>n</Arg> in the path
    algebra <Arg>KQ</Arg>. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="AddNthPowerToRelations" Arg="KQ, rels, n" Comm=""/>
   <Description>
    The operation <Ref Oper="AddNthPowerToRelations"/> append the
    list <Arg>rels</Arg> the paths of length <Arg>n</Arg> in the path
    algebra <Arg>KQ</Arg>. The object <Arg>rels</Arg> must be a list
    of elements in the path algebra <Arg>KQ</Arg>, and <Arg>n</Arg>
    must be a positive integer. 
   </Description>
  </ManSection>



<Subsection Label="AttributesOfIdeals"><Heading>Attributes of ideals</Heading>

Groebner Basis Of an Ideal: For many of the functions related to
quotients, you will need to compute a Groebner basis of the ideal.
Refer to the chapters "qpa:groebner basis" and "qpa:using opal with
gap" to learn more.

<Example>
gap&gt; J := Ideal(fq,[fq.a*fq.b]);
&lt;two-sided ideal in &lt;algebra-with-one over GF(23), with 6 generators&gt;,
  (1 generators)&gt;
gap&gt; anotherquot := fq/J;
&lt;algebra-with-one over GF(23), with 6 generators&gt;
gap&gt; gb := GroebnerBasis(J,[fq.a*fq.b]);
&lt;complete two-sided Groebner basis containing 1 elements&gt;
gap&gt; SetIsCompleteGroebnerBasis(gb, true);
gap&gt; IsCompleteGroebnerBasis(gb);
true
gap&gt; gb = GroebnerBasisOfIdeal(J);
true
</Example>
</Subsection>
</Section>


<Section><Heading>Categories and Properties of Quotients of Path Algebras</Heading>

  <ManSection>
   <Prop Name="IsSubalgebraFpPathAlgebra" Arg="object" Comm="checks if
   object is a quotient of a path algebra"/>
   <Description>
     is true when <Arg>object</Arg> is a quotient of a path algebra.
   </Description>
  </ManSection>

<Example>
gap&gt; IsSubalgebraFpPathAlgebra(quot);
true
gap&gt; IsSubalgebraFpPathAlgebra(fq);
false
</Example>
</Section>

<Section><Heading>Attributes and Operations for Quotients of Path
    Algebras</Heading> 

  <ManSection>
   <Attr Name="NormalFormFunction" Arg="object" Comm=""/>
   <Description>
    is a function that can compute normal forms for elements
    of <Arg>object</Arg>. It may be supplied by the user.
   </Description>
  </ManSection>

  <ManSection>
   <Prop Name="IsElementOfFpPathAlgebra" Arg="object" Comm=""/>
   <Description>
     is true if <Arg>object</Arg> is an element of some quotient of a
     path algebra.
   </Description>
  </ManSection>

<Example>
gap&gt; this := anotherquot.a*anotherquot.b;
[(Z(23)^0)*a*b]
gap&gt; IsElementOfFpPathAlgebra(this);
true
gap&gt; IsElementOfFpPathAlgebra(fq);
false
</Example>

  <ManSection>
   <Oper Name="Coefficients" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="Coefficients"/> operates on
    an <Arg>element</Arg> of a quotient of a path algebra, and it
    returns the coefficients of the <Arg>element</Arg> in terms of its
    canonical basis. Question: Does this only take one argument?
   </Description>
  </ManSection>


<ManSection>
   <Oper Name="IsSelfinjective" Arg="A" Comm=""/>
   <Description>
     This function takes a path algebra or a quotient of a path
     algebra as an argument <Arg>A</Arg>, and returns fail
     if <Arg>A</Arg> is not finite dimensional. Otherwise it returns
     true or false according to whether <Arg>A</Arg> is selfinjective
     or not.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="LoewyLength" Arg="A" Comm=""/>
   <Description>
     This function takes a pathalgebra or a quotient of a path algebra
     as an argument <Arg>A</Arg>, and returns fail if <Arg>A</Arg> is
     not finite dimensional. Otherwise it returns the Loewy length of
     the algebra <Arg>A</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="CartanMatrix" Arg="A" Comm=""/>
   <Description>
     This function returns the Cartan matrix of the
     algebra <Arg>A</Arg>,  after having checked that <Arg>A</Arg> is a
     finite dimensional quotient of a path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="CoxeterMatrix" Arg="A" Comm=""/>
   <Description>
     This function returns the Coxeter matrix of the
     algebra <Arg>A</Arg>,  after having checked that <Arg>A</Arg> is a
     finite dimensional quotient of a path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="CoxeterPolynomial" Arg="A" Comm=""/>
   <Description>
     This function returns the Coxeter polynomial of the
     algebra <Arg>A</Arg>,  after having checked that <Arg>A</Arg> is a
     finite dimensional quotient of a path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="Centre/Center" Arg="A" Comm=""/>
   <Description>
     This function returns the centre of the algebra <Arg>A</Arg>,  
     after having checked that <Arg>A</Arg> is a finite dimensional
     quotient of a path algebra (the check is not implemented and also
     not implemented for path algebras).  
   </Description>
</ManSection>

</Section>



<Section><Heading>Attributes and Operations on Elements
of Quotients of Path Algebra</Heading>

  <ManSection>
   <Oper Name="IsNormalForm" Arg="element" Comm=""/>
   <Description>
    The operation <Ref Oper="IsNormalForm"/> operates on
    an <Arg>element</Arg> from a path algebra, and it is true
    if <Arg>element</Arg> is known to be in normal form.
   </Description>
  </ManSection>

<Example>
gap&gt; IsNormalForm(this); 
false
</Example>

  <ManSection>
   <Oper Name="&lt;" Arg="a, b" Comm=""/>
   <Description>
    The operation <Ref Oper="&lt;"/> operates on two
    elements <Arg>a</Arg> and <Arg>b</Arg> from a path
    algebra <Math>FQ</Math>, and it compares them using the ordering
    for the path algebra.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="ElementOfFpPathAlgebra" Arg="family, element,
   computenormal" Comm=""/>
   <Description>
    The operation <Ref Oper="ElementOfFpPathAlgebra"/> operates on
    an <Arg>element</Arg> in a path algebra, and it projects it into
    the quotient given by <Arg>family</Arg>.
    If <Arg>computenormal</Arg> is true, then the normal form of the
    projection of <Arg>element</Arg> is returned.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="OriginalPathAlgebra" Arg="algebra" Comm="for a quotient
   of a path algebra"/>
   <Description>
    The operation <Ref Oper="OriginalPathAlgebra"/> operates on
    an <Arg>algebra</Arg>. If it is a quotient of a path algebra or
    just a path algebra itself, it returns the path algebra it was
    constructed from. Otherwise it returns an error saying that the
    algebra entered was not a quotient of a path algebra. 
   </Description>
  </ManSection>
</Section>

<Section Label="qpa:predefinedalgebras"><Heading>Predefined classes
  of quotient of path algebras</Heading>

  <ManSection>
   <Func Name="NakayamaAlgebra" Arg="admiss-seq,field" 
	 Comm="creates a Nakayama algebra"/>
   <Returns>the Nakayama algebra corresponding to the addmissible
   sequence <Arg>admiss-seq</Arg> over the field <Arg>field</Arg>, 
   or <K>the admissible sequence entered</K> if entered sequence is
   not an admissible sequence.</Returns>
   <Description>
    This function creates a Nakayama algebra from an admissible
    sequence over a field.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="TruncatedPathAlgebra" Arg="K, Q, n" 
	 Comm="creates a truncated path algebra"/>
   <Returns>the truncated path algebra <Arg>KQ/I</Arg>,
   where <Arg>I</Arg> is the ideal generated by all paths of
   length <Arg>n</Arg> in <Arg>KQ</Arg>. The object <Arg>K</Arg> must
   be a field, <Arg>Q</Arg> a quiver and <Arg>n</Arg> a positive
   integer.</Returns>
  </ManSection>
</Section>

<Section Label="qpa:patensor">
  <Heading>Tensor products of path algebras</Heading>

  If <M>\Lambda</M> and <M>\Gamma</M> are quotients of path algebras
  over the same field <M>F</M>, then their tensor product <M>\Lambda
  \tensor_F \Gamma</M> is also a quotient of a path algebra
  over <M>F</M>.<P/>

  The quiver for the tensor product path algebra is the
  <Ref Oper="QuiverProduct"/> of the quivers of the original
  algebras.<P/>

  The operation <Ref Oper="TensorProductOfAlgebras"/> computes the
  tensor products of two quotients of path algebras as a quotient of a
  path algebra.

  <ManSection>
    <Oper Name="QuiverProduct" Arg="Q1, Q2"/>
    <Description>
      Creates the product quiver <M><Arg>Q1</Arg>
      \quiverproduct <Arg>Q2</Arg></M>.  A vertex in <M><Arg>Q1</Arg>
      \quiverproduct <Arg>Q2</Arg></M> which is made by combining a
      vertex named <C>u</C> in <Arg>Q1</Arg> with a vertex <C>v</C>
      in <Arg>Q2</Arg> is named <C>u_v</C>.  Arrows are named
      similarly (they are made by combining an arrow from one quiver
      with a vertex from the other).
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="QuiverProductDecomposition" Arg="Q"/>
    <Description>
      Contains the original quivers <Arg>Q</Arg> is a product of,
      if <Arg>Q</Arg> was created by the <Ref Oper="QuiverProduct"/>
      operation.  The value of this attribute is an object in the
      category <Ref Filt="IsQuiverProductDecomposition"/>.
    </Description>
  </ManSection>

  <ManSection>
    <Filt Name="IsQuiverProductDecomposition"/>
    <Description>
      Category for objects containing information about the relation
      between a product quiver and the quivers it is a product of.
      The quiver factors can be extracted from the decomposition
      object by using the [] notation (like accessing elements of a
      list).  The decomposition object is also used by the operations
      <Ref Oper="IncludeInProductQuiver"/> and
      <Ref Oper="ProjectFromProductQuiver"/>.
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="IncludeInProductQuiver" Arg="L, Q"/>
    <Description>
      Includes paths <M>q_1</M> and <M>q_2</M> from two quivers into
      the product of these quivers.  If at least one of <M>q_1</M>
      and <M>q_2</M> is a vertex, there is exactly one possible
      inclusion.  If they are both non-trivial paths, there are
      several possibilities.  This operation constructs the path which
      is the inclusion of <M>q_1</M> at the source of <M>q_2</M>
      multiplied with the inclusion of <M>q_2</M> at the target
      of <M>q_1</M>.<P/>

      The argument <Arg>L</Arg> is a list containing the
      paths <M>q_1</M> and <M>q_2</M> to be included; <M>Q</M> is the
      product quiver to include them in.
    </Description>
  </ManSection>

  <ManSection>
    <Oper Name="ProjectFromProductQuiver" Arg="i, p"/>
    <Description>
      Returns the projection of the product quiver path <Arg>p</Arg>
      to one of the factors.  Which factor it should be projected to
      is specified by the argument <Arg>i</Arg>.
    </Description>
  </ManSection>

  The following example shows how the operations related to quiver
  products are used.

  <Example>
gap&gt; q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q2 := Quiver( [ "v1", "v2", "v3" ],
                      [ [ "v1", "v2", "b" ],
                        [ "v2", "v3", "c" ] ] );
&lt;quiver with 3 vertices and 2 arrows&gt;
gap&gt; q1_q2 := QuiverProduct( q1, q2 );
&lt;quiver with 6 vertices and 7 arrows&gt;
gap&gt; q1_q2.u1_b * q1_q2.a_v2;
u1_b*a_v2
gap&gt; IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );
a_v1*u2_b*u2_c
gap&gt; ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );
b*c
gap&gt; q1_q2_dec := QuiverProductDecomposition( q1_q2 );
&lt;object&gt;
gap&gt; q1_q2_dec[ 1 ];
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q1_q2_dec[ 1 ] = q1;
true
  </Example>

  <ManSection>
   <Oper Name="TensorProductOfAlgebras" Arg="FQ1, FQ2"/>
   <Description>
     The operation <Ref Oper="TensorProductOfAlgebras"/> produces the
     tensor product of two (quotients of) path algebras <Arg>FQ1</Arg>
     and <Arg>FQ2</Arg>.  The result is a quotient of a path algebra,
     whose quiver is the <Ref Oper="QuiverProduct"/> of the quivers of
     the operands.
   </Description>
  </ManSection>

  <ManSection>
    <Oper Name="SimpleTensor" Arg="L, T"/>
    <Description>
      The operation <Ref Oper="SimpleTensor"/> produces a simple
      tensor <M>x \tensor y</M> in the tensor product of two path
      algebras.  The argument <Arg>L</Arg> is a list containing the
      elements <M>x</M> and <M>y</M>.  These should be elements of two
      (quotients of) path algebras, and <Arg>T</Arg> the tensor
      product of these algebras (produced by
      <Ref Oper="TensorProductOfAlgebras"/>).
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="TensorProductDecomposition" Arg="T"/>
    <Description>
      For a tensor product of quotients of path algebras (produced by
      <Ref Oper="TensorProductOfAlgebras"/>), this attribute contains
      a list of the factors in the tensor product.
    </Description>
  </ManSection>

  The following example shows how the operations for tensor products
  of quotients of path algebras are used.

  <Example>
gap&gt; q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; q2 := Quiver( [ "v1", "v2", "v3", "v4" ],
                      [ [ "v1", "v2", "b" ],
                        [ "v1", "v3", "c" ],
                        [ "v2", "v4", "d" ],
                        [ "v3", "v4", "e" ] ] );
&lt;quiver with 4 vertices and 4 arrows&gt;
gap&gt; fq1 := PathAlgebra( Rationals, q1 );
&lt;algebra-with-one over Rationals, with 3 generators&gt;
gap&gt; fq2 := PathAlgebra( Rationals, q2 );
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );
&lt;two-sided ideal in &lt;algebra-with-one over Rationals, with 8 generators&gt;,
 (1 generators)&gt;
gap&gt; quot := fq2 / I;
&lt;algebra-with-one over Rationals, with 8 generators&gt;
gap&gt; t := TensorProductOfAlgebras( fq1, quot );
&lt;algebra-with-one over Rationals, with 20 generators&gt;
gap&gt; SimpleTensor( [ fq1.a, quot.b ], t );
[(1)*a_v1*u2_b]
gap&gt; t_dec := TensorProductDecomposition( t );
[ &lt;algebra-with-one over Rationals, with 3 generators&gt;, 
  &lt;algebra-with-one over Rationals, with 8 generators&gt; ]
gap&gt; t_dec[ 1 ] = fq1;
true
  </Example>

  <ManSection>
    <Oper Name="EnvelopingAlgebra" Arg="FQ"/>
    <Description>
      Produces the enveloping algebra <M><Arg>FQ</Arg>^\text{e}
      = <Arg>FQ</Arg> \tensor <Arg>FQ</Arg>^\text{op}</M>
      of <Arg>FQ</Arg>, which should be (a quotient of) a path
      algebra.
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="IsEnvelopingAlgebra" Arg="A"/>
    <Description>
      True if and only if <Arg>A</Arg> is the result of a call to
      <Ref Oper="EnvelopingAlgebra"/>.
    </Description>
  </ManSection>

</Section>

</Chapter>

<Chapter Label="Groebner-Basis"><Heading>Groebner Basis</Heading>

This chapter contains the declarations and implementations needed for
Groebner basis. Currently, we do not provide algorithms to
actually compute Groebner basis;  instead, the declarations and
implementations are provided here for GAP objects and the actual
elements of Groebner basis are expected to be computed by external
packages such as `Opal' and `Groebner'.

<Section><Heading>Constructing a Groebner Basis</Heading>

<ManSection>
   <InfoClass Name="InfoGroebnerBasis" Comm=""/>
   <Description>
      is the info class for functions dealing with Groebner basis. 
   </Description>
</ManSection>

  <ManSection>
   <Func Name="GroebnerBasis" Arg="A, rels" 
	 Comm=""/>
   <Returns> an object in the `IsGroebnerBasis' category.</Returns>
   <Description>
       The `GroebnerBasis' global function takes an
       algebra <Math>A</Math> and a list of relations <Math>rels \in
       A</Math> and creates an object in the `IsGroebnerBasis'
       category. There are absolutely no checks for correctness in
       this function. Giving a set of relations that does not form a
       Groebner basis may result in incorrect answers or
       unexpected errors.  This function is intended to be used by
       packages providing access to external Groebner basis
       programs.
   </Description>
  </ManSection>

</Section>

<Section><Heading>Categories and Properties of Groebner
    Basis</Heading>

  <ManSection>
   <Prop Name="IsGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis and 'false' otherwise.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsTipReducedGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis which is tip reduced.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsCompletelyReducedGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis which is
     completely reduced.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsHomogenousGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebnerbasis which is homogenous.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsCompleteGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a complete Groebner basis.
     While philosophically something that isn't a complete Groebner
     basis isn't a Groebner basis at all, this property can be used in
     conjuction with other properties to see if the the Groebner basis
     contains enough information for computations. An example of a
     system that creates incomplete Groebner basis is `Opal'.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>
</Section>

<Section><Heading>Attributes and Operations for Groebner Basis</Heading>

  <ManSection>
   <Oper Name="CompletelyReduce" Arg="GB, a" Comm=""/>
   <Description>
    The operation <Ref Oper="CompletelyReduce"/> operates on an
    element <Arg>a</Arg> in a path algebra, and it
    reduces <Arg>a</Arg> by the Groebner
    basis <Arg>GB</Arg>.  The reduced element is
    returned. If <Arg>a</Arg> is already completely reduced, the
    original element <Arg>a</Arg> is returned.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="CompletelyReduceGroebnerBasis" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="CompletelyReduceGroebnerBasis"/> operates
    on a Groebner basis <Arg>GB</Arg>, and it modifies a Groebner
    basis <Math>GB</Math> such that each relation in
    <Math>GB</Math> is completely reduced.  The
    `IsCompletelyReducedGroebnerBasis' and `IsTipReducedGroebnerBasis'
    properties are set as a result of this operation. The resulting
    relations will be placed in sorted order according to the ordering
    of <Math>GB</Math>.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="TipReduce" Arg="GB, a" Comm=""/>
   <Description>
    The operation <Ref Oper="TipReduce"/> operates on an
    element <Arg>a</Arg> in a path algebra, and it tip reduced by the
    Groebner basis <Math>GB</Math>. If <Math>a</Math> is already tip
    reduced, then the original <Math>a</Math> is returned. 
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="TipReduceGroebnerBasis" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="TipReduceGroebnerBasis"/> operates on
    Groebner basis <Arg>GB</Arg>, and it returns an equivalent
    Groebner basis to <Math>GB</Math> such that each relation
    generating <Math>GB</Math> is tip reduced. If <Math>GB</Math> is
    already tip reduced, this function returns the original
    object <Math>GB</Math>, possibly with the addition of the
    `IsTipReduced`' property set.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Iterator" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Iterator"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it creates an iterator that iterates over
    the relations making up the Groebner basis. These
    relations are iterated over in ascending order with respect to the
    ordering for the family the elements are contained in.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Enumerator" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Enumerator"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it creates an enumerator that enumerates
    the relations making up the Groebner basis. These
    relations should are enumerated in ascending order with respect to
    the ordering for the family the elements are contained in.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Nontips" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Nontips"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it returns a list of nontip elements for
    a Groebner basis. In order to compute the nontip
    elements, the Groebner basis must be complete and tip
    reduced, and there must be a finite number of nontips. If there
    are an infinite number of nontips, the operation returns `fail'.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="AdmitsFinitelyManyNontips" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="AdmitsFinitelyManyNontips"/> operates on
    a Groebner basis <Arg>GB</Arg>, and it returns `true' if the
    Groebner basis admits only finitely many nontips and `false'
    otherwise. This operation only applies to complete Groebner basis.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="NontipSize" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="NontipSize"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it returns the number of nontips admitted
    by the Groebner basis <Math>GB</Math>. This operation is
    available only to complete basis.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="IsPrefixOfTipInTipIdeal" Arg="GB, R" Comm=""/>
   <Description>
    The operation <Ref Oper="IsPrefixOfTipInTipIdeal"/> operates on a
    Groebner basis <Arg>GB</Arg> and a relation <Arg>R</Arg>, and it
    checks the tip of a relation <Math>R</Math> to see if it is in the
    tip ideal generated by the tips of <Math>GB</Math>. This is used
    mainly for the construction of right Groebner basis, but
    is made available for general use in case there are other
    unforseen applications.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>
</Section>

<Section><Heading>Right Groebner Basis</Heading> 

In this section we support right Groebner basis for two-sided
ideals with Groebner basis. More general cases may be
supported in the future.

  <ManSection>
   <Prop Name="IsRightGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> a right Groebner basis.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Attr Name="RightGroebnerBasisOfIdeal" Arg="object" Comm=""/>
   <Description>
    An attribute. Stores a right Groebner basis of a right
    ideal, <Arg>object</Arg>, is one has been computed.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="RightGroebnerBasis" Arg="R" Comm=""/>
   <Description>
    The operation <Ref Oper="RightGroebnerBasis"/> operates on a right
    ideal <Arg>R</Arg> in a path algebra, and it constructs a right
    Groebner basis for the right ideal, <Math>R</Math>, which
    must support a right Groebner basis theory.  Right now,
    this requires that R have a complete Groebner basis.
   </Description>
  </ManSection>

</Section>
</Chapter>

<Chapter Label="GBNP"><Heading>Using GBNP with Gap</Heading>

<Section><Heading>GBNP</Heading>

<Package>GBNP</Package> is a non-commutative Groebner Basis
package which assumes that all algebras involved will be free algebras
over a finite number of non-commuting generators.  It also assumes
that the ordering on the monomials is left length-lexicographic.
</Section>

<Section><Heading>Setting up GBNP</Heading>
in progress...
</Section>

<Section><Heading>Relevant GBNP internals</Heading>
in progress...
</Section>

<Section><Heading>Communicating with GBNP</Heading>
in progress...
</Section>
</Chapter>

<Chapter Label="Right-Modules"><Heading>Right Modules over Path
Algebras</Heading>

There are two implementations of right modules over path algebras.
The first type are matrix modules that are defined by vector spaces and
linear transformations.  The second type are presentations defined by
vertex projective modules.

<Section><Heading>Matrix Modules</Heading> 
The first implementation of right modules over path algebras views
them as a collection of vector spaces and linear transformations.
Each vertex in the path algebra is associated with a vector space over
the field of the algebra.  For each vertex <Math>v</Math> of the
algebra there is a vector space <Math>V</Math>.  Arrows of the algebra
are then associated with linear transformations which map the vector
space of the source vertex to the vector space of the target vertex.
For example, if <Math>a</Math> is an arrow from <Math>v</Math>
to <Math>w</Math> then there is a transformation from vector
space <Math>V</Math> to <Math>W</Math>.  In practice when creating the
modules all we need to know is the transformations and we can create
the vector spaces of the correct dimension, and check to make sure the
dimensions all agree.  We can create a module in this way as follows.<P/>

  <ManSection>
   <Oper Name="RightModuleOverPathAlgebra" Arg="A, mats" 
	 Comm=""/>
   <Oper Name="RightModuleOverQuotientOfPathAlgebra" Arg="A, mats" 
	 Comm=""/>
   <Returns>a module over a path algebra in the first variant, 
     a module over a qoutient of a path algebra in the second variant.</Returns>
   <Description>
      In the function call, <Arg>A</Arg> is a (quotient of a ) path
      algebra.  The list of matrices <Arg>mats</Arg> can take on three
      different forms.<P/>

      1) The argument <Arg>mats</Arg> can be a list of blocks of
      matrices where each block is of the form, `["name of
      arrow",matrix]'.  So if you named your arrows when you created
      the quiver, then you can associate a matrix with that arrow
      explicitly.<P/> 

      2) The argument <Arg>mats</Arg> is just a list of matrices, and
      the matrices will be associated to the arrows in the order of
      arrow creation.  If when creating the quiver, the
      arrow <Math>a</Math> was created first, then <Math>a</Math>
      would be associated with the first matrix.<P/>

      3) The method is very much the same as the second
      method. If <Arg>arrows</Arg> is a list of the arrows of the
      quiver (obtained for instance through <C>arrows :=
      ArrowsOfQuiver(Q);</C>), the argument <Arg>mats</Arg> can have
      the
      format <C>[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].</C><P/>

      If you would like the trivial vector space at any vertex, then
      for each incoming arrow "a", associate it with a list of the
      form <C>["a",[n,0]]</C> where n is the dimension of the vector
      space at the source vertex of the arrow.  Likewise for all
      outgoing arrows "b", associate them to a block of
      form <C>["b",[0,n]]</C> where n is the dimension of the vector
      space at the target vertex of the arrow.<P/>

      A warning though, the function assumes that you do not mix the
      styles of inputting the matrices/linear transformations
      associated to the arrows in the quiver. Furthermore, each arrow
      needs to be assigned a matrix, otherwise an error will be
      returned. The function verifies that the dimensions of the
      matrices and vector spaces are correct and match, and that each
      arrow has only one matrix assigned to it.<P/>
   </Description>
  </ManSection>

<Example><![CDATA[
gap&gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); 
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; P := PathAlgebra(Rationals, Q);
&lt;algebra-with-one over Rationals, with 5 generators&gt;
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; 
gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; arrows := ArrowsOfQuiver(Q);
[ a, b, c ]
gap&gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], 
&gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;
gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt;
gap&gt; # Next we give the vertex simple associate to vertex 1. 
gap&gt; M :=
RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
					generators&gt;&gt; 
gap&gt; # Finally, the next defines the zero representation of the quiver.
gap&gt; M :=
RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
					generators&gt;&gt; 
gap&gt; Dimension(M);
0
gap&gt; Basis(M);
Basis( &lt;
0-dimensional right-module over &lt;algebra-with-one over Rationals, with 
5 generators&gt;&gt;, [  ] )
]]>
</Example>

<ManSection>
   <Oper Name="NewRightModuleOverPathAlgebra" Arg="A, dim_vector, gens" 
	 Comm=""/>
   <Description>
      The first argument <Arg>A</Arg> is a (quotient of a ) path
      algebra, the second argument <Arg>dim_vector</Arg> is the
      dimension vector of the module, and the last
      argument <Arg>gens</Arg> (maybe an empty list []) is a list of
      elements of the form ["label",matrix].  This function constructs
      a right module over a (quotient of a) path algebra <Arg>A</Arg>
      with dimension vector <Arg>dim_vector</Arg>, and where the
      generators/arrows with a non-zero action is given in the list
      <Arg>gens</Arg>. The format of the list <Arg>gens</Arg> is
      [["a",[matrix_a]],["b",[matrix_b]],...], where "a" and "b" are
      labels of arrows used when the underlying quiver was created and
      matrix_? is the action of the algebra element corresponding to
      the arrow with label "?". The action of the arrows can be
      entered in any order. The function checks if the
      algebra <Arg>A</Arg> is a (quotient of a) path algebra and if
      the matrices of the action of the arrows have the correct size
      according to the dimension vector entered and also whether or
      not the relations of the algebra are satisfied.  
   </Description>
  </ManSection>

<Example><![CDATA[
gap> # Using the above example.  
gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",
[[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap> M:=NewRightModuleOverPathAlgebra(P,[2,3],matrices);
<right-module over <algebra-with-one over Rationals, with 5 generators>>
gap> M:=NewRightModuleOverPathAlgebra(P,[2,3],[]);      
<right-module over <algebra-with-one over Rationals, with 5 generators>>
]]>
</Example>

</Section>

<Section><Heading>Categories Of Matrix Modules</Heading>

  <ManSection>
   <Filt Name="IsPathAlgebraMatModule" Arg="object" Comm=""/>
   <Description>
     These matrix modules fall under the category `IsAlgebraModule' with
the added filter of `IsPathAlgebraMatModule'.  Operations available
for algebra modules can be applied to path algebra modules.  See
"ref:representations of algebras" for more details.

     These modules are also vector spaces over the field of the path
algebra.  So refer to "ref:vector spaces" for descriptions of the
basis and elementwise operations available.
   </Description>
  </ManSection> 
</Section>

<Section><Heading>Acting on Module Elements</Heading>

  <ManSection>
   <Oper Name="^" Arg="m, p" Comm=""/>
   <Description>
    The operation <Ref Oper="^"/> operates on an element <Arg>m</Arg>
    in a module and a path <Arg>p</Arg> in a path algebra, and it
    returns the element <Arg>m</Arg> multiplied with <Arg>p</Arg>.
    When you act on an module element <Math>m</Math> by an
    arrow <Math>a</Math> from <Math>v</Math> to <Math>w</Math>, the
    component of <Math>m</Math> from <Math>V</Math> is acted on
    by <Math>L</Math> the transformation associated to <Math>a</Math>
    and placed in the component <Math>W</Math> .  All other components
    are given the value
<Math>0</Math>.
   </Description>
  </ManSection>

<Example>
gap&gt; # Using the path algebra P from the above example. 
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; B:=BasisVectors(Basis(M));
[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
gap&gt; B[1]+B[3];
[ [ 1, 0 ], [ 1, 0, 0 ] ]
gap&gt; 4*B[2];
[ [ 0, 4 ], [ 0, 0, 0 ] ]
gap&gt; m:=5*B[1]+2*B[4]+B[5];
[ [ 5, 0 ], [ 0, 2, 1 ] ]
gap&gt; m^(P.a*P.b-P.c);
[ [ 0, 5 ], [ 0, 0, 0 ] ]
gap&gt; B[1]^P.a;
[ [ 0, 0 ], [ 1, 0, 0 ] ]
gap&gt; B[2]^P.b;
[ [ 0, 0 ], [ 0, 0, 0 ] ]
gap&gt; B[4]^(P.b*P.c);
[ [ 0, 0 ], [ 0, 0, 0 ] ]
</Example>
</Section>

<Section><Heading>Operations on representations</Heading>

<Example><![CDATA[
gap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);
<quiver with 3 vertices and 5 arrows>
gap> KQ := PathAlgebra(Rationals, Q);
<algebra-with-one over Rationals, with 8 generators>
gap> gens := GeneratorsOfAlgebra(KQ);
[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ]
gap> u := gens[1];; v := gens[2];;
gap> w := gens[3];; a := gens[4];;
gap> b := gens[5];; c := gens[6];;
gap> d := gens[7];; e := gens[8];;
gap> rels := [d*e,c^2,a*c*d-b*d,e*a];;
gap> I:= Ideal(KQ,rels);;
gap> gb:= GBNPGroebnerBasis(rels,KQ);;
gap> gbb:= GroebnerBasis(I,gb);;
gap> A:= KQ/I;
<algebra-with-one over Rationals, with 8 generators>
gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],
["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap> N:= RightModuleOverQuotientOfPathAlgebra(A,mat);                         
<right-module over <algebra-with-one over Rationals, with 8 generators>>
]]></Example>

<ManSection>
   <Oper Name="CommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Returns>a list of four modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>X</Arg>, <Arg>V</Arg>], 
     where <Arg>X</Arg> is one common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DimensionVector" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>the dimension vector of the representation <Arg>M</Arg>.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
   <Description> A shortcoming of this that it is not defined for
     modules of quotients of path algebras.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DimensionMatModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>the dimension of the representation <Arg>M</Arg>.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="DirectSummandTest" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Returns>true if <Arg>M</Arg> is isomorphic to a direct summand
     of <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DirectSumOfPathAlgebraMatModules" Arg="L" Comm="for a
   list of PathAlgebraMatModule's"/>
   <Returns>the direct sum of the representations contained in the
     list <Arg>L</Arg>.</Returns>
   <Description>The argument <Arg>L</Arg> must be a list
     of <C>PathAlgebraMatModule</C>'s over the same (quotient of a)
     path algebra. In addition three attributes are attached to the
     result, <C>IsDirectSum, DirectSumProjections</C>
     and <C>DirectSumInclusions</C>.  
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsDirectSum" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description>
    An attribute, returns true is <Arg>M</Arg> is constructed via the
    command <C>DirectSumOfPathAlgebraMatModules</C>.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="DirectSumInclusions" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description>
    An attribute, returns the list of inclusions from the individual
    modules to their direct sum, when a direct sum has been
    constructed using <C>DirectSumOfPathAlgebraMatModules</C>.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="DirectSumProjections" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description>
    An attribute, returns the list of projections from the direct sum
    to the individual modules used to construct direct sum, when a
    direct sum has been constructed
    using <C>DirectSumOfPathAlgebraMatModules</C>.
   </Description>
</ManSection>

Using the example above.
<Example><![CDATA[
gap> N2:=DirectSumOfPathAlgebraMatModules([N,N]);
<14-dimensional right-module over <algebra-with-one of dimension 
17 over Rationals>>
gap> proj:=DirectSumProjections(N2);
[ <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> inc:=DirectSumInclusions(N2);  
[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
]]></Example>

<ManSection>
   <Oper Name="1st_Syzygy" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>the first syzygy of the representation <Arg>M</Arg> as a
     representation. The argument <Arg>M</Arg> must be
     a <C>PathAlgebraMatModule</C>. 
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="InAdditiveClosureTest" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Returns>true if <Arg>M</Arg> is in the additive closure of the module
     <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="IsOmegaPeriodic" Arg="M, n" Comm="for a
   PathAlgebraMatModule and a positive integer"/>
   <Returns><C>i</C>, where <C>i</C> is the smallest positive integer
     less or equal <C>n</C> such that the representation <Arg>M</Arg> is isomorphic
     to the <C>i</C>-th syzygy of <Arg>M</Arg>, and false otherwise.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>,
     and <Arg>n</Arg> must be a positive integer.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsInjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>true if the representation <Arg>M</Arg> is injective.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsOmegaPeriodicTest" Arg="M, n" Comm="for a
   PathAlgebraMatModule"/>
   <Returns><C>i</C>, where <C>i</C> less or equal to <C>n</C> and the
     representation <Arg>M</Arg> is isomorphic to the <C>i</C>-th
     syzygy of <Arg>M</Arg>, or else false.  The argument <Arg>M</Arg>
     must be a <C>PathAlgebraMatModule</C> and <C>n</C> is a positive
     integer.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsProjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>true if the representation <Arg>M</Arg> is projective.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsSemisimpleModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>true if the representation <Arg>M</Arg> is semisimple.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsSimpleModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>true if the representation <Arg>M</Arg> is simple.
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="LoewyLength" Arg="M" Comm=""/>
   <Returns>the Loewy length of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function checks that the module <Arg>M</Arg> is a module over
    a finite dimensional quotient of a path algebra, and returns fail
    otherwise (This is not implemented yet). 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="MaximalCommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Returns>a list of three modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>V</Arg>], 
     where <Arg>X</Arg> is a maximal common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero maximal direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ModuleIsomorphismTest" Arg="M, N" Comm=""/>
   <Returns>true or false depending on whether <Arg>M</Arg>
   and <Arg>N</Arg> are isomorphic or not.</Returns> 
   <Description>
    The function first checks if the modules <Arg>M</Arg>
    and <Arg>N</Arg> are modules over the same algebra, and returns fail
    if not. The function returns true if the modules are
    isomorphic, otherwise false. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="nth_Syzygy" Arg="M, n" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>the top of the syzygies until a syzygy is projective or
     the <Arg>n</Arg>-th syzygy has been computed. The
     argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>, and
     the argument <Arg>n</Arg> must be a positive integer.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="nth_SyzygyNC" Arg="M, n" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>the <C>n</C>-th syzygy of the module <Arg>M</Arg>, unless
   the projective dimension of <Arg>M</Arg> is less or equal
   to <C>n-1</C>, in which case it returns the projective dimension of 
   <Arg>M</Arg>. It does not check if the <C>n</C>-th syzygy is
   projective or not. The argument <Arg>M</Arg> must be
   a <C>PathAlgebraMatModule</C>, and the argument <Arg>n</Arg> must
   be a positive integer.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="RadicalOfRep" Arg="M" Comm=""/>
   <Returns>the radical of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the radical of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="RadicalOfRepInclusion"/> computes the inclusion of the
    radical of <Arg>M</Arg> into <Arg>M</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="RadicalSeries" Arg="M" Comm=""/>
   <Returns>the radical series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the radical series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The first vector listed corresponds
     to the top layer, and so on.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleSeries" Arg="M" Comm=""/>
   <Returns>the socle series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the socle series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The last vector listed corresponds
     to the socle layer, and so on backwards.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleOfPathAlgebraMatModule" Arg="M" Comm=""/>
   <Returns>the socle of the module <Arg>M</Arg>.</Returns>
   <Description>
    This operation only return the representation given by the socle
    of the module <Arg>M</Arg>.  The inclusion the socle
    of <Arg>M</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SocleOfPathAlgebraMatModuleInclusion"/>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SubRep" Arg="M, gens" Comm=""/>
   <Returns>the submodule of the module <Arg>M</Arg> generated by the
   elements <Arg>gens</Arg>.</Returns>
   <Description>
    The function checks if <Arg>gens</Arg> are elements
    in <Arg>M</Arg>, and returns an error message otherwise. The
    inclusion of the submodule generated by the
    elements <Arg>gens</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SubRepInclusion"/>.   
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SupportModuleElement" Arg="m" Comm=""/>
   <Returns>the primitive idempotents <Arg>v</Arg> in the algebra over
   which the module containing the element <Arg>m</Arg> is a module,
   such that <Arg>m^v</Arg> is non-zero.</Returns>
   <Description>
    The function checks if <Arg>m</Arg> is an element in a module 
    over a (quotient of a) path algebra, and returns fail otherwise. 
   </Description>
</ManSection>


<ManSection>
   <Oper Name="TopOfRep" Arg="M" Comm=""/>
   <Returns>the top of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the top of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="TopOfRepProjection"/> computes the projection of the
    module <Arg>M</Arg> onto the top of the module <Arg>M</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="GeneratorsOfRep" Arg="M" Comm=""/>
   <Returns>a minimal generator set of the module <Arg>M</Arg> as a
   module of the path algebra it is defined over.</Returns>
</ManSection>

<ManSection>
   <Attr Name="MinimalSetOfGenerators" Arg="M" Comm=""/>
   <Returns>a minimal generator set of the module <Arg>M</Arg> as a
   module of the path algebra it is defined over. </Returns>
</ManSection>

<ManSection>
   <Oper Name="MatricesOfPathAlgebraMatModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Returns>a list of the matrices that defines the
     representation <Arg>M</Arg> as a right module of the acting path
     algebra. The argument <Arg>M</Arg> must be
     a <C>PathAlgebraMatModule</C>.
   </Returns>
   <Description> 
     The list of matrices that are returned are not the same identical
     to the matrices entered to define the representation if there is
     zero vector space in at least one vertex. Then zero matrices of
     the appropriate size are returned. A shortcoming of this that it
     is not defined for modules of quotients of path algebras. 
   </Description>
</ManSection>

</Section>

<Section><Heading>Special representations</Heading>
Here we collect the predefined representations/modules over a finite
  dimensional quotient of a path algebra. 

  <ManSection>
   <Oper Name="BasisOfProjectives" Arg="A" Comm=""/>
   <Returns>a list of bases for all the indecomposable projective
   representations over a finite dimensional (quotient of a) path
   algebra <Arg>A</Arg>. The basis for each indecomposable projective
   is given a list of elements in nontips in <Arg>A</Arg>. 
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a
     finite dimensional (quotient of a) path algebra, and returns an 
     error message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IndecomposableProjectiveRepresentations" Arg="A [, list]" Comm=""/>
   <Returns>a list of all the indecomposable projective
   representations over a finite dimensional (quotient of a) path
   algebra <Arg>A</Arg>, when only one argument is supplied. The
   second argument should be a list of integers, for example [1, 3,
   4], which will return the indecomposable projective corresponding
   to vertex 1, 3 and 4, in this order.  
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a
     finite dimensional (quotient of a) path algebra, and returns an 
     error message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IndecomposableInjectiveRepresentations" Arg="A [, list]" Comm=""/>
   <Returns>a list of all the indecomposable injective
   representations over a finite dimensional (quotient of a) path
   algebra <Arg>A</Arg>, when only one argument is supplied. The
   second argument should be a list of integers, for example [1, 3,
   4], which will return the indecomposable injective corresponding
   to vertex 1, 3 and 4, in this order.
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="VertexSimpleRepresentations" Arg="A" Comm=""/>
   <Returns>a list of all the simple representations over a finite
   dimensional (quotient of a) path algebra <Arg>A</Arg> .
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="ZeroRepresentation" Arg="A" Comm=""/>
   <Returns>the zero representation over a finite dimensional
   (quotient of a) path algebra <Arg>A</Arg> .
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>
</Section>


<Section><Heading>Functors on representations</Heading>

<ManSection>
   <Oper Name="DualOfPathAlgebraMatModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description>
     Takes the a representation <Arg>M</Arg> of a path
     algebra <Math>KQ</Math> and produces the dual of this
     representation over the opposite path algebra <Arg>KQ_op</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DualOfPathAlgebraMatModuleMap" Arg="f" Comm="for a PathAlgebraMatModuleMap"/>
   <Description>
     Takes the a map <Arg>f</Arg> between two
     representations <Arg>M</Arg> and <Arg>N</Arg> over a path
     algebra <Math>A</Math> and produces the dual of this
     map over the opposite path algebra <Arg>A^op</Arg>. 
   </Description>
</ManSection>


<ManSection>
   <Oper Name="DTr" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Oper Name="DTr" Arg="M, n" Comm="for a PathAlgebraMatModule and an integer"/>
   <Returns>the dual of the transpose of the module <Arg>M</Arg> in
   the first variant. In the second form it returns the dual of the
   transpose applied to <Arg>M</Arg> <Arg>n</Arg>
   times. If <Arg>n</Arg> is negative, then powers of <C>TrD</C> are
   computed.</Returns>
   <Description>
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>
     and <Arg>n</Arg> must be an integer. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="TrD" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Oper Name="TrD" Arg="M, n" Comm="for a PathAlgebraMatModule and an
   integer"/>
   <Returns>the transpose of the dual of the module <Arg>M</Arg> in
   the first variant. In the second form it returns the transpose of
   the dual applied to <Arg>M</Arg> <Arg>n</Arg>
   times. If <Arg>n</Arg> is negative, then powers of <C>TrD</C> are
   computed.</Returns>
   <Description>
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>
     and <Arg>n</Arg> must be an integer. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="TransposeOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Returns>the transpose of the module <Arg>M</Arg>.</Returns>
   <Description>
     The argument <Arg>M</Arg> must be a <C>PathAlgebraMatModule</C>. 
   </Description>
</ManSection>

</Section>

<Section><Heading>Vertex Projective Presentations</Heading> 
In general, if <Math>R</Math> is a ring and <Math>e</Math> is an
idempotent of <Math>R</Math> then <Math>eR</Math> is a projective
module of <Math>R</Math>.  Then we can form a direct sum of these
projective modules together to form larger projective module.

One can construct more general modules by providing a <Arg>vertex
projective presentation</Arg>.  In this case, <Math>M</Math> is the
cokernel as given by the following exact sequence:

<Math>\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R
\rightarrow{M} \rightarrow 0</Math>

for some map between <Math>\oplus_{j=1}^{r} w(j)R</Math>
and <Math>\oplus_{i=1}^{g} v(i)R</Math>.  The maps <Math>w</Math>
and <Math>v</Math> map the integers to some idempotent
in <Math>R</Math>.

<ManSection>
   <Func Name="RightProjectiveModule" Arg="A, verts" 
	 Comm=""/>
   <Returns> the right projective module over <Arg>A</Arg> which is
      the direct sum of projective modules of the form <Arg>vA</Arg>
      where the vertices are taken from the list of
      vertices <Arg>verts</Arg>.</Returns>
   <Description>
      In this implemenation the algebra can be a quotient of a path
      algebra.  So if the list was
      <Math>[v,w]</Math> then the module created will be the direct
      sum <Math>vA \oplus wA</Math>, in that order.  Elements of the
      modules are vectors of algebra elements, and in each component,
      each path begins with the vertex in that position in the list of
      vertices.  Right projective modules are implementated as algebra
      modules (see "ref:Representations of Algebras") and all
      operations for algebra modules are applicable to right
      projective modules.  In particular, one can construct submodules
      using `SubAlgebraModule'.
   </Description>
</ManSection>
Here we create the right projective module <Math>P = vA \oplus vA
    \oplus wA</Math>. 

<Example>
gap&gt; F:=GF(11);
GF(11)
gap&gt; Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
&lt;quiver with 3 vertices and 3 arrows&gt;
gap&gt; A:=PathAlgebra(F,Q);
&lt;algebra-with-one over GF(11), with 6 generators&gt;
gap&gt; P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
&lt;right-module over &lt;algebra-with-one over GF(11), with 6 generators&gt;&gt;
gap&gt; Dimension(P);
12
</Example>

  <ManSection>
   <Func Name="Vectorize" Arg="M, components" 
	 Comm=""/>
   <Returns>a vector in the module <Arg>M</Arg> from a list of path
      algebra elements <Arg>components</Arg>, which defines the
      components in the resulting vector.</Returns>
   <Description>
      The returned vector is normalized, so the vector's components
      may not match the input components.
   </Description>
  </ManSection>

In the following example, we create two elements in <Math>P</Math>,
perform some elementwise operations, and then construct a submodule
using the two elements as generators.<P/>

<Example>
gap&gt; p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
gap&gt; p2:=Vectorize(P,[A.a,A.b,A.w]);
[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
gap&gt; 2*p1 + p2;
[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ]
gap&gt; S:=SubAlgebraModule(P,[p1,p2]);
&lt;right-module over &lt;algebra-with-one of dimension 8 over GF(11)&gt;&gt;
gap&gt; Dimension(S);
3
</Example>

  <ManSection>
   <Oper Name="^" Arg="m, a" Comm="Action by a path algebra element"/>
   <Description>
    The operation <Ref Oper="^"/> operates on an element <Arg>m</Arg>
    in a module and an element <Arg>a</Arg> in a path algebra, and it
    returns the element <Arg>m</Arg> multiplied with <Arg>a</Arg>.
    This action is defined by multiplying each component
    in <Arg>m</Arg> by <Arg>a</Arg> on the right.
   </Description>
  </ManSection>

<Example>
gap&gt; p2^(A.c - A.w);
[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
  (Z(11)^5)*w+(Z(11)^0)*c ]
</Example>

  <ManSection>
   <Oper Name="&lt;" Arg="m1, m2" Comm="lessthan"/>
   <Description>
    The operation <Ref Oper="&lt;"/> operates on
    elements <Arg>m1</Arg> and <Arg>m2</Arg> in ????, and it compares
    them.  The result is `true' if <Arg>m1</Arg> is less
    than <Arg>m2</Arg> and false otherwise.  Elements are compared
    componentwise from left to right using the ordering of the
    underlying algebra.  The element <Arg>m1</Arg> is less
    than <Arg>m2</Arg> if the first time components are not equal, the
    component of <Arg>m1</Arg> is less than the corresponding
    component of <Arg>m2</Arg>.
   </Description>
  </ManSection>

<Example>
gap&gt; p1 &lt; p2;
false
</Example>

  <ManSection>
   <Oper Name="/" Arg="M, N" Comm="Factor module"/>
   <Description>
    The operation <Ref Oper="/"/> operates on two finite dimensional
    modules <Arg>M</Arg> and <Arg>N</Arg> over a path algebra?, and it
    constructs the factor module <Math>M/N</Math>.  This module is
    again a right algebra module, and all applicable methods and
    operations are available for the resulting factor module.
    Furthermore, the resulting module is a vector space, so operations
    for computing bases and dimensions are also available.
   </Description>
  </ManSection>
This 

<Example>
gap&gt; PS := P/S;
&lt;9-dimensional right-module over &lt;algebra-with-one of dimension
8 over GF(11)&gt;&gt; 
gap&gt; Basis(PS);
Basis( &lt;9-dimensional right-module over &lt;algebra-with-one of dimension 
8 over GF(11)&gt;&gt;, [ [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ...,
(Z(11)^0)*w ] ],  
  [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ..., (Z(11)^0)*c ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*v, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a*c, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b*c, &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*v, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*b, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ] ] )
</Example>
</Section>
</Chapter>

<Chapter Label="Homomorphisms"><Heading>Homomorphisms of Right Modules
    over Path Algebras</Heading>

This chapter describes the categories, representations, attributes,
  and operations on homomorphisms between representations of quivers. 

The example used throughout this chapter is the following.
<Example><![CDATA[
gap> Q:= Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);;
gap> KQ:= PathAlgebra(Rationals, Q);;
gap> gen:= GeneratorsOfAlgebra(KQ);;
gap> a:= gen[4];;
gap> b:= gen[5];;
gap> c:= gen[6];;
gap> d:= gen[7];;
gap> e:= gen[8];;
gap> rels:= [d*e,c^2,a*c*d-b*d,e*a];;
gap> I:= Ideal(KQ,rels);;
gap> gb:= GBNPGroebnerBasis(rels,KQ);;
gap> gbb:= GroebnerBasis(I,gb);;
gap> A:= KQ/I;;
gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],["c",[[0,0],[1,0]]],
["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap> N:= RightModuleOverQuotientOfPathAlgebra(A,mat);;
]]></Example>


<Section><Heading>Categories and representation of homomorphisms</Heading>

<ManSection>
   <Filt Name="IsPathAlgebraMatModuleMap" Arg="object" Comm="category"/>
   <Description>
     The homomorphisms between modules over a path algebra belongs to
     the categories <Code>IsAdditiveElementWithZero</Code>, 
     <Code>IsGeneralMapping</Code>, <Code>RespectsScalarMultiplication</Code>, 
     <Code>IsTotal</Code> and <Code>IsSingleValued</Code> with the
     added filter of <Ref Filt="IsPathAlgebraMatModuleMap"/> 
   </Description>
</ManSection> 

<ManSection>
   <Oper Name="RightModuleHomOverPathAlgebra" Arg="M, N, mats" Comm=""/>
   <Returns>a homomorphism from the module <Arg>M</Arg> to the
   module <Arg>N</Arg> given by the matrices <Arg>mats</Arg>.</Returns>
   <Description>
     The arguments <Arg>M</Arg> and <Arg>N</Arg> are two modules over
     the same algebra (this is checked), and <Arg>mats</Arg> is a list
     <Code>DimensionVector(M)[i]</Code>
     by <Code>DimensionVector(N)[i]</Code> matrices,
     where <Code>i</Code> runs over all the vertices in the underlying
     quiver. The function checks if <Arg>mats</Arg> is a homomorphism
     from the module <Arg>M</Arg> to the module <Arg>N</Arg> by
     checking that the matrices given in <Arg>mats</Arg> have the
     correct size and satisfy the appropriate commutativity conditions
     with the matrices in the modules given by <Arg>M</Arg>
     and <Arg>N</Arg>. The source (or domain) and the range (or
     codomain) of the homomorphism constructed can by obtained again
     by <Ref Oper="Range"/> and by <Ref Oper="Source"/>, respectively.
   </Description>
</ManSection>

<Example><![CDATA[
gap> L := RightModuleOverQuotientOfPathAlgebra(A,[["a",[0,1]],["b",[0,1]],
["c",[[0]]],["d",[[1]]],["e",[1,0]]]);
<right-module over <algebra-with-one over Rationals, with 8 generators>>
gap> DimensionVector(L);
[ 0, 1, 1 ]
gap> f := RightModuleHomOverPathAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals,
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d],
[(1)*e] ] )> -> <7-dimensional right-module over AlgebraWithOne(Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] ] )> >
gap> IsPathAlgebraMatModuleMap(f);
true
]]></Example>

</Section>

<Section><Heading>Generalities of homomorphisms</Heading>

<ManSection>
   <Oper Name="Range" Arg="f" Comm=""/>
   <Returns>the range (or codomain) the homomorphism <Arg>f</Arg>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="Source" Arg="f" Comm=""/>
   <Returns>the source (or domain) the homomorphism <Arg>f</Arg>.</Returns>
</ManSection>

<Example><![CDATA[
gap> Range(f);
<7-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> Source(f);
<2-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> Source(f) = L;
true
]]></Example>

<ManSection>
   <Oper Name="PreImagesElm" Arg="f, elem" Comm=""/>
   <Returns>a preimage of an element <Arg>elem</Arg> in the range (or
   codomain) the homomorphism <Arg>f</Arg>. The name of this function
   should be changed to PreImagesRepresentative.</Returns>
   <Description>
     The functions checks if <Arg>elem</Arg> is an element in the
     range of <Arg>f</Arg>, and it returns a preimage
     of <Arg>elem</Arg> one exists, and otherwise it
     returns <Code>fail</Code>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ImageElm" Arg="f, elem" Comm=""/>
   <Returns>the image of the element <Arg>elem</Arg> in the source (or
   domain) of the homomorphism <Arg>f</Arg>.</Returns>
   <Description>
     The functions checks if <Arg>elem</Arg> is an element in the
     source of <Arg>f</Arg>, and it returns an error message
     otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ImagesSet" Arg="f, elts" Comm=""/>
   <Returns>the non-zero images of a set of elements <Arg>elts</Arg>
   in the source of the homomorphism <Arg>f</Arg>, or
   if <Arg>elts</Arg> is a submodule of the source of <Arg>f</Arg>, it
   returns a basis of the non-zero elements in the image of the
   homomorphism restricted to the submodule.</Returns>
   <Description>
     The functions checks if the set of elements <Arg>elts</Arg>
     consists of elements in the source of <Arg>f</Arg>, and it
     returns an error message otherwise.
   </Description>
</ManSection>

<Example><![CDATA[
B:=BasisVectors(Basis(N)); 
[ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
gap> PreImagesElm(f,B[4]);     
[ [ 0 ], [ 1 ], [ 0 ] ]
gap> PreImagesElm(f,B[5]);
fail
gap> BL:=BasisVectors(Basis(L));
[ [ [ 0 ], [ 1 ], [ 0 ] ], [ [ 0 ], [ 0 ], [ 1 ] ] ]
gap> ImageElm(f,BL[1]);
[ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ]
gap> ImagesSet(f,L);
[ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
gap> ImagesSet(f,BL);
[ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
]]></Example>

<ManSection>
   <Oper Name="Zero" Arg="f" Comm=""/>
   <Returns>the zero map between <Code>Source(f)</Code>
   and <Code>Range(f)</Code>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="ZeroMap" Arg="M, N" Comm=""/>
   <Returns>the zero map between <Arg>M</Arg> and <Arg>N</Arg>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="IdentityMap" Arg="M" Comm=""/>
   <Returns>the identity map between <Arg>M</Arg> and <Arg>M</Arg>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="\= (maps)" Arg="f,g " Comm=""/>
   <Returns>true,
   if <Code>Source(f)=Source(g)</Code>, <Code>Range(f)=Range(g)</Code>,
   the matrices defining the maps <Arg>f</Arg> and <Arg>g</Arg>
   coincide.</Returns>
</ManSection>

<ManSection>
   <Oper Name="\+ (maps)" Arg="f,g " Comm=""/>
   <Returns>the sum <Arg>f+g</Arg> of the maps <Arg>f</Arg>
   and <Arg>g</Arg>.</Returns>
   <Description>The functions checks if the maps have the same source
   and the same range, and returns an error message otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="\* (maps)" Arg="f,g " Comm=""/>
   <Returns>the composition <Arg>fg</Arg> of the maps <Arg>f</Arg>
   and <Arg>g</Arg>, if the input are maps between representations of
   the same quivers. If <Arg>f</Arg> or <Arg>g</Arg> is a 
   scalar, it returns the natural action of scalars on the maps
   between representations.</Returns>
   <Description>The functions checks if the maps are composable, in
   the first case and in the second case it checks if the scalar is in
   the correct field, and returns an error message otherwise.
   </Description>
</ManSection>

<Example><![CDATA[
gap> z:=Zero(f);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> f = z;
false
gap> Range(f) = Range(z);
true
gap> y := ZeroMap(L,N); 
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> y = z;            
true
gap> id := IdentityMap(N);  
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> f*id;
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> id*f;
Error, codomain of the first argument is not equal to the domain of the second\
 argument,  called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> 
gap> 2*f + z;
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Attr Name="CoKernelOfWhat" Arg="f" Comm=""/>
   <Description>
     If the homomorphism <Arg>f</Arg> has been computed as the
     cokernel of an other homomorphism <Arg>g</Arg>, then <Arg>g</Arg>
     is returned.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="ImageOfWhat" Arg="f" Comm=""/>
   <Description>
     If the homomorphism <Arg>f</Arg> has been computed as the image
     projection or image inclusion of an other
     homomorphism <Arg>g</Arg>, then <Arg>g</Arg> is returned.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsOneToOne" Arg="f" Comm=""/>
   <Description>
     This returns <Code>true</Code> if the homomorphism <Arg>f</Arg>
     is one-to-one.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsOnto" Arg="f" Comm=""/>
   <Description>
     This returns <Code>true</Code> if the homomorphism <Arg>f</Arg>
     is onto.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsIsom" Arg="f" Comm=""/>
   <Description>
     This returns <Code>true</Code> if the homomorphism <Arg>f</Arg>
     is an isomorphism.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsSplitEpi" Arg="f" Comm=""/>
   <Description>
     This returns <Code>false</Code> if the homomorphism <Arg>f</Arg>
     is not a splittable epimorphism, otherwise it returns a
     splitting of the homomorphism<Arg>f</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsSplitMono" Arg="f" Comm=""/>
   <Description>
     This returns <Code>false</Code> if the homomorphism <Arg>f</Arg>
     is not a splittable monomorphism, otherwise it returns a
     splitting of the homomorphism<Arg>f</Arg>.
   </Description>
</ManSection>

<Example><![CDATA[
gap> S := VertexSimpleRepresentations(A)[1];;
gap> H := HomOverPathAlgebra(N,S);; 
gap> IsSplitMono(H[1]);  
false      
gap> f := IsSplitEpi(H[1]);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> IsSplitMono(f);
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Attr Name="IsZeroMap" Arg="f" Comm=""/>
   <Description>
     This returns <Code>true</Code> if the homomorphism <Arg>f</Arg>
     is zero homomorphism.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="KernelOfWhat" Arg="f" Comm=""/>
   <Description>
     If the homomorphism <Arg>f</Arg> has been computed as the kernel
     of an other homomorphism <Arg>g</Arg>, then <Arg>g</Arg> is
     returned. 
   </Description>
</ManSection>


</Section>

<Section><Heading>Homomorphisms and modules constructed from homomorphisms and modules</Heading>

<ManSection>
   <Attr Name="Coker" Arg="f" Comm=""/>
   <Attr Name="CokerProjection" Arg="f" Comm=""/>
   <Returns>the cokernel of a homomorphism <Arg>f</Arg> between two
   representations of a quiver.</Returns>
   <Description>
    The first variant <Ref Oper="Coker"/> returns the cokernel of the
    homomorphism <Arg>f</Arg> as a representation of the quiver, while
    the latter one returns the projection homomorphism from the range
    of the homomorphism <Arg>f</Arg> to the cokernel of the
    homomorphism <Arg>f</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="EndOverPathAlgebra" Arg="M" Comm=""/>
   <Returns>the endomorphism ring of <Arg>M</Arg> as a subalgebra of
   the direct sum of the full matrix rings of <Arg>dim_M[i] x
   dim_M[i]</Arg>, where <Arg>i</Arg> runs over all vertices.</Returns>
   <Description>
    The endomorphism is an algebra with one, and one can apply for
    example <Code>RadicalOfAlgebra</Code> to find the radical of the
    endomorphism ring. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="HomFromProjective" Arg="m, M" Comm=""/>
   <Returns>the homomorphism from the indecomposable projective
   module defined by the support of the element <Arg>m</Arg>
   to the module <Arg>M</Arg>.</Returns>
   <Description>
    The function checks if <Arg>m</Arg> is an elememt in <Arg>M</Arg>
    and if the element <Arg>m</Arg> is uniform. Otherwise it returns
    fail. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="HomOverPathAlgebra" Arg="M, N" Comm=""/>
   <Returns>a basis for the homomorphisms from <Arg>M</Arg>
   to <Arg>N</Arg>.</Returns>
   <Description>
    The function checks if <Arg>M</Arg> and <Arg>N</Arg> are modules
    over the same algebra, and returns an error message and fail
    otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="Im" Arg="f" Comm=""/>
   <Attr Name="ImProjection" Arg="f" Comm=""/>
   <Attr Name="ImInclusion" Arg="" Comm=""/>
   <Attr Name="ImProjectionInclusion" Arg="" Comm=""/>
   <Returns>the image of a homomorphism <Arg>f</Arg> between two
   representations of a quiver.</Returns>
   <Description>
    The first variant <Ref Attr="Im"/> returns the image of the
    homomorphism <Arg>f</Arg> as a representation of the quiver. The
    second returns the projection from the source of <Arg>f</Arg> to
    the image into the source of the homomorphism <Arg>f</Arg>. The
    third returns the inclusion of the image into the range of the
    homomorphism <Arg>f</Arg>. The last one returns both the
    projection and the inclusion. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="Ker" Arg="f" Comm=""/>
   <Attr Name="KerInclusion" Arg="M" Comm=""/>
   <Returns>the kernel of a homomorphism <Arg>f</Arg> between two
   representations of a quiver.</Returns>
   <Description>
    The first variant <Ref Attr="Ker"/> returns the kernel of the
    homomorphism <Arg>f</Arg> as a representation of the quiver, while
    the latter one returns the inclusion homomorphism of the kernel
    into the source of the homomorphism <Arg>f</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="LeftMinimalVersion" Arg="f" Comm=""/>
   <Description>
     It returns the left minimal version <Arg>f'</Arg> of the
     homomorphism <Arg>f</Arg> together with the a list <Code>B</Code>
     of modules such that the direct sum of the
     modules, <Code>Source(f')</Code> and the modules on the
     list <Code>B</Code> is isomorphic to <Code>Source(f)</Code>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="LiftingInclusionMorphisms" Arg="f, g" Comm=""/>
   <Description>
    Given two inclusions <Math>f\colon A\to C</Math> and <Math>g\colon
    B\to C</Math>, this function constructs a morphism (inclusion)
    from <Math>A</Math> to <Math>B</Math>, whenever the image
    of <Arg>f</Arg> is contained in the image of <Arg>g</Arg>.
    Otherwise the function returns fail. The function checks
    if <Arg>f</Arg> and <Arg>g</Arg> have the same range and if the
    image of <Arg>f</Arg> is contained in the image of <Arg>g</Arg>. 
   </Description>
</ManSection>


<ManSection>
   <Oper Name="LiftingMorphismFromProjective" Arg="f, g" Comm=""/>
   <Description>
    Given two morphisms <Math>f\colon P\to C</Math> and <Math>g\colon
    B\to C</Math>, where  P  is a direct sum of indecomposable
    projective modules constructed
    via <Code>DirectSumOfPathAlgebraMatModules</Code>
    and  <Arg>g</Arg> an epimorphism, this function finds a lifting
    of  <Arg>f</Arg>  to  <Math>B</Math>. The function checks
    if <Math>P</Math> is a direct sum of indecomposable projective
    modules, if <Arg>g</Arg> is onto and if  <Arg>f</Arg>
    and <Arg>g</Arg> have the same range.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="RightMinimalVersion" Arg="f" Comm=""/>
   <Description>
     It returns the right minimal version <Arg>f'</Arg> of the
     homomorphism <Arg>f</Arg> together with the a list <Code>B</Code>
     of modules such that the direct sum of the
     modules, <Code>Range(f')</Code> and the modules on the
     list <Code>B</Code> is isomorphic to <Code>Range(f)</Code>.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="MinimalLeftApproximation" Arg="C, M" Comm=""/>
   <Description>
     It returns the minimal left <Code>add M</Code>-approximation of
     the module <Arg>C</Arg>. Note: Order of the arguments are
     opposite of the order for minimal right approximations. 
   </Description>
</ManSection>


<ManSection>
   <Attr Name="MinimalRightApproximation" Arg="M, C" Comm=""/>
   <Description>
     It returns the minimal right <Code>add M</Code>-approximation of
     the module <Arg>C</Arg>. Note: Order of the arguments are
     opposite of the order for minimal left approximations.
   </Description>
</ManSection>

<Example><![CDATA[
gap> H:= HomOverPathAlgebra(N,N);;
gap> RightMinimalVersion(H[1]);   
[ <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  [ <6-dimensional right-module over <algebra-with-one of dimension 
        17 over Rationals>> ] ]
gap> LeftMinimalVersion(H[1]);             
[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  [ <6-dimensional right-module over <algebra-with-one of dimension 
        17 over Rationals>> ] ]
gap> S:=VertexSimpleRepresentations(A)[1];;
gap> MinimalRightApproximation(N,S);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> S:=VertexSimpleRepresentations(A)[3];;
gap> MinimalLeftApproximation(S,N);        
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Oper Name="MorphismOnKernel" Arg="f, g, beta, alpha" Comm="for a
   commutative diagram of maps"/>
   <Oper Name="MorphismOnImage" Arg="f, g, beta, alpha" Comm="for a
   commutative diagram of maps"/>
   <Oper Name="MorphismOnCokernel" Arg="f, g, beta, alpha" Comm="for a
   commutative diagram of maps"/>
   <Returns>the morphism induced on the kernels, the images or the
   cokernels of the morphisms <Arg>f</Arg> and <Arg>g</Arg>,
   respectively.</Returns>  
   <Description>
    It is checked 
    if <Arg>f</Arg>, <Arg>g</Arg>, <Arg>beta</Arg>, <Arg>alpha</Arg>
    forms a commutative diagram, that is, if <Math>f \alpha - \beta g
    = 0</Math>. 
   </Description>
</ManSection>



<ManSection>
   <Oper Name="ProjectiveCover" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Returns>the projective cover of <Arg>M</Arg>, that is, returns the
   map <Arg>P(M) --> M</Arg>.</Returns>
   <Description>
     If the module <Arg>M</Arg> is zero, then the functions returns
     the zero module.<Arg>g</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="PullBack" Arg="f, g" Comm="for two maps between modules
   with common target"/>
   <Returns>the pullback of the maps <Arg>f</Arg> and <Arg>g</Arg>.</Returns>
   <Description>
    It is checked if <Arg>f</Arg> and <Arg>g</Arg> has the same target. The
    pullback is returned as two homomorphism from the pullback to the
    source of <Arg>f</Arg> and to the source of <Arg>g</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="PushOut" Arg="f, g" Comm="for two maps between modules
   with common source"/>
   <Returns>the pushout of the maps <Arg>f</Arg> and <Arg>g</Arg>.</Returns>
   <Description>
    It is checked if <Arg>f</Arg> and <Arg>g</Arg> has the same source. The
    pushout is returned as two homomorphism from the target
    of <Arg>f</Arg> and from the target of <Arg>g</Arg> to the pushout. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="RadicalOfRepInclusion" Arg="M" Comm=""/>
   <Returns>the inclusion of the radical of the module <Arg>M</Arg>
   into <Arg>M</Arg>.</Returns>
   <Description>
    The representation given by the submodule generated by the
    generators <Arg>gens</Arg> can be accessed
    using <Code>Source</Code>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleOfPathAlgebraMatModuleInclusion" Arg="M" Comm=""/>
   <Returns>the inclusion of the socle of the module <Arg>M</Arg>
   into <Arg>M</Arg>.</Returns>
   <Description>
    The representation given by the socle of <Arg>M</Arg> can be accessed
    using <Code>Source</Code>, or it can be computed directly via the
    command <Ref Oper="SocleOfPathAlgebraMatModule"/>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SubRepInclusion" Arg="M, gens" Comm=""/>
   <Returns>the inclusion of the submodule generated by the
   generators <Arg>gens</Arg> into the module <Arg>M</Arg></Returns>
   <Description>
    The function checks if <Arg>gens</Arg> are elements
    in <Arg>M</Arg>, and returns an error message otherwise. The
    representation given by the submodule generated by the
    generators <Arg>gens</Arg> can be accessed
    using <Code>Source</Code>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="TopOfRepProjection" Arg="M" Comm=""/>
   <Returns>the projection from the module <Arg>M</Arg> to the top of
   the module <Arg>M</Arg>
   into <Arg>M</Arg>.</Returns>
   <Description>
    The representation given by the top of the module <Arg>M</Arg> can
    be accessed using <Code>Range</Code> of the homomorphism.
   </Description>
</ManSection>
</Section>

<Section><Heading>Homological algebra</Heading>

<ManSection>
   <Oper Name="ExtOne" Arg="M, N" Comm=""/>
   <Returns>the map from the first syzygy, <Arg>Omega(M)</Arg> to the
   projective cover, <Arg>P(M)</Arg> of the module <Arg>M</Arg>, and
   in addition a basis of <Math>Ext^1(M,N)</Math> in terms of elements
   in <Math>Hom(Omega(M),N)</Math>.</Returns>
   <Description>
    The function checks if arguments <Arg>M</Arg> and <Arg>N</Arg> are
    modules of the same algebra, and returns an error message
    otherwise. It <Math>Ext^1(M,N)</Math> is zero, the functions
    returns an empty list.
   </Description>
</ManSection>

</Section>

<Section><Heading>Auslander-Reiten theory</Heading>

<ManSection>
   <Oper Name="AlmostSplitSequence" Arg="M" Comm=""/>
   <Returns>the almost split sequence ending in the
   module <Arg>M</Arg> if it is indecomposable and not projective. It
   returns the almost split sequence in terms of two maps, a left
   minimal almost split map and a right minimal almost split map.
   </Returns>
   <Description>
    The range of the right minimal almost split map is not equal to
    the module <Arg>M</Arg> one started with, but isomorphic.  
   </Description>
</ManSection>

</Section>
</Chapter>



<Chapter>
<Heading>Chain complexes</Heading>
TODO


<Section>
<Heading>Representation of categories</Heading>

A chain complex consists of objects and morphisms from some category.
In QPA, this category will usually be the category of right modules
over some quotient of a path algebra.

(TODO)

</Section>


<Section>
<Heading>Making a complex</Heading>

The most general constructor for complexes is the function
<Ref Func="Complex"/>.  In addition to this, there are constructors
for common special cases:
<List>
<Item><Ref Func="ZeroComplex"/></Item>
<Item><Ref Func="SingleObjectComplex"/></Item>
<Item><Ref Func="FiniteComplex"/></Item>
<Item><Ref Func="ShortExactSequence"/></Item>
</List>
<!-- TODO: ComplexByDifferentialList -->

<ManSection>
<Filt Type="Category" Name="IsComplex"/>
<Description>
The category for chain complexes.
</Description>
</ManSection>

<ManSection>
<Filt Type="Category" Name="IsZeroComplex"/>
<Description>
Category for zero complexes, subcategory of <Ref Filt="IsComplex"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Complex"
      Arg="cat, baseDegree, middle, positive, negative"/>
<Returns>A newly created chain complex</Returns>
<Description>
The first argument, <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The rest of the arguments describe the differentials of the complex.
These are divided into three parts: one finite (<Q>middle</Q>) and two
infinite (<Q>positive</Q> and <Q>negative</Q>).  The positive part
contains all differentials in degrees higher than those in the middle
part, and the negative part contains all differentials in degrees
lower than those in the middle part.  (The middle part may be placed
anywhere, so the positive part can -- despite its name -- contain some
differentials of negative degree.  Conversely, the negative part can
contain some differentials of positive degree.)<P/>

The argument <Arg>middle</Arg> is a list containing the differentials
for the middle part.  The argument <Arg>baseDegree</Arg> gives the
degree of the first differential in this list.  The second
differential is placed in degree <M><Arg>baseDegree</Arg>+1</M>, and
so on.  Thus, the middle part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>).
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero objects and zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the differentials in <Code>L</Code> repeated infinitely many times.
  The convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the differential which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the differentials in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>Complex</Code> constructor, but will be called later as
  the differentials in this part are needed.  The function
  call <Code>f(C,i)</Code> (where <Code>C</Code> is the complex
  and <Code>i</Code> an integer) should produce the differential in
  degree <Code>i</Code>.  The function may use <Code>C</Code> to look
  up other differentials in the complex, as long as this does not
  cause an infinite loop.  If <Code>store</Code> is <Code>true</Code>
  (or not specified), each computed differential is stored, and they
  are computed in order from the one closest to the middle part,
  regardless of which order they are requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the differentials in this part.  For the first
  differential in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next differential, <Code>f</Code> is called with
  the first differential as argument, and so on.  Thus, the
  differentials are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each differential is stored when it has been computed.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ZeroComplex" Arg="cat"/>
<Returns>A newly created zero complex</Returns>
<Description>
This function creates a zero complex (a complex consisting of only
zero objects and zero morphisms) over the category described by the
<Ref Filt="IsCat"/> object <Arg>cat</Arg>.
</Description>
</ManSection>

<ManSection>
<Func Name="FiniteComplex" Arg="cat, baseDegree, differentials"/>
<Returns>A newly created complex</Returns>
<Description>
This function creates a complex where all but finitely many objects
are the zero object.<P/>

The argument <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The argument <Arg>differentials</Arg> is a list of morphisms.  The
argument <Arg>baseDegree</Arg> gives the degree for the first
differential in this list.  The subsequent differentials are placed in
degrees <M><Arg>baseDegree</Arg>+1</M>, and so on.<P/>

This means that the <Arg>differentials</Arg> argument specifies the
differentials in degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>);
</Display>
and thus implicitly the objects in degrees
<Display>
<Arg>baseDegree</Arg> - 1,\quad
<Arg>baseDegree</Arg>,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>).
</Display>
All other objects in the complex are zero.
</Description>
</ManSection>

</Section>


<Section>
<Heading>Information about a complex</Heading>

</Section>


<Section>
<Heading>Transforming and combinig complexes</Heading>

</Section>


<Section>
<Heading>Chain maps</Heading>

</Section>

</Chapter>
</Body>

<Appendix Label="Appendix">
<Heading>An Appendix</Heading>
<Label Name="ElevenBack"/>

This is an appendix. 
</Appendix>

<Bibliography Databases="" Style="alpha"/>
<TheIndex/>

</Book>

