<?xml version="1.0" encoding="UTF-8"?>

<!-- $Id: qpadocumentation.xml,v 1.35 2012/05/02 14:21:36 wralsen Exp $ -->

<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<!-- [ <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">--&gt;</Alt>'>
 ]> -->

<?LaTeX ExtraPreamble="
\usepackage{amsmath}
\usepackage[all]{xy}
\newcommand{\tensor}{\otimes}
\newcommand{\quiverproduct}{\times}
\newcommand{\Hom}{\operatorname{Hom}\nolimits}
\newcommand{\End}{\operatorname{End}\nolimits}
\newcommand{\Ext}{\operatorname{Ext}\nolimits}
"?>

<Book Name="QPA documentation">

<TitlePage>
  <Title>QPA</Title>
  <Subtitle>Quivers and Path Algebras</Subtitle>
  <Version>Version <#Include SYSTEM "../version"></Version>
  <TitleComment>
  We can add a comment here.
  </TitleComment>
  <Author>The QPA-team<Br/>
          <URL>http://sourceforge.net/projects/quiverspathalg/</URL><Br/>
          (See also <URL>http://www.math.ntnu.no/~oyvinso/QPA/</URL>) 
  </Author>
  <Date>September 2010</Date>
  <Address>
  Virginia Tech, Blacksburg, USA<Br/>
  NTNU, Trondheim, Norway<Br/> 
  </Address>
  <Abstract>
    
      
  </Abstract>
  <Copyright>&copyright; 2010-2020 The QPA-team. 
  </Copyright>
  <Acknowledgements>The system design of <Package>QPA</Package> was initiated by
Edward L. Green, Lenwood S. Heath, and Craig A. Struble.  It was
continued and completed by Randall Cone and Edward Green.  We would
like to thank the following people for their contributions:

<Table Align="ll">
<Row><Item>Gerard Brunick</Item><Item>Quivers, path algebras</Item></Row>
<Row><Item>Randall Cone</Item><Item>Code modernization and cleanup,
GBNP interface (for Groebner bases),</Item></Row> 
<Row><Item> </Item><Item>projective resolutions, user documentation</Item></Row>
<Row><Item>George Yuhasz</Item><Item>User documentation, matrix
    representations of path algebras</Item></Row>
</Table>
  </Acknowledgements>
  <Colophon>This is the Colophon page.
  </Colophon>
</TitlePage>

<TableOfContents/>

<Body>

<Chapter Label="Quickstart"><Heading>Quick Start</Heading>

This chapter is intended for those who would like to get started with
<Package>QPA</Package> right away by playing with a few examples.  A
simple example is presented first:

<!-- Example 9 from GBNP: -->
<Section Label="Example 1"><Heading>Example 1</Heading>

We construct a quiver <Math>q</Math>, i.e. a finite directed graph, with one
vertex and two loops:

<Example><![CDATA[
gap> q := Quiver(["u"],[["u","u","a"],["u","u","b"]]);
<quiver with 1 vertices and 2 arrows>
]]></Example>

We can request the list of vertices and the list of arrows
for <Math>q</Math>:

<Example> 
gap&gt; VerticesOfQuiver(q);
[ u ]
gap&gt; ArrowsOfQuiver(q);
[ a, b ]
</Example>

Next we create the path algebra <Math>pa</Math> from <Math>q</Math>
over the rational numbers:

<Example> 
gap&gt; pa := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 3 generators&gt;
</Example>

In this case it is interesting to note that we've created an algebra
isomorphic to the free algebra on two generators.  We now retrieve and
label the generators and multiplicative identity for <Math>pa</Math>:

<Example>
gap&gt; gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*a, (1)*b ]
gap&gt; u := gens[1];
(1)*u
gap&gt; a := gens[2];
(1)*a
gap&gt; b := gens[3];
(1)*b
gap&gt; id := One(pa);
(1)*u
</Example>

As we expect, in this case, the multiplicative identity
for <Math>pa</Math> and the single vertex <Math>u</Math> are one in
the same:

<Example> 
gap&gt; u = id;
true
</Example>

We now create a list of generators for an ideal and ask for its
Groebner basis: 
<Example>
gap&gt; polys := [a*b*a-b,b*a*b-b];
[ (-1)*b+(1)*a*b*a, (-1)*b+(1)*b*a*b ]
gap&gt; gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*a*b+(1)*b*a, (-1)*a*b+(1)*b^2, (-1)*b+(1)*a^2*b ]
</Example>

Next, we create an ideal <Math>I</Math> in {\GAP} using the Groebner
basis <Math>gb</Math> found above, and then the
quotient <Math>pa/I</Math>:
<Example>
gap&gt; I := Ideal(pa,gb);
&lt;two-sided ideal in &lt;algebra-with-one over Rationals, with 3
generators&gt;, 
 (3 generators)&gt;
</Example>

Once we have the generators for a Groebner basis, we set the
appropriate property for the ideal <Math>I</Math>:
<Example>
gap&gt; grb := GroebnerBasis(I,gb);    
&lt;partial two-sided Groebner basis containing 3 elements&gt;
</Example>
</Section>

<Section><Heading>Example 2</Heading>

In this next example we create another path algebra that is
essentially the free algebra on six generators.  We then find the
Groebner basis for a commutative example from (create bibliographic
reference here) the book "Some Tapas of Computer Algebra" by
A.M. Cohen, H. Cuypers, H. Sterk.

We create the underlying quiver, and from it the path algebra over
the rational numbers:
<Example> 
gap&gt; q := Quiver(["u"],[["u","u","a"],["u","u","b"], ["u","u","c"],
&gt;                    ["u","u","d"],["u","u","e"],["u","u","f"]]);
&lt;quiver with 1 vertices and 6 arrows&gt;
gap&gt; fq := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 7 generators&gt;
</Example>

Next, the generators are labeled and the list of polynomials is
entered:
<Example>
gap&gt; gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e, (1)*f ]
gap&gt; u := gens[1];; a := gens[2];; b := gens[3];; c := gens[4];;
gap&gt; d := gens[5];; e := gens[6];; f := gens[7];;
gap&gt; polys := [ e*a,
&gt;            a^3 + f*a,
&gt;            a^9 + c*a^3,
&gt;            a^81 + c*a^9 + d*a^3,
&gt;            a^27 + d*a^81 + e*a^9 + f*a^3,
&gt;            b + c*a^27 + e*a^81 + f*a^9,
&gt;            c*b + d*a^27 + f*a^81,
&gt;            a + d*b + e*a^27,
&gt;            c*a + e*b + f*a^27,
&gt;            d*a + f*b,
&gt;            b^3 - b,
&gt;            a*b - b*a, a*c - c*a,
&gt;            a*d - d*a, a*e - e*a,
&gt;            a*f - f*a, b*c - c*b,
&gt;            b*d - d*b, b*e - e*b,
&gt;            b*f - f*b, c*d - d*c,
&gt;            c*e - e*c, c*f - f*c,
&gt;            d*e - e*d, d*f - f*d,
&gt;            e*f - f*e
&gt; ];;
</Example>

Finally, the Groebner basis is found:
<Example>
gap&gt; gb := GBNPGroebnerBasis(polys,fq);
[ (1)*a, (1)*b, (-1)*c*d+(1)*d*c, (-1)*c*e+(1)*e*c, (-1)*d*e+(1)*e*d,
  (-1)*c*f+(1)*f*c, (-1)*d*f+(1)*f*d, (-1)*e*f+(1)*f*e ]
</Example>
</Section>

<Section><Heading>Example 3</Heading>

The next example is from B. Keller's PhD thesis, p. 26:

<Example>
gap&gt; q := Quiver(["u","v"],[["u","v","c"],["u","u","b"],["u","u","a"]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; pa := PathAlgebra(Rationals,q);
&lt;algebra-with-one over Rationals, with 5 generators&gt;
gap&gt; 
gap&gt; # Get generators of path algebra:
gap&gt; gens := GeneratorsOfAlgebra(pa);
[ (1)*u, (1)*v, (1)*c, (1)*b, (1)*a ]
gap&gt; u := gens[1];; v := gens[2];; c := gens[3];;
gap&gt; b := gens[4];; a := gens[5];; id := One(pa);;
gap&gt; 
gap&gt; polys := [a*b*c+b*a*b+a+c];
[ (1)*c+(1)*a+(1)*b*a*b+(1)*a*b*c ]
gap&gt; gb := GBNPGroebnerBasis(polys,pa);
[ (-1)*b*c+(1)*a*c, (1)*a+(1)*b*a*b, (1)*c+(1)*a*b*c, (-1)*b*a^2+(1)*a^2*b ]
</Example>
</Section>

<Section><Heading>Example 4</Heading>

Here's an example that doesn't meet our necessary criteria that all
elements in a generating set have monomials in the arrow ideal.  Since
the given path algebra is isomorphic to a free algebra, the single
vertex is sent to the identity and there are no complications.

First, we set up the algebra and generating set:
<Example>
gap&gt; q := Quiver(["u"],[["u","u","x"],["u","u","y"]]);
&lt;quiver with 1 vertices and 2 arrows&gt;
gap&gt; f := Rationals;
Rationals
gap&gt; fq := PathAlgebra(f,q);
&lt;algebra-with-one over Rationals, with 3 generators&gt;
gap&gt; 
gap&gt; # Get generators of path algebra:
gap&gt; gens := GeneratorsOfAlgebra(fq);
[ (1)*u, (1)*x, (1)*y ]
gap&gt; u := gens[1];; x := gens[2];; y := gens[3];; id := One(fq);;
gap&gt; polys := [x*y-y*x,x^2*y-id,x*y^2-id];
[ (1)*x*y+(-1)*y*x, (-1)*u+(1)*x^2*y, (-1)*u+(1)*x*y^2 ]
</Example>

Then we ask GBNP for its Groebner basis:

<Example>
gap&gt; gb := GBNPGroebnerBasisNC(polys,fq);
The given path algebra is isomorphic to a free algebra.
[ (-1)*x+(1)*y, (-1)*u+(1)*x^3 ]
</Example>

NOTE: It is important to realize that we've used the routine
`GBNPGroebnerBasisNC' which doesn't check that all elements in a given
list have non-vertex monomials.

So, if we run the standard <Package>QPA</Package> Groebner basis
routine on this example, we get the following:

<Example>
gap&gt; GBNPGroebnerBasis(polys,pa);
Please make sure all elements are in the given path algebra, 
and each summand of each element is not (only) a vertex.
false
</Example>
</Section>
</Chapter>

<Chapter Label="Quivers"><Heading>Quivers</Heading>

<Section><Heading>Information class, Quivers</Heading>

A quiver <Math>Q</Math> is a set derived from a labeled directed
multigraph with loops <Math>\Gamma</Math>.  An element
of <Math>Q</Math> is called a *path*, and falls into one of three
classes.  The first class is the set of *vertices* of
<Math>\Gamma</Math>.  The second class is the set of *walks*
in <Math>\Gamma</Math> of length at least one, each of which is
represented by the corresponding sequence of *arrows*
in <Math>\Gamma</Math>.  The third class is the singleton set
containing the distinguished *zero path*, usually
denoted <Math>0</Math>.  An associative multiplication is defined
on <Math>Q</Math>.<P/>

This chapter describes the functions in <Package>QPA</Package> that
deal with paths and quivers.  The functions for constructing paths in
Section <Ref Sect="Constructing Paths"/> are normally not useful in
isolation; typically, they are invoked by the functions for
constructing quivers in Section <Ref Sect="Constructing Quivers"/>.

  <ManSection>
   <InfoClass Name="InfoQuiver" Comm="InfoClass for functions dealing
   with quivers"/> 
   <Description>
     is the info class for functions dealing with quivers.
   </Description>
  </ManSection>

<!-- The quiver functionality was designed and implemented by Craig --
  -- A. Struble. --> 
</Section> 

<Section  Label="Constructing Quivers"><Heading>Constructing Quivers</Heading>
  <ManSection>
   <Func Name="Quiver" Arg="N, arrows" 
	 Comm="creates a quiver"/>
   <Func Name="Quiver" Arg="vertices,
	 arrows" 
	 Comm="creates a quiver"/>
   <Func Name="Quiver" Arg="adjacencymatrix" 
	 Comm="creates a quiver"/>
   <Description>Arguments: First construction: <Arg>N</Arg> -- number of vertices, <Arg>arrows</Arg> -- a list of arrows to specify the graph <Math>\Gamma</Math>. Second construction: <Arg>vertices</Arg> -- a list of vertex names, <Arg>arrows</Arg> -- a list of arrows. Third construction: takes an adjacency matrix for the graph <Math>\Gamma</Math>.
   
   <Br /></Description>
   <Returns>a quiver, which satisfies the property
   <Ref Prop="IsQuiver"/>.</Returns> 
   <Description>
In the first and third constructions, the vertices are named `v1, v2,
...'.  In the second construction, unique vertex names are given as
strings in the list that is the first parameter.  Each arrow is a list
consisting of a source vertex and a target vertex, followed optionally
by an arrow name as a string.<P/>

Vertices and arrows are referenced as record components using the dot
(`.') operator.
   </Description>
  </ManSection>

<Example> 
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; VerticesOfQuiver(q1);
[ u, v ]
gap&gt; ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap&gt; q2 := Quiver(2,[[1,1],[2,1],[1,2]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; ArrowsOfQuiver(q2);
[ a1, a2, a3 ]
gap&gt; VerticesOfQuiver(q2);
[ v1, v2 ]
gap&gt; q3 := Quiver(2,[[1,1,"a"],[2,1,"b"],[1,2,"c"]]);
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; ArrowsOfQuiver(q3);
[ a, b, c ]
gap&gt; q4 := Quiver([[1,1],[2,1]]);
&lt;quiver with 2 vertices and 5 arrows&gt;
gap&gt; VerticesOfQuiver(q4);
[ v1, v2 ]
gap&gt; ArrowsOfQuiver(q4);
[ a1, a2, a3, a4, a5 ]
gap&gt; SourceOfPath(q4.a2);
v1
gap&gt; TargetOfPath(q4.a2);
v2
</Example>

  <ManSection>
   <Func Name="OrderedBy" Arg="quiver, ordering" 
	 Comm="Quivers:OrderedBy"/>
   <Returns>a copy of <Arg>quiver</Arg> whose elements are ordered
     by <Arg>ordering</Arg>. The default ordering of a quiver is
     length left lexicographic.  See Section
     <Ref Sect="qpa:Orderings"/> for more information.</Returns>
   <Description>
   </Description>
  </ManSection>
</Section>

<Section><Heading>Categories and Properties of Quivers</Heading>

  <ManSection>
   <Prop Name="IsQuiver" Arg="object" Comm="property, whether object
   is a quiver"/>
   <Returns>
    true when <Arg>object</Arg> is a quiver.
   </Returns>
  </ManSection>

  <ManSection>
   <Prop Name="IsAcyclicQuiver" Arg="quiver" Comm="property, whether object
   is a quiver with no cycles"/>
   <Returns>
    true when <Arg>quiver</Arg> is a quiver with no oriented cycles.
   </Returns>
  </ManSection>

<Example>
gap&gt; quiver1 := Quiver(2,[[1,2]]);
&lt;quiver with 2 vertices and 1 arrows&gt;
gap&gt; IsQuiver("v1");
false
gap&gt; IsQuiver(quiver1);
true
gap&gt; IsAcyclicQuiver(quiver1);
true
gap&gt; quiver2 := Quiver(["u","v"],[["u","v"],["v","u"]]);
&lt;quiver with 2 vertices and 2 arrows&gt;
gap&gt; IsAcyclicQuiver(quiver2);
false
gap&gt; IsFinite(quiver1);
true
gap&gt; IsFinite(quiver2);
false
</Example>
</Section>

<Section Label="qpa:Orderings"><Heading>Orderings of paths in a
    quiver</Heading> 

  To be written. 

</Section>

<Section><Heading>Attributes and Operations for Quivers</Heading>

  <ManSection>
   <Oper Name="." Arg="Q, element" Comm=""/>
   <Description> 
    Arguments: <Arg>Q</Arg> -- a quiver,
    and <Arg>element</Arg> -- a vertex or an arrow.
   <P />
    The operation <Ref Oper="."/> allows access to
    generators of the quiver. If you have named your vertices and
    arrows then the access looks like `<Arg>Q</Arg>.<Arg>name of
    element</Arg>'.  If you have not named the elements of the quiver
    then the default names are v1, v2, ... and a1, a2, ... in the order
    they are created.
   </Description>
  </ManSection>

  <ManSection>
   <Attr Name="VerticesOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
    a list of paths that are vertices
    in <Arg>quiver</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="ArrowsOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
    a list of paths that are arrows
    in <Arg>quiver</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="AdjacencyMatrixOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
    the adjacency matrix of <Arg>quiver</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="GeneratorsOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
    a list of the vertices and the arrows
    in <Arg>quiver</Arg>. 
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="NumberOfVertices" Arg="quiver" Comm=""/>
   <Returns>
    the number of vertices in <Arg>quiver</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="NumberOfArrows" Arg="quiver" Comm=""/>
   <Returns>
    the number of arrows in <Arg>quiver</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="OrderingOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
    the ordering used to order elements
    in <Arg>quiver</Arg>. See Section <Ref Sect="qpa:Orderings"/> for
    more information.
   </Returns>
  </ManSection>

  <ManSection>
   <Oper Name="OppositeOfQuiver" Arg="quiver" Comm=""/>
   <Returns>
     the opposite
     quiver of <Arg>quiver</Arg>, where the vertices are labelled "name in original
     quiver" + "_op" and the arrows are labelled "name in orginal
     quiver" + "_op". 
   </Returns>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; q1.a;
a
gap&gt; q1.v;
v
gap&gt; VerticesOfQuiver(q1);
[ u, v ]
gap&gt; ArrowsOfQuiver(q1);
[ a, b, c, d ]
gap&gt; AdjacencyMatrixOfQuiver(q1);
[ [ 1, 1 ], [ 1, 1 ] ]
gap&gt; GeneratorsOfQuiver(q1);
[ u, v, a, b, c, d ]
gap&gt; NumberOfVertices(q1);
2
gap&gt; NumberOfArrows(q1);
4
gap&gt; OrderingOfQuiver(q1);
&lt;length left lexicographic ordering&gt;
gap&gt; q1_op := OppositeOfQuiver(q1);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; VerticesOfQuiver(q1);
[ u_op, v_op ]
gap&gt; ArrowsOfQuiver(q1);
[ a_op, b_op, c_op, d_op ]
</Example>
</Section>

<Section><Heading>Categories and Properties of Paths</Heading>

<ManSection>
   <Filt Name="IsPath" Arg="object" Comm="" Type="category"/>
   <Description>
      All path objects are in this category.
   </Description>
  </ManSection>

<ManSection>
   <Filt Name="IsVertex" Arg="object" Comm="" Type="category"/>
   <Description>
      All vertices are in this category.
   </Description>
  </ManSection>

<ManSection>
   <Filt Name="IsArrow" Arg="object" Comm="" Type="category"/>
   <Description>
      All arrows are in this category.
   </Description>
  </ManSection>


  <ManSection>
   <Prop Name="IsZeroPath" Arg="object" Comm="checks if object is zero"/>
   <Description>
     is true when <Arg>object</Arg> is the zero path.
   </Description>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; IsPath(q1.b);
true
gap&gt; IsPath(q1.u);
true
gap&gt; IsVertex(q1.c);
false
gap&gt; IsZeroPath(q1.d);
false
</Example>
</Section>

<Section><Heading>Attributes and Operations of Paths</Heading>

  <ManSection>
   <Attr Name="SourceOfPath" Arg="path" Comm=""/>
   <Returns>
    the source (first) vertex of <Arg>path</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="TargetOfPath" Arg="path" Comm=""/>
   <Returns>
    the target (last) vertex of <Arg>path</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="LengthOfPath" Arg="path" Comm=""/>
   <Returns>
    the length of <Arg>path</Arg>.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="WalkOfPath" Arg="path" Comm=""/>
   <Returns>
    a list of the arrows that constitute <Arg>path</Arg> in order.
   </Returns>
  </ManSection>

  <ManSection>
   <Oper Name="*" Arg="p, q" Comm=""/>
   <Description> 
    Arguments: <Arg>p</Arg>
    and <Arg>q</Arg> -- two paths in the same quiver.
   <Br /></Description>
   <Returns> 
    the multiplication of the paths. If the paths are not in
    the same quiver an error is returned. If the target
    of <Arg>p</Arg> differs from the source of <Arg>q</Arg>, then the
    result is the zero path.  Otherwise, if either path is a vertex,
    then the result is the other path.  Finally, if both are paths of
    length at least 1, then the result is the concatenation of the
    walks of the two paths.
   </Returns>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; SourceOfPath(q1.v);                                                       
v
gap&gt; p1:=q1.a*q1.b*q1.d*q1.d;
a*b*d^2
gap&gt; TargetOfPath(p1);
v
gap&gt; p2:=q1.b*q1.b;
0
gap&gt; WalkOfPath(p1);
[ a, b, d, d ]
gap&gt; WalkOfPath(q1.a);
[ a ]
gap&gt; LengthOfPath(p1);
4
gap&gt; LengthOfPath(q1.v);
0
</Example>

  <ManSection>
   <Oper Name="=" Arg="p, q" Comm="equality"/>
   <Description> 
    Arguments: <Arg>p</Arg> and <Arg>q</Arg> -- two paths in the same quiver.
   <Br /></Description>
   <Returns> 
   true if the two paths are equal. Two paths
    are equal if they have the same source and the same target and if
    they have the same walks.
   </Returns>
  </ManSection>

  <ManSection>
   <Oper Name="&lt;" Arg="p, q" Comm="lessthan"/>
   <Description> 
    Arguments: <Arg>p</Arg> and <Arg>q</Arg> -- two paths in the same quiver.
   <Br /></Description>
   <Returns>
    a comparison of the two paths with respect to the ordering of the quiver.
   </Returns>
  </ManSection>

<Example>
gap&gt; q1.a=q1.b;
false
gap&gt; q1.a &lt; q1.v;
false
gap&gt; q1.a &lt; q1.c;
true
</Example>
</Section>

<Section><Heading>Attributes of Vertices</Heading>

  <ManSection>
   <Attr Name="IncomingArrowsOfVertex" Arg="vertex" Comm=""/>
   <Returns>
    a list of arrows having <Arg>vertex</Arg> as
    target. Only meaningful if <Arg>vertex</Arg> is in a quiver.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="OutgoingArrowsOfVertex" Arg="vertex" Comm=""/>
   <Returns>
    a list of arrows having <Arg>vertex</Arg> as
    source.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="InDegreeOfVertex" Arg="vertex" Comm=""/>
   <Returns>
    the number of arrows
    having <Arg>vertex</Arg> as target. Only meaningful
    if <Arg>vertex</Arg> is in a quiver. 
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="OutDegreeOfVertex" Arg="vertex" Comm=""/>
   <Returns>
    the number of arrows
    having <Arg>vertex</Arg> as source.
   </Returns>
  </ManSection>

  <ManSection>
   <Attr Name="NeighborsOfVertex" Arg="vertex" Comm=""/>
   <Returns>
    a list of neighbors of <Arg>vertex</Arg>,
    that is, vertices that are targets of arrows
    having <Arg>vertex</Arg> as source. 
    </Returns>
  </ManSection>

<Example>
gap&gt; q1 := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
&gt; ["v","u","c"],["v","v","d"]]);
&lt;quiver with 2 vertices and 4 arrows&gt;
gap&gt; OutgoingArrowsOfVertex(q1.u);
[ a, b ]
gap&gt; InDegreeOfVertex(q1.u);
2
gap&gt; NeighborsOfVertex(q1.v);
[ u, v ]
</Example>
</Section>
</Chapter>

<#Include SYSTEM "chapter_path_algebras.xml">


<Chapter Label="Groebner-Basis"><Heading>Groebner Basis</Heading>

This chapter contains the declarations and implementations needed for
Groebner basis. Currently, we do not provide algorithms to
actually compute Groebner basis;  instead, the declarations and
implementations are provided here for GAP objects and the actual
elements of Groebner basis are expected to be computed by external
packages such as `Opal' and `Groebner'.

<Section><Heading>Constructing a Groebner Basis</Heading>

<ManSection>
   <InfoClass Name="InfoGroebnerBasis" Comm=""/>
   <Description>
      is the info class for functions dealing with Groebner basis. 
   </Description>
</ManSection>

  <ManSection>
   <Func Name="GroebnerBasis" Arg="A, rels" 
	 Comm=""/>
   <Returns> an object in the `IsGroebnerBasis' category.</Returns>
   <Description>
       The `GroebnerBasis' global function takes an
       algebra <Math>A</Math> and a list of relations <Math>rels \in
       A</Math> and creates an object in the `IsGroebnerBasis'
       category. There are absolutely no checks for correctness in
       this function. Giving a set of relations that does not form a
       Groebner basis may result in incorrect answers or
       unexpected errors.  This function is intended to be used by
       packages providing access to external Groebner basis
       programs.
   </Description>
  </ManSection>

</Section>

<Section><Heading>Categories and Properties of Groebner
    Basis</Heading>

  <ManSection>
   <Prop Name="IsGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis and 'false' otherwise.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsTipReducedGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis which is tip reduced.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsCompletelyReducedGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebner basis which is
     completely reduced.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsHomogeneousGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a Groebnerbasis which is homogenous.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Prop Name="IsCompleteGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> is a complete Groebner basis.
     While philosophically something that isn't a complete Groebner
     basis isn't a Groebner basis at all, this property can be used in
     conjuction with other properties to see if the the Groebner basis
     contains enough information for computations. An example of a
     system that creates incomplete Groebner basis is `Opal'.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>
</Section>

<Section><Heading>Attributes and Operations for Groebner Basis</Heading>

  <ManSection>
   <Oper Name="CompletelyReduce" Arg="GB, a" Comm=""/>
   <Description>
    The operation <Ref Oper="CompletelyReduce"/> operates on an
    element <Arg>a</Arg> in a path algebra, and it
    reduces <Arg>a</Arg> by the Groebner
    basis <Arg>GB</Arg>.  The reduced element is
    returned. If <Arg>a</Arg> is already completely reduced, the
    original element <Arg>a</Arg> is returned.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="CompletelyReduceGroebnerBasis" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="CompletelyReduceGroebnerBasis"/> operates
    on a Groebner basis <Arg>GB</Arg>, and it modifies a Groebner
    basis <Math>GB</Math> such that each relation in
    <Math>GB</Math> is completely reduced.  The
    `IsCompletelyReducedGroebnerBasis' and `IsTipReducedGroebnerBasis'
    properties are set as a result of this operation. The resulting
    relations will be placed in sorted order according to the ordering
    of <Math>GB</Math>.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="TipReduce" Arg="GB, a" Comm=""/>
   <Description>
    The operation <Ref Oper="TipReduce"/> operates on an
    element <Arg>a</Arg> in a path algebra, and it tip reduced by the
    Groebner basis <Math>GB</Math>. If <Math>a</Math> is already tip
    reduced, then the original <Math>a</Math> is returned. 
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="TipReduceGroebnerBasis" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="TipReduceGroebnerBasis"/> operates on
    Groebner basis <Arg>GB</Arg>, and it returns an equivalent
    Groebner basis to <Math>GB</Math> such that each relation
    generating <Math>GB</Math> is tip reduced. If <Math>GB</Math> is
    already tip reduced, this function returns the original
    object <Math>GB</Math>, possibly with the addition of the
    `IsTipReduced`' property set.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Iterator" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Iterator"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it creates an iterator that iterates over
    the relations making up the Groebner basis. These
    relations are iterated over in ascending order with respect to the
    ordering for the family the elements are contained in.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Enumerator" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Enumerator"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it creates an enumerator that enumerates
    the relations making up the Groebner basis. These
    relations should are enumerated in ascending order with respect to
    the ordering for the family the elements are contained in.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="Nontips" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="Nontips"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it returns a list of nontip elements for
    a Groebner basis. In order to compute the nontip
    elements, the Groebner basis must be complete and tip
    reduced, and there must be a finite number of nontips. If there
    are an infinite number of nontips, the operation returns `fail'.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="AdmitsFinitelyManyNontips" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="AdmitsFinitelyManyNontips"/> operates on
    a Groebner basis <Arg>GB</Arg>, and it returns `true' if the
    Groebner basis admits only finitely many nontips and `false'
    otherwise. This operation only applies to complete Groebner basis.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="NontipSize" Arg="GB" Comm=""/>
   <Description>
    The operation <Ref Oper="NontipSize"/> operates on a Groebner
    basis <Arg>GB</Arg>, and it returns the number of nontips admitted
    by the Groebner basis <Math>GB</Math>. This operation is
    available only to complete basis.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>

  <ManSection>
   <Oper Name="IsPrefixOfTipInTipIdeal" Arg="GB, R" Comm=""/>
   <Description>
    The operation <Ref Oper="IsPrefixOfTipInTipIdeal"/> operates on a
    Groebner basis <Arg>GB</Arg> and a relation <Arg>R</Arg>, and it
    checks the tip of a relation <Math>R</Math> to see if it is in the
    tip ideal generated by the tips of <Math>GB</Math>. This is used
    mainly for the construction of right Groebner basis, but
    is made available for general use in case there are other
    unforseen applications.
   </Description>
  </ManSection>


<Example> 
gap&gt;
</Example>
</Section>

<Section><Heading>Right Groebner Basis</Heading> 

In this section we support right Groebner basis for two-sided
ideals with Groebner basis. More general cases may be
supported in the future.

  <ManSection>
   <Prop Name="IsRightGroebnerBasis" Arg="object" Comm=""/>
   <Description>
     is true when <Arg>object</Arg> a right Groebner basis.
   </Description>
  </ManSection>

<Example> 
gap&gt;
</Example>

  <ManSection>
   <Attr Name="RightGroebnerBasisOfIdeal" Arg="object" Comm=""/>
   <Description>
    An attribute. Stores a right Groebner basis of a right
    ideal, <Arg>object</Arg>, is one has been computed.
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="RightGroebnerBasis" Arg="R" Comm=""/>
   <Description>
    The operation <Ref Oper="RightGroebnerBasis"/> operates on a right
    ideal <Arg>R</Arg> in a path algebra, and it constructs a right
    Groebner basis for the right ideal, <Math>R</Math>, which
    must support a right Groebner basis theory.  Right now,
    this requires that R have a complete Groebner basis.
   </Description>
  </ManSection>

</Section>
</Chapter>

<Chapter Label="GBNP"><Heading>Using GBNP with Gap</Heading>

<Section><Heading>GBNP</Heading>

<Package>GBNP</Package> is a non-commutative Groebner Basis
package which assumes that all algebras involved will be free algebras
over a finite number of non-commuting generators.  It also assumes
that the ordering on the monomials is left length-lexicographic.
</Section>

<Section><Heading>Setting up GBNP</Heading>
in progress...
</Section>

<Section><Heading>Relevant GBNP internals</Heading>
in progress...
</Section>

<Section><Heading>Communicating with GBNP</Heading>
in progress...
</Section>
</Chapter>

<Chapter Label="Right-Modules"><Heading>Right Modules over Path
Algebras</Heading>

There are two implementations of right modules over path algebras.
The first type are matrix modules that are defined by vector spaces and
linear transformations.  The second type are presentations defined by
vertex projective modules.

<Section><Heading>Matrix Modules</Heading> 
The first implementation of right modules over path algebras views
them as a collection of vector spaces and linear transformations.
Each vertex in the path algebra is associated with a vector space over
the field of the algebra.  For each vertex <Math>v</Math> of the
algebra there is a vector space <Math>V</Math>.  Arrows of the algebra
are then associated with linear transformations which map the vector
space of the source vertex to the vector space of the target vertex.
For example, if <Math>a</Math> is an arrow from <Math>v</Math>
to <Math>w</Math> then there is a transformation from vector
space <Math>V</Math> to <Math>W</Math>.  In practice when creating the
modules all we need to know is the transformations and we can create
the vector spaces of the correct dimension, and check to make sure the
dimensions all agree.  We can create a module in this way as follows.<P/>

  <ManSection>
   <Oper Name="RightModuleOverPathAlgebra" Arg="A, mats" 
	 Comm=""/>
   <Oper Name="RightModuleOverPathAlgebra" Arg="A, dim_vector, gens" 
	 Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a (quotient of a) path algebra, <Arg>mats</Arg> -- a list of matrices, <Arg>dim_vector</Arg> -- the dimension vector of the module, <Arg>gens</Arg> -- a list of elements (generators). For further explanations, see below.
   <Br /></Description>
   <Returns>a module over a path algebra or over a qoutient of a path
   algebra in the second variant.</Returns> 
   <Description>
      In the first function call, the list of matrices <Arg>mats</Arg> can take on three different forms.<P/>

      1) The argument <Arg>mats</Arg> can be a list of blocks of
      matrices where each block is of the form, `["name of
      arrow",matrix]'.  So if you named your arrows when you created
      the quiver, then you can associate a matrix with that arrow
      explicitly.<P/> 

      2) The argument <Arg>mats</Arg> is just a list of matrices, and
      the matrices will be associated to the arrows in the order of
      arrow creation.  If when creating the quiver, the
      arrow <Math>a</Math> was created first, then <Math>a</Math>
      would be associated with the first matrix.<P/>

      3) The method is very much the same as the second
      method. If <Arg>arrows</Arg> is a list of the arrows of the
      quiver (obtained for instance through <C>arrows :=
      ArrowsOfQuiver(Q);</C>), the argument <Arg>mats</Arg> can have
      the
      format <C>[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].</C><P/>

      If you would like the trivial vector space at any vertex, then
      for each incoming arrow "a", associate it with a list of the
      form <C>["a",[n,0]]</C> where n is the dimension of the vector
      space at the source vertex of the arrow.  Likewise for all
      outgoing arrows "b", associate them to a block of
      form <C>["b",[0,n]]</C> where n is the dimension of the vector
      space at the target vertex of the arrow.<P/>

      A warning though, the function assumes that you do not mix the
      styles of inputting the matrices/linear transformations
      associated to the arrows in the quiver. Furthermore, each arrow
      needs to be assigned a matrix, otherwise an error will be
      returned. The function verifies that the dimensions of the
      matrices and vector spaces are correct and match, and that each
      arrow has only one matrix assigned to it.<P/>

      In the second function call, the second
      argument <Arg>dim_vector</Arg> is the dimension vector of the
      module, and the last argument <Arg>gens</Arg> (maybe an empty
      list []) is a list of elements of the form ["label",matrix].
      This function constructs a right module over a (quotient of a)
      path algebra <Arg>A</Arg> with dimension
      vector <Arg>dim_vector</Arg>, and where the generators/arrows
      with a non-zero action is given in the list
      <Arg>gens</Arg>. The format of the list <Arg>gens</Arg> is
      [["a",[matrix_a]],["b",[matrix_b]],...], where "a" and "b" are
      labels of arrows used when the underlying quiver was created and
      matrix_? is the action of the algebra element corresponding to
      the arrow with label "?". The action of the arrows can be
      entered in any order. The function checks if the
      algebra <Arg>A</Arg> is a (quotient of a) path algebra and if
      the matrices of the action of the arrows have the correct size
      according to the dimension vector entered and also whether or
      not the relations of the algebra are satisfied.  
   </Description>
  </ManSection>

<Example><![CDATA[
gap&gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); 
&lt;quiver with 2 vertices and 3 arrows&gt;
gap&gt; P := PathAlgebra(Rationals, Q);
&lt;algebra-with-one over Rationals, with 5 generators&gt;
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; 
gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; arrows := ArrowsOfQuiver(Q);
[ a, b, c ]
gap&gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], 
&gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;
gap&gt; N := RightModuleOverPathAlgebra(P,mats); 
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt;
gap&gt; # Next we give the vertex simple associate to vertex 1. 
gap&gt; M :=
RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
					generators&gt;&gt; 
gap&gt; # Finally, the next defines the zero representation of the quiver.
gap&gt; M :=
RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
					generators&gt;&gt; 
gap&gt; Dimension(M);
0
gap&gt; Basis(M);
Basis( &lt;
0-dimensional right-module over &lt;algebra-with-one over Rationals, with 
5 generators&gt;&gt;, [  ] )
gap> # Using the above example.  
gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",
[[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap> M := RightModuleOverPathAlgebra(P,[2,3],matrices);
<right-module over <algebra-with-one over Rationals, with 5 generators>>
gap> M := RightModuleOverPathAlgebra(P,[2,3],[]);      
<right-module over <algebra-with-one over Rationals, with 5 generators>>
]]>
</Example>

</Section>

<Section><Heading>Categories Of Matrix Modules</Heading>

  <ManSection>
   <Filt Name="IsPathAlgebraModule" Arg="object" Comm=""/>
   <Returns> 
   true or false depending on whether <Arg>object</Arg> belongs to the category <Code>IsPathAlgebraModule</Code>.</Returns>
   <Description>
     These matrix modules fall under the category `IsAlgebraModule' with
the added filter of `IsPathAlgebraModule'.  Operations available
for algebra modules can be applied to path algebra modules.  See
"ref:representations of algebras" for more details.

     These modules are also vector spaces over the field of the path
algebra.  So refer to "ref:vector spaces" for descriptions of the
basis and elementwise operations available.
   </Description>
  </ManSection> 
</Section>

<Section><Heading>Acting on Module Elements</Heading>

  <ManSection>
   <Oper Name="^" Arg="m, p" Comm=""/>
   <Description> 
   Arguments: <Arg>m</Arg> -- an element in a module, <Arg>p</Arg> -- a path in a path algebra.
   <Br /></Description>
   <Returns> 
    the element <Arg>m</Arg> multiplied with <Arg>p</Arg>.
   </Returns>
   <Description>
    When you act on an module element <Math>m</Math> by an
    arrow <Math>a</Math> from <Math>v</Math> to <Math>w</Math>, the
    component of <Math>m</Math> from <Math>V</Math> is acted on
    by <Math>L</Math> the transformation associated to <Math>a</Math>
    and placed in the component <Math>W</Math>.  All other components
    are given the value <Math>0</Math>.
   </Description>
  </ManSection>

<Example>
gap&gt; # Using the path algebra P from the above example. 
gap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],
&gt; ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap&gt; M := RightModuleOverPathAlgebra(P,matrices);
&lt;right-module over &lt;algebra-with-one over Rationals, with 5
generators&gt;&gt; 
gap&gt; B:=BasisVectors(Basis(M));
[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
gap&gt; B[1]+B[3];
[ [ 1, 0 ], [ 1, 0, 0 ] ]
gap&gt; 4*B[2];
[ [ 0, 4 ], [ 0, 0, 0 ] ]
gap&gt; m:=5*B[1]+2*B[4]+B[5];
[ [ 5, 0 ], [ 0, 2, 1 ] ]
gap&gt; m^(P.a*P.b-P.c);
[ [ 0, 5 ], [ 0, 0, 0 ] ]
gap&gt; B[1]^P.a;
[ [ 0, 0 ], [ 1, 0, 0 ] ]
gap&gt; B[2]^P.b;
[ [ 0, 0 ], [ 0, 0, 0 ] ]
gap&gt; B[4]^(P.b*P.c);
[ [ 0, 0 ], [ 0, 0, 0 ] ]
</Example>
</Section>

<Section><Heading>Operations on representations</Heading>

<Example><![CDATA[
gap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);
<quiver with 3 vertices and 5 arrows>
gap> KQ := PathAlgebra(Rationals, Q);
<algebra-with-one over Rationals, with 8 generators>
gap> gens := GeneratorsOfAlgebra(KQ);
[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ]
gap> u := gens[1];; v := gens[2];;
gap> w := gens[3];; a := gens[4];;
gap> b := gens[5];; c := gens[6];;
gap> d := gens[7];; e := gens[8];;
gap> rels := [d*e,c^2,a*c*d-b*d,e*a];;
gap> I:= Ideal(KQ,rels);;
gap> gb:= GBNPGroebnerBasis(rels,KQ);;
gap> gbb:= GroebnerBasis(I,gb);;
gap> A:= KQ/I;
<algebra-with-one over Rationals, with 8 generators>
gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],
["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap> N:= RightModuleOverPathAlgebra(A,mat);                         
<right-module over <algebra-with-one over Rationals, with 8 generators>>
]]></Example>

<ManSection>
   <Oper Name="CommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
   Arguments: <Arg>M</Arg> and <Arg>N</Arg> -- two path algebra modules.
   <Br /></Description>
   <Returns>a list of four modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>X</Arg>, <Arg>V</Arg>], 
     where <Arg>X</Arg> is one common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DimensionVector" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the dimension vector of the representation <Arg>M</Arg>.
   </Returns>
   <Description> A shortcoming of this that it is not defined for
     modules of quotients of path algebras.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="Dimension" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the dimension of the representation <Arg>M</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
   Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is isomorphic to a direct summand
     of <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DirectSumOfModules" Arg="L" Comm="for a
   list of PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>L</Arg> -- a list of <C>PathAlgebraMatModule</C>s over the same (quotient of a) path algebra. 
   <Br /></Description>
   <Returns>the direct sum of the representations contained in the
     list <Arg>L</Arg>.</Returns>
   <Description>In addition three attributes are attached to the
     result, <C>IsDirectSumOfModules, DirectSumProjections</C>
     and <C>DirectSumInclusions</C>.  
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsDirectSumOfModules" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    true if <Arg>M</Arg> is constructed via the
    command <C>DirectSumOfModules</C>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="DirectSumInclusions" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    the list of inclusions from the individual
    modules to their direct sum, when a direct sum has been
    constructed using <C>DirectSumOfModules</C>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="DirectSumProjections" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    the list of projections from the direct sum
    to the individual modules used to construct direct sum, when a
    direct sum has been constructed
    using <C>DirectSumOfModules</C>.
   </Returns>
</ManSection>

Using the example above.
<Example><![CDATA[
gap> N2:=DirectSumOfModules([N,N]);
<14-dimensional right-module over <algebra-with-one of dimension 
17 over Rationals>>
gap> proj:=DirectSumProjections(N2);
[ <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> inc:=DirectSumInclusions(N2);  
[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    14-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
]]></Example>

<ManSection>
   <Oper Name="1stSyzygy" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description>
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the first syzygy of the representation <Arg>M</Arg> as a
     representation. 
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsInAdditiveClosure" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is in the additive closure of the module
     <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="IsOmegaPeriodic" Arg="M, n" Comm="for a
   PathAlgebraMatModule and a positive integer"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>), <Arg>n</Arg> -- be a positive integer.
   <Br /></Description>
   <Returns><C>i</C>, where <C>i</C> is the smallest positive integer
     less or equal <C>n</C> such that the representation <Arg>M</Arg> is isomorphic
     to the <C>i</C>-th syzygy of <Arg>M</Arg>, and false otherwise.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsInjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is injective.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsProjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is projective.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsSemisimpleModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is semisimple.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsSimpleModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is simple.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="LoewyLength" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the Loewy length of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function checks that the module <Arg>M</Arg> is a module over
    a finite dimensional quotient of a path algebra, and returns fail
    otherwise (This is not implemented yet). 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="MaximalCommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>a list of three modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>V</Arg>], 
     where <Arg>X</Arg> is a maximal common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero maximal direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="IsomorphicModules" Arg="M, N" Comm=""/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true or false depending on whether <Arg>M</Arg>
   and <Arg>N</Arg> are isomorphic or not.</Returns> 
   <Description>
    The function first checks if the modules <Arg>M</Arg>
    and <Arg>N</Arg> are modules over the same algebra, and returns fail
    if not. The function returns true if the modules are
    isomorphic, otherwise false. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="NthSyzygy" Arg="M, n" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>), <Arg>n</Arg> -- a positive integer.
   <Br /></Description>
   <Returns>the top of the syzygies until a syzygy is projective or
     the <Arg>n</Arg>-th syzygy has been computed.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="NthSyzygyNC" Arg="M, n" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>), <Arg>n</Arg> -- a positive integer.
   <Br /></Description>
   <Returns>the <C>n</C>-th syzygy of the module <Arg>M</Arg>, unless
   the projective dimension of <Arg>M</Arg> is less or equal
   to <C>n-1</C>, in which case it returns the projective dimension of 
   <Arg>M</Arg>. It does not check if the <C>n</C>-th syzygy is
   projective or not.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="RadicalOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the radical of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the radical of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="RadicalOfModuleInclusion"/> computes the inclusion of the
    radical of <Arg>M</Arg> into <Arg>M</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="RadicalSeries" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the radical series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the radical series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The first vector listed corresponds
     to the top layer, and so on.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleSeries" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the socle series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the socle series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The last vector listed corresponds
     to the socle layer, and so on backwards.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the socle of the module <Arg>M</Arg>.</Returns>
   <Description>
    This operation only return the representation given by the socle
    of the module <Arg>M</Arg>.  The inclusion the socle
    of <Arg>M</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SocleOfModuleInclusion"/>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SubRepresentation" Arg="M, gens" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>), <Arg>gens</Arg> -- elements in <Arg>M</Arg>.
   <Br /></Description>
   <Returns>the submodule of the module <Arg>M</Arg> generated by the
   elements <Arg>gens</Arg>.</Returns>
   <Description>
    The function checks if <Arg>gens</Arg> are elements
    in <Arg>M</Arg>, and returns an error message otherwise. The
    inclusion of the submodule generated by the
    elements <Arg>gens</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SubRepresentationInclusion"/>.   
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SupportModuleElement" Arg="m" Comm=""/>
   <Description> 
    Arguments: <Arg>m</Arg> -- an element of a path algebra module.
   <Br /></Description>
   <Returns>the primitive idempotents <Arg>v</Arg> in the algebra over
   which the module containing the element <Arg>m</Arg> is a module,
   such that <Arg>m^v</Arg> is non-zero.</Returns>
   <Description>
    The function checks if <Arg>m</Arg> is an element in a module 
    over a (quotient of a) path algebra, and returns fail otherwise. 
   </Description>
</ManSection>


<ManSection>
   <Oper Name="TopOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the top of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the top of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="TopOfModuleProjection"/> computes the projection of the
    module <Arg>M</Arg> onto the top of the module <Arg>M</Arg>. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="MinimalGeneratingSetOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>a minimal generator set of the module <Arg>M</Arg> as a
   module of the path algebra it is defined over. </Returns>
</ManSection>

<ManSection>
   <Oper Name="MatricesOfPathAlgebraModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>a list of the matrices that defines the
     representation <Arg>M</Arg> as a right module of the acting path
     algebra.
   </Returns>
   <Description> 
     The list of matrices that are returned are not the same identical
     to the matrices entered to define the representation if there is
     zero vector space in at least one vertex. Then zero matrices of
     the appropriate size are returned. A shortcoming of this that it
     is not defined for modules of quotients of path algebras. 
   </Description>
</ManSection>

</Section>

<Section><Heading>Special representations</Heading>
Here we collect the predefined representations/modules over a finite
  dimensional quotient of a path algebra. 

  <ManSection>
   <Oper Name="BasisOfProjectives" Arg="A" Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
    algebra.
   <Br /></Description>
   <Returns>a list of bases for all the indecomposable projective
   representations over <Arg>A</Arg>. The basis for each indecomposable projective is given a list of elements in nontips in <Arg>A</Arg>. 
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a
     finite dimensional (quotient of a) path algebra, and returns an 
     error message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IndecProjectiveModules" Arg="A [, list]" Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
    algebra, (optional) <Arg>list</Arg> -- a list of integers.
   <Br /></Description>
   <Returns>a list of all the indecomposable projective
   representations over <Arg>A</Arg>, when only one argument is supplied. The
   second argument should be a list of integers, for example [1, 3,
   4], which will return the indecomposable projective corresponding
   to vertex 1, 3 and 4, in this order.  
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a
     finite dimensional (quotient of a) path algebra, and returns an 
     error message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="IndecInjectiveModules" Arg="A [, list]" Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
    algebra, (optional) <Arg>list</Arg> -- a list of integers.
   <Br /></Description>
   <Returns>a list of all the indecomposable injective
   representations over <Arg>A</Arg>, when only one argument is supplied. The
   second argument should be a list of integers, for example [1, 3,
   4], which will return the indecomposable injective corresponding
   to vertex 1, 3 and 4, in this order.
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="SimpleModules" Arg="A" Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
    algebra.
   <Br /></Description>
   <Returns>a list of all the simple representations over <Arg>A</Arg> .
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="ZeroModule" Arg="A" Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
    algebra.
   <Br /></Description>
   <Returns>the zero representation over <Arg>A</Arg> .
   </Returns>
   <Description>
     The function checks if the algebra <Arg>A</Arg> is a finite
     dimensional (quotient of a) path algebra, and returns an error
     message otherwise. 
   </Description>
  </ManSection>
</Section>


<Section><Heading>Functors on representations</Heading>

<ManSection>
   <Oper Name="DualOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a representation of a path algebra <Math>KQ</Math>.
   <Br /></Description>
   <Returns>
    the dual of <Arg>M</Arg> over the opposite path algebra <Arg>KQ_op</Arg>. 
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="DualOfModuleHomomorphism" Arg="f" Comm="for a PathAlgebraMatModuleMap"/>
   <Description> 
    Arguments: <Arg>f</Arg> -- a map between two representations <Arg>M</Arg> and <Arg>N</Arg> over a path algebra <Math>A</Math>.
   <Br /></Description>
   <Returns>
    the dual of this map over the opposite path algebra <Arg>A^op</Arg>.
   </Returns>
</ManSection>


<ManSection>
   <Oper Name="DTr" Arg="M, [ n ]" Comm="for a PathAlgebraMatModule and an
   integer"/>
   <Oper Name="DualOfTranspose" Arg="M, [ n ]" Comm="for a
   PathAlgebraMatModule"/> 
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module, (optional) <Arg>n</Arg> -- an integer.
   <Br /></Description>
   <Returns>the dual of the transpose of <Arg>M</Arg> when
   called with only one argument, while it returns the dual of the
   transpose applied to <Arg>M</Arg> <Arg>n</Arg> times
   otherwise. If <Arg>n</Arg> is negative, then powers of <C>TrD</C>
   are computed. <Ref Oper="DualOfTranspose"/> is a synonym for
   <Ref Oper="DTr"/>. </Returns>
</ManSection>

<ManSection>

   <Oper Name="TrD" Arg="M, [n]" Comm="for a PathAlgebraMatModule and an
   integer"/>
   <Oper Name="TransposeOfDual" Arg="M, [n]" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module, (optional) <Arg>n</Arg> -- an integer.
   <Br /></Description>
   <Returns>the transpose of the dual of <Arg>M</Arg> when
   called with only one argument, while it returns the transpose of
   the dual applied to <Arg>M</Arg> <Arg>n</Arg> times
   otherwise. If <Arg>n</Arg> is negative, then powers of <C>TrD</C>
   are computed. <Ref Oper="TransposeOfDual"/> is a synonym for
   <Ref Oper="TrD"/>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="TransposeOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>the transpose of the module <Arg>M</Arg>.</Returns>
</ManSection>

</Section>

<Section><Heading>Vertex Projective Presentations</Heading> 
In general, if <Math>R</Math> is a ring and <Math>e</Math> is an
idempotent of <Math>R</Math> then <Math>eR</Math> is a projective
module of <Math>R</Math>.  Then we can form a direct sum of these
projective modules together to form larger projective module.

One can construct more general modules by providing a <Arg>vertex
projective presentation</Arg>.  In this case, <Math>M</Math> is the
cokernel as given by the following exact sequence:

<Math>\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R
\rightarrow{M} \rightarrow 0</Math>

for some map between <Math>\oplus_{j=1}^{r} w(j)R</Math>
and <Math>\oplus_{i=1}^{g} v(i)R</Math>.  The maps <Math>w</Math>
and <Math>v</Math> map the integers to some idempotent
in <Math>R</Math>.

<ManSection>
   <Func Name="RightProjectiveModule" Arg="A, verts" 
	 Comm=""/>
	 <Description> 
    Arguments: <Arg>A</Arg> -- a (quotient of a) path algebra, <Arg>verts</Arg> -- a list of vertices.
   <Br /></Description>
   <Returns> the right projective module over <Arg>A</Arg> which is
      the direct sum of projective modules of the form <Arg>vA</Arg>
      where the vertices are taken from <Arg>verts</Arg>.</Returns>
   <Description>
      In this implementation the algebra can be a quotient of a path
      algebra.  So if the list was
      <Math>[v,w]</Math> then the module created will be the direct
      sum <Math>vA \oplus wA</Math>, in that order.  Elements of the
      modules are vectors of algebra elements, and in each component,
      each path begins with the vertex in that position in the list of
      vertices.  Right projective modules are implementated as algebra
      modules (see "ref:Representations of Algebras") and all
      operations for algebra modules are applicable to right
      projective modules.  In particular, one can construct submodules
      using `SubAlgebraModule'.
   </Description>
</ManSection>
Here we create the right projective module <Math>P = vA \oplus vA
    \oplus wA</Math>. 

<Example>
gap&gt; F:=GF(11);
GF(11)
gap&gt; Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);
&lt;quiver with 3 vertices and 3 arrows&gt;
gap&gt; A:=PathAlgebra(F,Q);
&lt;algebra-with-one over GF(11), with 6 generators&gt;
gap&gt; P:=RightProjectiveModule(A,[A.v,A.v,A.w]);
&lt;right-module over &lt;algebra-with-one over GF(11), with 6 generators&gt;&gt;
gap&gt; Dimension(P);
12
</Example>

  <ManSection>
   <Func Name="Vectorize" Arg="M, components" 
	 Comm=""/>
	 <Description> 
    Arguments: <Arg>M</Arg> -- a module over a path algebra, <Arg>components</Arg> -- a list of elements of <Arg>M</Arg>.
   <Br /></Description>
   <Returns>a vector in <Arg>M</Arg> from a list of path
      algebra elements <Arg>components</Arg>, which defines the
      components in the resulting vector.</Returns>
   <Description>
      The returned vector is normalized, so the vector's components
      may not match the input components.
   </Description>
  </ManSection>

In the following example, we create two elements in <Math>P</Math>,
perform some elementwise operations, and then construct a submodule
using the two elements as generators.<P/>

<Example>
gap&gt; p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
gap&gt; p2:=Vectorize(P,[A.a,A.b,A.w]);
[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
gap&gt; 2*p1 + p2;
[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ]
gap&gt; S:=SubAlgebraModule(P,[p1,p2]);
&lt;right-module over &lt;algebra-with-one of dimension 8 over GF(11)&gt;&gt;
gap&gt; Dimension(S);
3
</Example>

  <ManSection>
   <Oper Name="^" Arg="m, a" Comm="Action by a path algebra element"/>
   <Description> 
    Arguments: <Arg>m</Arg> -- an element of a path algebra module, <Arg>a</Arg> -- an element of a path algebra.
   <Br /></Description>
   <Returns>
    the element <Arg>m</Arg> multiplied with <Arg>a</Arg>.
   </Returns>
   <Description>
    This action is defined by multiplying each component
    in <Arg>m</Arg> by <Arg>a</Arg> on the right.
   </Description>
  </ManSection>

<Example>
gap&gt; p2^(A.c - A.w);
[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
  (Z(11)^5)*w+(Z(11)^0)*c ]
</Example>

  <ManSection>
   <Oper Name="&lt;" Arg="m1, m2" Comm="lessthan"/>
   <Description> 
    Arguments: <Arg>m1, m2</Arg> -- two elements of a module over a path algebra (?).
   <Br /></Description>
   <Returns>
    `true' if <Arg>m1</Arg> is less than <Arg>m2</Arg> and false otherwise.
   </Returns>
   <Description>
    Elements are compared componentwise from left to right using the ordering of the underlying algebra.  The element <Arg>m1</Arg> is less than <Arg>m2</Arg> if the first time components are not equal, the
    component of <Arg>m1</Arg> is less than the corresponding
    component of <Arg>m2</Arg>.
   </Description>
  </ManSection>

<Example>
gap&gt; p1 &lt; p2;
false
</Example>

  <ManSection>
   <Oper Name="/" Arg="M, N" Comm="Factor module"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two finite dimensional modules over a path algebra (?).
   <Br /></Description>
   <Returns>
    the factor module <Math>M/N</Math>.
   </Returns>
   <Description>
    This module is
    again a right algebra module, and all applicable methods and
    operations are available for the resulting factor module.
    Furthermore, the resulting module is a vector space, so operations
    for computing bases and dimensions are also available.
   </Description>
  </ManSection>
This 

<Example>
gap&gt; PS := P/S;
&lt;9-dimensional right-module over &lt;algebra-with-one of dimension
8 over GF(11)&gt;&gt; 
gap&gt; Basis(PS);
Basis( &lt;9-dimensional right-module over &lt;algebra-with-one of dimension 
8 over GF(11)&gt;&gt;, [ [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ...,
(Z(11)^0)*w ] ],  
  [ [ &lt;zero&gt; of ..., &lt;zero&gt; of ..., (Z(11)^0)*c ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*v, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*a*c, &lt;zero&gt; of ... ] ], 
  [ [ &lt;zero&gt; of ..., (Z(11)^0)*b*c, &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*v, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ], 
  [ [ (Z(11)^0)*b, &lt;zero&gt; of ..., &lt;zero&gt; of ... ] ] ] )
</Example>
</Section>
</Chapter>

<Chapter Label="Homomorphisms"><Heading>Homomorphisms of Right Modules
    over Path Algebras</Heading>

This chapter describes the categories, representations, attributes,
  and operations on homomorphisms between representations of
  quivers.<P /> 

Given two homorphisms <Math>f\colon L\to M</Math> and <Math>g\colon
  M\to N</Math>, then the composition is written <Math>f*g</Math>. The
  elements in the modules or the representations of a quiver are row
  vectors. Therefore the homomorphisms between two modules are acting
  on these row vectors, that is, if <Math>m_i</Math> is
  in <Math>M[i]</Math> and <Math>g_i\colon M[i]\to N[i]</Math>
  represents the linear map, then the value of <Math>g</Math> applied
  to <Math>m_i</Math> is the matrix product <Math>m_i*g_i</Math>.<P />

The example used throughout this chapter is the following.
<Example><![CDATA[
gap> Q:= Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);;
gap> KQ:= PathAlgebra(Rationals, Q);;
gap> gen:= GeneratorsOfAlgebra(KQ);;
gap> a:= gen[4];;
gap> b:= gen[5];;
gap> c:= gen[6];;
gap> d:= gen[7];;
gap> e:= gen[8];;
gap> rels:= [d*e,c^2,a*c*d-b*d,e*a];;
gap> I:= Ideal(KQ,rels);;
gap> gb:= GBNPGroebnerBasis(rels,KQ);;
gap> gbb:= GroebnerBasis(I,gb);;
gap> A:= KQ/I;;
gap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],["c",[[0,0],[1,0]]],
["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap> N:= RightModuleOverPathAlgebra(A,mat);;
]]></Example>


<Section><Heading>Categories and representation of homomorphisms</Heading>

<ManSection>
   <Filt Name="IsPathAlgebraModuleHomomorphism" Arg="f" Comm="category"/>
   <Description>
     Arguments: <Arg>f</Arg> - any object in GAP.<Br />
   </Description>
   <Returns> true or false depending on if <Arg>f</Arg> belongs to the
     categories <Code>IsAdditiveElementWithZero</Code>, <C>IsAdditiveElementWithInverse</C>,
     <Code>IsGeneralMapping</Code>, <C>RespectsAddition</C>, <C>RespectsZero</C>, 
     <Code>RespectsScalarMultiplication</Code>,
     <Code>IsTotal</Code> and <Code>IsSingleValued</Code> or not.
   </Returns>
   <Description>
     This defines the category
     <Ref Filt="IsPathAlgebraModuleHomomorphism"/>. 
   </Description>
</ManSection> 

<ManSection>
   <Oper Name="RightModuleHomOverAlgebra" Arg="M, N, mats" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg>, <Arg>N</Arg> - two modules over the same
     (quotient of a) path algebra, <Arg>mats</Arg> - a list of
     matrices, one for each vertex in the quiver of the path
     algebra.<Br />
   </Description>
   <Returns>a homomorphism in the
   category <C>IsPathAlgebraModuleHomomorphism</C> from the module <Arg>M</Arg> to the
   module <Arg>N</Arg> given by the matrices <Arg>mats</Arg>.</Returns>
   <Description>
     The arguments <Arg>M</Arg> and <Arg>N</Arg> are two modules over
     the same algebra (this is checked), and <Arg>mats</Arg> is a list
     of matrices <C>mats[i]</C>, where <C>mats[i]</C> represents the
     linear map from <C>M[i]</C> to <C>N[i]</C> with <Code>i</Code>
     running through all the vertices in the same order as when the
     underlying quiver was created. If
     both <Code>DimensionVector(M)[i]</Code>
     and <Code>DimensionVector(N)[i]</Code> are non-zero,
     then <C>mats[i]</C> is a <Code>DimensionVector(M)[i]</Code>
     by <Code>DimensionVector(N)[i]</Code> matrix. If
     <Code>DimensionVector(M)[i]</Code> is zero 
     and <Code>DimensionVector(N)[i]</Code> is non-zero, then
     <C>mats[i]</C> must be the zero <Code>1</Code>
     by <Code>DimensionVector(N)[i]</Code> matrix. Similarly for the 
     other way around. If both <Code>DimensionVector(M)[i]</Code>
     and <Code>DimensionVector(N)[i]</Code> are zero,
     then <C>mats[i]</C> must be the <Code>1</Code> by <Code>1</Code>
     zero matrix. The function checks if <Arg>mats</Arg> is a
     homomorphism from the module <Arg>M</Arg> to the
     module <Arg>N</Arg> by checking that the matrices given
     in <Arg>mats</Arg> have the correct size and satisfy the
     appropriate commutativity conditions with the matrices in the
     modules given by <Arg>M</Arg> and <Arg>N</Arg>. The source (or
     domain) and the range (or codomain) of the homomorphism
     constructed can by obtained again by <Ref Oper="Range"/> and by
     <Ref Oper="Source"/>, respectively.
   </Description>
</ManSection>

<Example><![CDATA[
gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]],
["c",[[0]]],["d",[[1]]],["e",[1,0]]]);
<right-module over <algebra-with-one over Rationals, with 8 generators>>
gap> DimensionVector(L);
[ 0, 1, 1 ]
gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals,
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d],
[(1)*e] ] )> -> <7-dimensional right-module over AlgebraWithOne(Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] ] )> >
gap> IsPathAlgebraModuleHomomorphism(f);
true
]]></Example>

</Section>

<Section><Heading>Generalities of homomorphisms</Heading>

<ManSection>
   <Oper Name="MatricesOfPathAlgebraMatModuleHomomorphism" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two modules.<Br />
   </Description>
   <Returns>the matrices defining the homomorphism <Arg>f</Arg>.</Returns>
</ManSection>

<ManSection>
   <Attr Name="Range" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two modules.<Br />
   </Description>
   <Returns>the range (or codomain) the homomorphism <Arg>f</Arg>.</Returns>
</ManSection>

<ManSection>
   <Attr Name="Source" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two modules.<Br />
   </Description>
   <Returns>the source (or domain) the homomorphism <Arg>f</Arg>.</Returns>
</ManSection>

<Example><![CDATA[
gap> MatricesOfPathAlgebraMatModuleHomomorphism(f);
[ [ [ 0, 0, 0 ] ], [ [ 1, 0 ] ], [ [ 1, 2 ] ] ]
gap> Range(f);
<7-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> Source(f);
<2-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> Source(f) = L;
true
]]></Example>

<ManSection>
   <Oper Name="PreImagesRepresentative" Arg="f, elem" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules, <Arg>elem</Arg> - an element in the range of <Arg>f</Arg>.<Br />
   </Description>
   <Returns>a preimage of the element <Arg>elem</Arg> in the range (or
   codomain) the homomorphism <Arg>f</Arg> if a preimage exists,
   otherwise it returns <C>fail</C>.</Returns>
   <Description>
     The function checks if <Arg>elem</Arg> is an element in the
     range of <Arg>f</Arg> and returns an error message if
     not. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ImageElm" Arg="f, elem" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules, <Arg>elem</Arg> - an element in the source of <Arg>f</Arg>.<Br />
   </Description>
   <Returns>the image of the element <Arg>elem</Arg> in the source (or
   domain) of the homomorphism <Arg>f</Arg>.</Returns>
   <Description>
     The function checks if <Arg>elem</Arg> is an element in the
     source of <Arg>f</Arg>, and it returns an error message
     otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ImagesSet" Arg="f, elts" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules, <Arg>elts</Arg> - an element in the source
     of <Arg>f</Arg>, or the source of <Arg>f</Arg>.<Br />
   </Description>
   <Returns>the non-zero images of a set of elements <Arg>elts</Arg>
   in the source of the homomorphism <Arg>f</Arg>, or
   if <Arg>elts</Arg> is  the source of <Arg>f</Arg>, it
   returns a basis of the image.</Returns>
   <Description>
     The function checks if the set of elements <Arg>elts</Arg>
     consists of elements in the source of <Arg>f</Arg>, and it
     returns an error message otherwise.
   </Description>
</ManSection>

<Example><![CDATA[
B:=BasisVectors(Basis(N)); 
[ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
gap> PreImagesRepresentative(f,B[4]);     
[ [ 0 ], [ 1 ], [ 0 ] ]
gap> PreImagesRepresentative(f,B[5]);
fail
gap> BL:=BasisVectors(Basis(L));
[ [ [ 0 ], [ 1 ], [ 0 ] ], [ [ 0 ], [ 0 ], [ 1 ] ] ]
gap> ImageElm(f,BL[1]);
[ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ]
gap> ImagesSet(f,L);
[ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
gap> ImagesSet(f,BL);
[ [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 2 ] ] ]
]]></Example>

<ManSection>
   <Oper Name="Zero" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two modules.<Br />
   </Description>
   <Returns>the zero map between <Code>Source(f)</Code>
   and <Code>Range(f)</Code>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="ZeroMapping" Arg="M, N" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg>, <Arg>N</Arg> - two modules.<Br />
   </Description>
   <Returns>the zero map between <Arg>M</Arg> and <Arg>N</Arg>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="IdentityMapping" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the identity map between <Arg>M</Arg> and <Arg>M</Arg>.</Returns>
</ManSection>

<ManSection>
   <Oper Name="\= (maps)" Arg="f,g " Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms between
     two modules.<Br />
   </Description>
   <Returns>true, if <Code>Source(f) =
   Source(g)</Code>, <Code>Range(f) = Range(g)</Code>, and the
   matrices defining the maps <Arg>f</Arg> and <Arg>g</Arg>
   coincide.</Returns>
</ManSection>

<ManSection>
   <Oper Name="\+ (maps)" Arg="f,g " Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms between
     two modules.<Br />
   </Description>
   <Returns>the sum <Arg>f+g</Arg> of the maps <Arg>f</Arg>
   and <Arg>g</Arg>.</Returns>
   <Description>The function checks if the maps have the same source
   and the same range, and returns an error message otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="\* (maps)" Arg="f,g " Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms between
     two modules, or one scalar and one homomorphism between modules.<Br />
   </Description>
   <Returns>the composition <Arg>fg</Arg> of the maps <Arg>f</Arg>
   and <Arg>g</Arg>, if the input are maps between representations of
   the same quivers. If <Arg>f</Arg> or <Arg>g</Arg> is a 
   scalar, it returns the natural action of scalars on the maps
   between representations.</Returns>
   <Description>The function checks if the maps are composable, in
   the first case and in the second case it checks if the scalar is in
   the correct field, and returns an error message otherwise.
   </Description>
</ManSection>

<Example><![CDATA[
gap> z:=Zero(f);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> f = z;
false
gap> Range(f) = Range(z);
true
gap> y := ZeroMapping(L,N); 
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> y = z;            
true
gap> id := IdentityMapping(N);  
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> f*id;
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> id*f;
Error, codomain of the first argument is not equal to the domain of the second\
 argument,  called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> 
gap> 2*f + z;
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Attr Name="CoKernelOfWhat" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between
     two modules.<Br />
   </Description>
   <Returns>
     a homomorphism <Arg>g</Arg>, if <Arg>f</Arg> has been computed as the
     cokernel of the homomorphism <Arg>g</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="ImageOfWhat" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     a homomorphism <Arg>g</Arg>, if <Arg>f</Arg> has been computed as the
     image projection or the image inclusion of the homomorphism <Arg>g</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsInjective" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>true</Code> if the homomorphism <Arg>f</Arg> is one-to-one.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsSurjective" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>true</Code> if the homomorphism <Arg>f</Arg> is onto.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsIsomorphism" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>true</Code> if the homomorphism <Arg>f</Arg> is an isomorphism.
   </Returns>
</ManSection>

<Example><![CDATA[
gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]], 
     ["c",[[0]]],["d",[[1]]],["e",[1,0]]]);;
gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);;
gap> g := CoKernelProjection(f);                                       
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <5-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> CoKernelOfWhat(g) = f;
true
gap> h := ImageProjection(f);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> ImageOfWhat(h) = f;
true
gap> IsInjective(f); IsSurjective(f); IsIsomorphism(f); IsIsomorphism(h);
true
false
false
true
]]></Example>

<ManSection>
   <Attr Name="IsSplitEpimorphism" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>false</Code> if the homomorphism <Arg>f</Arg>
     is not a splittable epimorphism, otherwise it returns a
     splitting of the homomorphism <Arg>f</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="IsSplitMonomorphism" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>false</Code> if the homomorphism <Arg>f</Arg>
     is not a splittable monomorphism, otherwise it returns a
     splitting of the homomorphism <Arg>f</Arg>.
   </Returns>
</ManSection>

<Example><![CDATA[
gap> S := SimpleModules(A)[1];;
gap> H := HomOverAlgebra(N,S);; 
gap> IsSplitMonomorphism(H[1]);  
false      
gap> f := IsSplitEpimorphism(H[1]);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> IsSplitMonomorphism(f);
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Prop Name="IsZero" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     <Code>true</Code> if the homomorphism <Arg>f</Arg>
     is a zero homomorphism.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="KernelOfWhat" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     a homomorphism <Arg>g</Arg>, if <Arg>f</Arg> has been computed as the
     kernel of the homomorphism <Arg>g</Arg>.
   </Returns>
</ManSection>

<Example><![CDATA[
gap> L := RightModuleOverPathAlgebra(A,[["a",[0,1]],["b",[0,1]],
  ["c",[[0]]],["d",[[1]]],["e",[1,0]]]);
<right-module over <algebra-with-one over Rationals, with 8 generators>>
gap> f := RightModuleHomOverAlgebra(L,N,[[[0,0,0]], [[1,0]], [[1,2]]]);;
gap> IsZero(0*f);
true
gap> KnownAttributesOfObject(g);
[ "Range", "Source", "PathAlgebraOfMatModuleMap", "KernelOfWhat" ]
gap> KernelOfWhat(g) = f;
true
]]></Example>
</Section>

<Section><Heading>Homomorphisms and modules constructed from homomorphisms and modules</Heading>

<ManSection>
   <Attr Name="CoKernel" Arg="f" Comm=""/>
   <Attr Name="CoKernelProjection" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>the cokernel of a homomorphism <Arg>f</Arg> between two
   modules.</Returns>
   <Description>
    The first variant <Ref Oper="CoKernel"/> returns the cokernel of
    the homomorphism <Arg>f</Arg> as a module, while the latter one
    returns the projection homomorphism from the range of the
    homomorphism <Arg>f</Arg> to the cokernel of the
    homomorphism <Arg>f</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="EndOverAlgebra" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the endomorphism ring of <Arg>M</Arg> as a subalgebra of
   the direct sum of the full matrix rings of <C>DimensionVector(M)[i] x
   DimensionVector(M)[i]</C>, where <Arg>i</Arg> runs over all
   vertices where <C>DimensionVector(M)[i]</C> is non-zero.</Returns>
   <Description>
    The endomorphism is an algebra with one, and one can apply for
    example <Code>RadicalOfAlgebra</Code> to find the radical of the
    endomorphism ring. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="HomFromProjective" Arg="m, M" Comm=""/>
   <Description>
     Arguments: <Arg>m</Arg>, <Arg>M</Arg> - an element and a module.<Br />
   </Description>
   <Returns>the homomorphism from the indecomposable projective
   module defined by the support of the element <Arg>m</Arg>
   to the module <Arg>M</Arg>.</Returns>
   <Description>
    The function checks if <Arg>m</Arg> is an elememt in <Arg>M</Arg>
    and if the element <Arg>m</Arg> is supported in only one
    vertex. Otherwise it returns fail.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="HomOverAlgebra" Arg="M, N" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg>, <Arg>N</Arg> - two modules.<Br />
   </Description>
   <Returns>a basis for the vector space of homomorphisms from <Arg>M</Arg>
   to <Arg>N</Arg>.</Returns>
   <Description>
    The function checks if <Arg>M</Arg> and <Arg>N</Arg> are modules
    over the same algebra, and returns an error message and fail
    otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="Image" Arg="f" Comm=""/>
   <Attr Name="ImageProjection" Arg="f" Comm=""/>
   <Attr Name="ImageInclusion" Arg="f" Comm=""/>
   <Attr Name="ImageProjectionInclusion" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>the image of a homomorphism <Arg>f</Arg> between two modules.</Returns>
   <Description>
    The first variant <Ref Attr="Image"/> returns the image of the
    homomorphism <Arg>f</Arg> as a module. The
    second returns the projection from the source of <Arg>f</Arg> to
    the image of the homomorphism <Arg>f</Arg>. The third returns the
    inclusion of the image into the range of the
    homomorphism <Arg>f</Arg>. The last one returns both the
    projection and the inclusion as a list of two elements (first the
    projection and then the inclusion).
   </Description>
</ManSection>

<ManSection>
   <Attr Name="Kernel" Arg="f" Comm=""/>
   <Attr Name="KernelInclusion" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>the kernel of a homomorphism <Arg>f</Arg> between two
   modules.</Returns>
   <Description>
    The first variant <Ref Attr="Kernel"/> returns the kernel of the
    homomorphism <Arg>f</Arg> as a module, while the latter one
    returns the inclusion homomorphism of the kernel into the source
    of the homomorphism <Arg>f</Arg>.
   </Description>
</ManSection>


<Example><![CDATA[
gap> hom := HomOverAlgebra(N,N);
[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> g := hom[1];
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> M := CoKernel(g);
<6-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> f := CoKernelProjection(g);
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> Range(f) = M;
true
gap> endo := EndOverAlgebra(N);
<algebra-with-one of dimension 5 over Rationals>
gap> RadicalOfAlgebra(endo);
<algebra of dimension 3 over Rationals>
gap> B := BasisVectors(Basis(N));
[ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
gap> p := HomFromProjective(B[1],N);
<mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> U := Image(p);
<5-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> projinc := ImageProjectionInclusion(p);
[ <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    5-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> U = Range(projinc[1]);                                      
true
gap> Kernel(p);
<3-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
]]></Example>

<ManSection>
   <Oper Name="LiftingInclusionMorphisms" Arg="f, g" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms with
     common range.<Br />
   </Description>
   <Returns>
     a factorization of <Arg>g</Arg> in terms of <Arg>f</Arg>, whenever
     possible and <C>fail</C> otherwise.
   </Returns>
   <Description>
    Given two inclusions <Math>f\colon B\to C</Math> and <Math>g\colon
    A\to C</Math>, this function constructs a morphism
    from <Math>A</Math> to <Math>B</Math>, whenever the image
    of <Arg>g</Arg> is contained in the image of <Arg>f</Arg>.
    Otherwise the function returns fail. The function checks
    if <Arg>f</Arg> and <Arg>g</Arg> are one-to-one, if they have
    the same range and if the image of <Arg>g</Arg> is contained in
    the image of <Arg>f</Arg>.
   </Description>
</ManSection>


<ManSection>
   <Oper Name="LiftingMorphismFromProjective" Arg="f, g" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms with
     common range.<Br />
   </Description>
   <Returns>
     a factorization of <Arg>g</Arg> in terms of <Arg>f</Arg>, whenever
     possible and <C>fail</C> otherwise.
   </Returns>
   <Description>
    Given two morphisms <Math>f\colon B\to C</Math> and <Math>g\colon
    P\to C</Math>, where <Math>P</Math> is a direct sum of
    indecomposable projective modules constructed
    via <Code>DirectSumOfModules</Code> and <Arg>f</Arg> an
    epimorphism, this function finds a lifting of <Arg>g</Arg>
    to <Math>B</Math>. The function checks if <Math>P</Math> is a
    direct sum of indecomposable projective modules, if <Arg>f</Arg>
    is onto and if <Arg>f</Arg> and <Arg>g</Arg> have the same range.
   </Description>
</ManSection>

<Example><![CDATA[
gap> B := BasisVectors(Basis(N));
[ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
gap> g := SubRepresentationInclusion(N,[B[1],B[4]]);
<mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> f := SubRepresentationInclusion(N,[B[1],B[2]]);
<mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> LiftingInclusionMorphisms(f,g);
<mapping: <5-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> S := SimpleModules(A); 
[ <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
  <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
  <right-module over <algebra-with-one over Rationals, with 8 generators>> ]
gap> homNS := HomOverAlgebra(N,S[1]);
[ <mapping: <
    7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
    1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >, 
  <mapping: <
    7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
    1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >, 
  <mapping: <
    7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
    1-dimensional right-module over AlgebraWithOne( Rationals, ... )> > ]
gap> f := homNS[1];
<mapping: <
7-dimensional right-module over AlgebraWithOne( Rationals, ... )> -> <
1-dimensional right-module over AlgebraWithOne( Rationals, ... )> >
gap> p := ProjectiveCover(S[1]);
<mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> LiftingMorphismFromProjective(f,p);
<mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Attr Name="LeftMinimalVersion" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     the left minimal version <Arg>f'</Arg> of the
     homomorphism <Arg>f</Arg> together with the a list <Code>B</Code>
     of modules such that the direct sum of the
     modules, <Code>Range(f')</Code> and the modules in the
     list <Code>B</Code> is isomorphic to <Code>Range(f)</Code>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="RightMinimalVersion" Arg="f" Comm=""/>
   <Description>
     Arguments: <Arg>f</Arg> - a homomorphism between two
     modules.<Br />
   </Description>
   <Returns>
     the right minimal version <Arg>f'</Arg> of the
     homomorphism <Arg>f</Arg> together with the a list <Code>B</Code>
     of modules such that the direct sum of the
     modules, <Code>Source(f')</Code> and the modules on the
     list <Code>B</Code> is isomorphic to <Code>Source(f)</Code>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="MinimalLeftApproximation" Arg="C, M" Comm=""/>
   <Description>
     Arguments: <Arg>C</Arg>, <Arg>M</Arg> - two modules.<Br />
   </Description>
   <Returns>
     the minimal left <Code>add M</Code>-approximation of the
     module <Arg>C</Arg>. Note: The order of the arguments is opposite
     of the order for minimal right approximations.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="MinimalRightApproximation" Arg="M, C" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg>, <Arg>C</Arg> - two modules.<Br />
   </Description>
   <Returns>
     the minimal right <Code>add M</Code>-approximation of the
     module <Arg>C</Arg>. Note: The order of the arguments is opposite
     of the order for minimal left approximations.
   </Returns>
</ManSection>

<Example><![CDATA[
gap> H:= HomOverAlgebra(N,N);;
gap> RightMinimalVersion(H[1]);   
[ <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  [ <6-dimensional right-module over <algebra-with-one of dimension 
        17 over Rationals>> ] ]
gap> LeftMinimalVersion(H[1]);             
[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  [ <6-dimensional right-module over <algebra-with-one of dimension 
        17 over Rationals>> ] ]
gap> S:=SimpleModules(A)[1];;
gap> MinimalRightApproximation(N,S);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> S:=SimpleModules(A)[3];;
gap> MinimalLeftApproximation(S,N);        
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>

<ManSection>
   <Oper Name="MorphismOnKernel" Arg="f, g,  alpha, beta" Comm="for a
   commutative diagram of maps"/>
   <Oper Name="MorphismOnImage" Arg="f, g,  alpha, beta" Comm="for a
   commutative diagram of maps"/>
   <Oper Name="MorphismOnCoKernel" Arg="f, g, alpha, beta" Comm="for a
   commutative diagram of maps"/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg>, <Arg>alpha</Arg>, <Arg>beta</Arg>
     - four homomorphisms of modules.<Br />
   </Description>
   <Returns>the morphism induced on the kernels, the images or the
   cokernels of the morphisms <Arg>f</Arg> and <Arg>g</Arg>,
   respectively, whenever <M>f\colon A\to B</M>, <M>\beta\colon B\to
   B'</M>, <M>\alpha\colon A\to A'</M> and <M>g\colon A'\to B'</M>
   forms a commutative diagram.</Returns>
   <Description>
    It is checked
    if <Arg>f</Arg>, <Arg>g</Arg>, <Arg>alpha</Arg>, <Arg>beta</Arg>
    forms a commutative diagram, that is, if <Math>f \beta - \alpha g
    = 0</Math>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ProjectiveCover" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the projective cover of <Arg>M</Arg>, that is, returns the
   map <Math>P(M)\to M</Math>.</Returns>
   <Description>
     If the module <Arg>M</Arg> is zero, then the zero map
     to <Arg>M</Arg> is returned. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="PullBack" Arg="f, g" Comm="for two maps between modules
   with common target"/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms with a common range.<Br />
   </Description>
   <Returns>the pullback of the maps <Arg>f</Arg> and <Arg>g</Arg>.</Returns>
   <Description>
    It is checked if <Arg>f</Arg> and <Arg>g</Arg> have the same range.
    Given the input <Math>f\colon A\to B</Math> (horizontal map)
    and <Math>g\colon C\to B</Math> (vertical map), the
    pullback <Math>E</Math> is returned as the two
    homomorphisms <Math>[f',g']</Math>, where <Math>f'\colon E\to
    C</Math> (horizontal map) and <Math>g'\colon E\to A</Math>
    (vertical map).
   </Description>
</ManSection>

<ManSection>
   <Oper Name="PushOut" Arg="f, g" Comm="for two maps between modules
   with common source"/>
   <Description>
     Arguments: <Arg>f</Arg>, <Arg>g</Arg> - two homomorphisms between
     modules with a common source.<Br />
   </Description>
   <Returns>the pushout of the maps <Arg>f</Arg> and <Arg>g</Arg>.</Returns>
   <Description>
    It is checked if <Arg>f</Arg> and <Arg>g</Arg> have the same
    source. Given the input <Math>f\colon A\to B</Math> (horizontal
    map) and <Math>g\colon A\to C</Math> (vertical map), the
    pushout <Math>E</Math> is returned as the two
    homomorphisms <Math>[f',g']</Math>, where <Math>f'\colon C\to
    E</Math> (horizontal map) and <Math>g'\colon B\to E</Math>
    (vertical map).
   </Description>
</ManSection>

<Example><![CDATA[
gap> g := MorphismOnKernel(hom[1],hom[2],hom[1],hom[2]);
<mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <6-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> IsomorphicModules(Source(g),Range(g));
true
gap> p := ProjectiveCover(N);
<mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> N1 := Kernel(p);
<17-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> pullback := PullBack(p,hom[1]);
[ <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    7-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> Kernel(pullback[1]);
<17-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> IsomorphicModules(N1,Kernel(pullback[1]));
true
gap> t := LiftingMorphismFromProjective(p,p*hom[1]);
<mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <24-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> s := MorphismOnKernel(p,p,t,hom[1]);    
<mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <17-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> Source(s)=N1;
true
gap> q := KernelInclusion(p);
<mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <24-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> pushout := PushOut(q,s);
[ <mapping: <17-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    24-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> U := CoKernel(pushout[1]);
<7-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> IsomorphicModules(U,N);
true
]]></Example>

<ManSection>
   <Oper Name="RadicalOfModuleInclusion" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the inclusion of the radical of the module <Arg>M</Arg>
   into <Arg>M</Arg>.</Returns>
   <Description>
    The radical of <Arg>M</Arg> can be accessed
    using <Code>Source</Code>, or it can be computed directly via the
    command <Ref Oper="RadicalOfModule"/>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleOfModuleInclusion" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the inclusion of the socle of the module <Arg>M</Arg>
   into <Arg>M</Arg>.</Returns>
   <Description>
    The socle of <Arg>M</Arg> can be accessed
    using <Code>Source</Code>, or it can be computed directly via the
    command <Ref Oper="SocleOfModule"/>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SubRepresentationInclusion" Arg="M, gens" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module, <Arg>gens</Arg> - a list of elements in
     <Arg>M</Arg>.<Br />
   </Description>
   <Returns>the inclusion of the submodule generated by the
   generators <Arg>gens</Arg> into the module <Arg>M</Arg>.</Returns>
   <Description>
    The function checks if <Arg>gens</Arg> consists of elements
    in <Arg>M</Arg>, and returns an error message otherwise. The
    module given by the submodule generated by the
    generators <Arg>gens</Arg> can be accessed using <Code>Source</Code>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="TopOfModuleProjection" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - a module.<Br />
   </Description>
   <Returns>the projection from the module <Arg>M</Arg> to the top of
   the module <Arg>M</Arg>.</Returns>
   <Description>
    The module given by the top of the module <Arg>M</Arg> can
    be accessed using <Code>Range</Code> of the homomorphism.
   </Description>
</ManSection>

<Example><![CDATA[
gap> f := RadicalOfModuleInclusion(N);
<mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> radN := Source(f);
<4-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> g := SocleOfModuleInclusion(N);
<mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> U := SubRepresentationInclusion(N,[B[5]+B[6],B[7]]);
<mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> h := TopOfModuleProjection(N);
<mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <3-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
]]></Example>
</Section>

<Section><Heading>Homological algebra</Heading>

<ManSection>
   <Oper Name="ExtOverAlgebra" Arg="M, N" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg>, <Arg>N</Arg> - two modules.<Br />
   </Description>
   <Returns>the map from the first syzygy, <M>\Omega(M)</M> to the
   projective cover, <M>P(M)</M> of the module <Arg>M</Arg>, and
   in addition a basis of <Math>\Ext^1(M,N)</Math> in terms of elements
   in <Math>\Hom(\Omega(M),N)</Math>.</Returns>
   <Description>
    The function checks if the arguments <Arg>M</Arg> and <Arg>N</Arg>
    are modules of the same algebra, and returns an error message
    otherwise. It <Math>\Ext^1(M,N)</Math> is zero, an empty list is
    returned.
   </Description>
</ManSection>

</Section>

<Section><Heading>Auslander-Reiten theory</Heading>

<ManSection>
   <Oper Name="AlmostSplitSequence" Arg="M" Comm=""/>
   <Description>
     Arguments: <Arg>M</Arg> - an indecomposable non-projective module.<Br />
   </Description>
   <Returns>the almost split sequence ending in the
   module <Arg>M</Arg> if it is indecomposable and not projective. It
   returns the almost split sequence in terms of two maps, a left
   minimal almost split map and a right minimal almost split map.
   </Returns>
   <Description>
    The range of the right minimal almost split map is not necessarily
    equal to the module <Arg>M</Arg> one started with, but isomorphic.
   </Description>
</ManSection>

<Example><![CDATA[
gap> S := SimpleModules(A);
[ <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
  <right-module over <algebra-with-one over Rationals, with 8 generators>>, 
  <right-module over <algebra-with-one over Rationals, with 8 generators>> ]
gap> Ext:=ExtOverAlgebra(S[2],S[2]);
[ <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    4-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  [ <mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
        [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
          [(1)*e] ] )> -> <
        1-dimensional right-module over AlgebraWithOne( Rationals, 
        [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
          [(1)*e] ] )> > ] ]
gap> Length(Ext[2]);
1
gap> # i.e. Ext^1(S[2],S[2]) is 1-dimensional
gap> pushout := PushOut(Ext[2][1],Ext[1]);   
[ <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    2-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <4-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    2-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> f:= CoKernelProjection(pushout[1]);
<mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> -> <1-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )> >
gap> U := Range(pushout[1]);            
<2-dimensional right-module over <algebra-with-one over Rationals, with 
8 generators>>
gap> assU := AlmostSplitSequence(U);
[ <mapping: <6-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    8-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> >, 
  <mapping: <8-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> -> <
    2-dimensional right-module over AlgebraWithOne( Rationals, 
    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], 
      [(1)*e] ] )> > ]
gap> assU[1]*assU[2] = Zero(assU[1]*assU[2]);
true
]]></Example>
</Section>
</Chapter>

<Chapter>
<Heading>Chain complexes</Heading>
TODO


<Section>
<Heading>Representation of categories</Heading>

A chain complex consists of objects and morphisms from some category.
In QPA, this category will usually be the category of right modules
over some quotient of a path algebra.

(TODO)

</Section>


<Section>
<Heading>Making a complex</Heading>

The most general constructor for complexes is the function
<Ref Func="Complex"/>.  In addition to this, there are constructors
for common special cases:
<List>
<Item><Ref Func="ZeroComplex"/></Item>
<Item><Ref Func="SingleObjectComplex"/></Item>
<Item><Ref Func="FiniteComplex"/></Item>
<Item><Ref Func="ShortExactSequence"/></Item>
</List>
<!-- TODO: ComplexByDifferentialList -->

<ManSection>
<Filt Type="Category" Name="IsComplex"/>
<Description>
The category for chain complexes.
</Description>
</ManSection>

<ManSection>
<Filt Type="Category" Name="IsZeroComplex"/>
<Description>
Category for zero complexes, subcategory of <Ref Filt="IsComplex"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Complex"
      Arg="cat, baseDegree, middle, positive, negative"/>
<Returns>A newly created chain complex</Returns>
<Description>
The first argument, <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The rest of the arguments describe the differentials of the complex.
These are divided into three parts: one finite (<Q>middle</Q>) and two
infinite (<Q>positive</Q> and <Q>negative</Q>).  The positive part
contains all differentials in degrees higher than those in the middle
part, and the negative part contains all differentials in degrees
lower than those in the middle part.  (The middle part may be placed
anywhere, so the positive part can -- despite its name -- contain some
differentials of negative degree.  Conversely, the negative part can
contain some differentials of positive degree.)<P/>

The argument <Arg>middle</Arg> is a list containing the differentials
for the middle part.  The argument <Arg>baseDegree</Arg> gives the
degree of the first differential in this list.  The second
differential is placed in degree <M><Arg>baseDegree</Arg>+1</M>, and
so on.  Thus, the middle part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>).
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero objects and zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the differentials in <Code>L</Code> repeated infinitely many times.
  The convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the differential which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the differentials in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>Complex</Code> constructor, but will be called later as
  the differentials in this part are needed.  The function
  call <Code>f(C,i)</Code> (where <Code>C</Code> is the complex
  and <Code>i</Code> an integer) should produce the differential in
  degree <Code>i</Code>.  The function may use <Code>C</Code> to look
  up other differentials in the complex, as long as this does not
  cause an infinite loop.  If <Code>store</Code> is <Code>true</Code>
  (or not specified), each computed differential is stored, and they
  are computed in order from the one closest to the middle part,
  regardless of which order they are requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the differentials in this part.  For the first
  differential in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next differential, <Code>f</Code> is called with
  the first differential as argument, and so on.  Thus, the
  differentials are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each differential is stored when it has been computed.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ZeroComplex" Arg="cat"/>
<Returns>A newly created zero complex</Returns>
<Description>
This function creates a zero complex (a complex consisting of only
zero objects and zero morphisms) over the category described by the
<Ref Filt="IsCat"/> object <Arg>cat</Arg>.
</Description>
</ManSection>

<ManSection>
<Func Name="FiniteComplex" Arg="cat, baseDegree, differentials"/>
<Returns>A newly created complex</Returns>
<Description>
This function creates a complex where all but finitely many objects
are the zero object.<P/>

The argument <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The argument <Arg>differentials</Arg> is a list of morphisms.  The
argument <Arg>baseDegree</Arg> gives the degree for the first
differential in this list.  The subsequent differentials are placed in
degrees <M><Arg>baseDegree</Arg>+1</M>, and so on.<P/>

This means that the <Arg>differentials</Arg> argument specifies the
differentials in degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>);
</Display>
and thus implicitly the objects in degrees
<Display>
<Arg>baseDegree</Arg> - 1,\quad
<Arg>baseDegree</Arg>,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>).
</Display>
All other objects in the complex are zero.
</Description>
</ManSection>

</Section>


<Section>
<Heading>Information about a complex</Heading>

</Section>


<Section>
<Heading>Transforming and combinig complexes</Heading>

</Section>


<Section>
<Heading>Chain maps</Heading>

</Section>

</Chapter>
</Body>

<Appendix Label="Appendix">
<Heading>An Appendix</Heading>
<Label Name="ElevenBack"/>

This is an appendix. 
</Appendix>

<Bibliography Databases="" Style="alpha"/>
<TheIndex/>

</Book>

