<Chapter>
<Heading>Chain complexes</Heading>
(Not completely documentet yet.)


<Section>
<Heading>Representation of categories</Heading>

A chain complex consists of objects and morphisms from some category.
In QPA, this category will usually be the category of right modules
over some quotient of a path algebra.

<ManSection>
<Filt Type="Category" Name="IsCat"/>
<Description>
The category for categories. A category is a record, storing a number
of properties that is specified within each category. Two categories can
be compared using <C>=</C>. Currently, the only implemented category
is the one of right modules over a (quotient of a) path algebra.
</Description>
</ManSection>

<ManSection>
<Oper Name="CatOfRightAlgebraModules" Arg="A"/>
  <Description>Arguments: <Arg>A</Arg> -- a (quotient of a) path
  algebra.<Br />
  </Description>
  <Returns>The category mod <Math>A</Math>.
  </Returns>
  <Description>
    mod <Math>A</Math> has several properties, which can be accessed
    using the <C>.</C> mark. Some of the properties store
    functions. All properties are demonstrated in the following
    example.
    <List>
      <Item><C>zeroObj</C> -- returns the zero module of
      mod <Math>A</Math>.</Item>
      <Item><C>isZeroObj</C> -- returns true if the given module is zero.</Item>
      <Item><C>zeroMap</C> -- returns the ZeroMapping function.</Item>
      <Item><C>isZeroMapping</C> -- returns the IsZero test.</Item>
      <Item><C>composeMaps</C> -- returns the composition of the two
      given maps.</Item>
      <Item><C>ker</C> -- returns the Kernel function.</Item>
      <Item><C>im</C> -- returns the Image function.</Item>
      <Item><C>isExact</C> -- returns true if two consecutive maps
      are exact. </Item>
    </List>
  </Description>
</ManSection>

<Example><![CDATA[
gap> alg;
<algebra-with-one over Rationals, with 7 generators>
gap> # L, M, and N are alg-modules
gap> # f: L --> M and g: M --> N are non-zero morphisms
gap> cat := CatOfRightAlgebraModules(alg);
<cat: right modules over algebra>
gap> cat.zeroObj;
<right-module over <algebra-with-one over Rationals, with 7 generators>>
gap> cat.isZeroObj(M);
false
gap> cat.zeroMap(M,N);
<mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ])> -> 
  <1-dimensional right-module over AlgebraWithOne( Rationals,
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
gap> cat.composeMaps(g,f);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c]]
  -> <1-dimensional right-module over AlgebraWithOne( Rationals,
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
gap> cat.ker(g);
<2-dimensional right-module over <algebra-with-one over Rationals,
  with 7 generators>>
gap> cat.isExact(g,f);
false ]]>
</Example>

</Section>


<Section>
<Heading>Making a complex</Heading>

The most general constructor for complexes is the function
<Ref Func="Complex"/>.  In addition to this, there are constructors
for common special cases:
<List>
<Item><Ref Func="ZeroComplex"/></Item>
<Item><Ref Func="StalkComplex"/></Item>
<Item><Ref Func="FiniteComplex"/></Item>
<Item><Ref Func="ShortExactSequence"/></Item>
</List>
<!-- TODO: ComplexByDifferentialList -->

<ManSection>
<Filt Type="Category" Name="IsComplex"/>
<Description>
The category for chain complexes.
</Description>
</ManSection>

<ManSection>
<Filt Type="Category" Name="IsZeroComplex"/>
<Description>
Category for zero complexes, subcategory of <Ref Filt="IsComplex"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Complex"
      Arg="cat, baseDegree, middle, positive, negative"/>
<Returns>A newly created chain complex</Returns>
<Description>
The first argument, <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The rest of the arguments describe the differentials of the complex.
These are divided into three parts: one finite (<Q>middle</Q>) and two
infinite (<Q>positive</Q> and <Q>negative</Q>).  The positive part
contains all differentials in degrees higher than those in the middle
part, and the negative part contains all differentials in degrees
lower than those in the middle part.  (The middle part may be placed
anywhere, so the positive part can -- despite its name -- contain some
differentials of negative degree.  Conversely, the negative part can
contain some differentials of positive degree.)<P/>

The argument <Arg>middle</Arg> is a list containing the differentials
for the middle part.  The argument <Arg>baseDegree</Arg> gives the
degree of the first differential in this list.  The second
differential is placed in degree <M><Arg>baseDegree</Arg>+1</M>, and
so on.  Thus, the middle part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>).
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero objects and zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the differentials in <Code>L</Code> repeated infinitely many times.
  The convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the differential which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the differentials in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>Complex</Code> constructor, but will be called later as
  the differentials in this part are needed.  The function
  call <Code>f(C,i)</Code> (where <Code>C</Code> is the complex
  and <Code>i</Code> an integer) should produce the differential in
  degree <Code>i</Code>.  The function may use <Code>C</Code> to look
  up other differentials in the complex, as long as this does not
  cause an infinite loop.  If <Code>store</Code> is <Code>true</Code>
  (or not specified), each computed differential is stored, and they
  are computed in order from the one closest to the middle part,
  regardless of which order they are requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the differentials in this part.  For the first
  differential in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next differential, <Code>f</Code> is called with
  the first differential as argument, and so on.  Thus, the
  differentials are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each differential is stored when it has been computed.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ZeroComplex" Arg="cat"/>
<Returns>A newly created zero complex</Returns>
<Description>
This function creates a zero complex (a complex consisting of only
zero objects and zero morphisms) over the category described by the
<Ref Filt="IsCat"/> object <Arg>cat</Arg>.
</Description>
</ManSection>

<ManSection>
<Func Name="FiniteComplex" Arg="cat, baseDegree, differentials"/>
<Returns>A newly created complex</Returns>
<Description>
This function creates a complex where all but finitely many objects
are the zero object.<P/>

The argument <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The argument <Arg>differentials</Arg> is a list of morphisms.  The
argument <Arg>baseDegree</Arg> gives the degree for the first
differential in this list.  The subsequent differentials are placed in
degrees <M><Arg>baseDegree</Arg>+1</M>, and so on.<P/>

This means that the <Arg>differentials</Arg> argument specifies the
differentials in degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>);
</Display>
and thus implicitly the objects in degrees
<Display>
<Arg>baseDegree</Arg> - 1,\quad
<Arg>baseDegree</Arg>,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>).
</Display>
All other objects in the complex are zero.
</Description>
</ManSection>

<Example><![CDATA[
gap> # L, M and N are modules over the same algebra A
gap> # cat is the category mod A
gap> # f: L --> M and g: M --> N maps
gap> C := FiniteComplex(cat, 1, [g,f]);
0 -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> 0 ]]>
</Example>

<ManSection>
  <Func Name="StalkComplex" Arg="cat, obj, degree" />
  <Description>
    Arguments: <Arg>cat</Arg> -- a category, <Arg>obj</Arg> -- an
    object in <Arg>cat</Arg>, <Arg>degree</Arg> -- the
    degree <Arg>obj</Arg> should be placed in.<Br />
  </Description>
  <Returns>a newly created complex.
  </Returns>
  <Description>
    The new complex is a stalk complex with <Arg>obj</Arg> in
    position <Arg>degree</Arg>, and zero elsewhere.
  </Description>
</ManSection>

<Example><![CDATA[
gap> Ms := StalkComplex(cat, M, 3);
0 -> 3:(2,2) -> 0 ]]>
</Example>

<ManSection>
  <Func Name="ShortExactSequence" Arg="cat, f, g" />
  <Description>
    Arguments: <Arg>cat</Arg> -- a category, <Arg>f</Arg>
    and <Arg>g</Arg> -- maps in <Arg>cat</Arg>,
    where <Arg>f</Arg>: <Math>A \rightarrow B</Math>
    and <Arg>g</Arg>: <Math>B \rightarrow C</Math>.<Br />
  </Description>
  <Returns>a newly created complex.
  </Returns>
  <Description>If the sequence <Math>0 \rightarrow A \rightarrow B \rightarrow
  C \rightarrow 0</Math> is exact, this complex  (with <Math>B</Math>
  in degree 0) is returned.
  </Description>
</ManSection>

<Example><![CDATA[
gap> ses := ShortExactSequence(cat, f, g);
0 -> 1:(0,0,1,0) -> 0:(0,1,1,1) -> -1:(0,1,0,1) -> 0 ]]>
</Example>



</Section>


<Section>
<Heading>Information about a complex</Heading>

<ManSection>
  <Attr Name="CatOfComplex" Arg="C"/>
  <Returns>
    The category the objects of the complex <Arg>C</Arg> live in.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ObjectOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>
    The object at position <Arg>i</Arg> in the complex.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="DifferentialOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>
    The map in <Arg>C</Arg> between objects at
    positions <Math>i</Math> and <Math>i-1</Math>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="DifferentialsOfComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex<Br />
  </Description>
  <Returns>
    The differentials of the complex, stored as an <C>IsInfList</C>
    object.
  </Returns>
</ManSection>

<ManSection>
  <Oper Name="CyclesOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer. <Br />
  </Description>
  <Returns>The <Math>i</Math>-cycle of the complex, that is the
  subobject <Math>Ker(d_i)</Math> of <C>ObjectOfComplex(C,i)</C>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BoundariesOfComplex" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer. <Br />
  </Description>
  <Returns> The <Math>i</Math>-boundary of the complex, that is the
  subobject <Math>Im(d_{i+1})</Math> of <C>ObjectOfComplex(C,i)</C>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="HomologyOfComplex" Arg="C,i" />
  <Description>
    Arguments:  <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns> The <Math>i</Math>th homology of the complex, that
  is, <Math>Ker(d_i)/Im(d_{i+1})</Math>.
  </Returns>
  <Description>Note: this operation is currently not available. When
  working in the category of right <Math>kQ/I</Math>-modules, it is
  possible to "cheat" and use the following procedure to compute the
  homology of a complex:
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;                     
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> # Want to compute the homology in degree 2
gap> f := DifferentialOfComplex(C,3);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> g := KernelInclusion(DifferentialOfComplex(C,2));
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> # We know that Im f is included in Ker g, so can find the
gap> # lifting morphism h from C_3 to Ker g.
gap> h := LiftingInclusionMorphisms(g,f);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> # The cokernel of h is Ker g / Im f 
gap> Homology := CoKernel(h);
<1-dimensional right-module over <algebra-with-one over Rationals, with 
  4 generators>> ]]>
</Example>

<ManSection>
  <Oper Name="IsFiniteComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is a finite complex, false otherwise.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="UpperBound" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>If it exists: The smallest integer <Math>i</Math> such that
  the object at position <Math>i</Math> is non-zero, but for
  all <Math>j &gt; i</Math> the object at position <Math>j</Math> is zero.
  </Returns>
  <Description>If <Arg>C</Arg> is not a finite complex, the operation
  will return fail or infinity, depending on how <Arg>C</Arg> was defined.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LowerBound" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>If it exists: The greatest integer <Math>i</Math> such that
  the object at position <Math>i</Math> is non-zero, but for
  all <Math>j &lt; i</Math> the object at position <Math>j</Math> is zero.
  </Returns>
  <Description>If <Arg>C</Arg> is not a finite complex, the operation
  will return fail or negative infinity, depending on how <Arg>C</Arg>
  was defined.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LengthOfComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>the length of the complex.
  </Returns>
  <Description>The length is defined as follows: If <Arg>C</Arg> is a
  zero complex, the length is zero. If <Arg>C</Arg> is a finite
  complex, the lenght is the upper bound -- the lower bound +
  1. If <Arg>C</Arg> is an inifinite complex, the lenght is infinity.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="HighestKnownDegree" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>The greatest integer <Math>i</Math> such that the object at
  position <Math>i</Math> is known (or computed).
  </Returns>
  <Description>For a finite complex, this will be infinity.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LowestKnownDegree" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>The smallest integer <Math>i</Math> such that the object at
  position <Math>i</Math> is known (or computed).
  </Returns>
  <Description>For a finite complex, this will be negative infinity.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> IsFiniteComplex(C);
true
gap> UpperBound(C);
4
gap> LowerBound(C);
0
gap> LengthOfComplex(C);
5
gap> HighestKnownDegree(C);
+inf
gap> LowestKnownDegree(C);
-inf ]]>
</Example>

<ManSection>
  <Prop Name="IsExactSequence" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact at every position.
  </Returns>
  <Description>If the complex is not finite and not repeating, the
  function fails.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="IsExactInDegree" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact at position <Arg>i</Arg>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Prop Name="IsShortExactSequence" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact and of the form 
    <Display>
      \ldots \rightarrow 0 \rightarrow A \rightarrow B \rightarrow C
      \rightarrow 0 \rightarrow \ldots
    </Display>
    This could be positioned in any degree (as opposed to the
    construction of a short exact sequence, where <Math>B</Math> will
    be put in degree zero).
  </Returns>
  <Description>
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;                
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> IsExactSequence(C);
false
gap> IsExactInDegree(C,1);
true
gap> IsExactInDegree(C,2);
false ]]>
</Example>



</Section>


<Section>
<Heading>Transforming and combinig complexes</Heading>

<ManSection>
  <Oper Name="Shift" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A new complex, which is a shift of <Arg>C</Arg>.
  </Returns>
  <Description>If <Arg>i</Arg> &gt; 0, the complex is shifted to the
  left. If <Arg>i</Arg> &lt; 0, the complex is shifted to the
  right. Note that shifting might change the differentials: In the
  shifted complex, <Math>d_{new}</Math> is defined to
  be <Math>(-1)^i d_{old}</Math>.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> Shift(C,1);
0 -> 3:(0,1) -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> -1:(2,2) -> 0
gap> D := Shift(C,-1);
0 -> 5:(0,1) -> 4:(1,0) -> 3:(2,2) -> 2:(1,1) -> 1:(2,2) -> 0
gap> dc := DifferentialOfComplex(C,3)!.maps;
[ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
gap> dd := DifferentialOfComplex(D,4)!.maps;
[ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ]
gap> MatricesOfPathAlgebraMatModuleHomomorphism(dc);
[ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
gap> MatricesOfPathAlgebraMatModuleHomomorphism(dd);
[ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ] ]]>
</Example>

<ManSection>
  <Oper Name="YonedaProduct" Arg="C, D" />
  <Description>
    Arguments: <Arg>C</Arg>, <Arg>D</Arg> -- complexes.<Br />
  </Description>
  <Returns>The Yoneda product of the two complexes, which is a complex.
  </Returns>
  <Description>To compute the Yoneda product, <Arg>C</Arg>
  and <Arg>D</Arg> must be such that the object in
  degree <C>LowerBound(C)</C> equals the object in
  degree <C>UpperBound(D)</C>, that is
    <Display>
      \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow A
      \rightarrow 0 \rightarrow \ldots
    </Display>
    <Display>
      \ldots \rightarrow 0 \rightarrow A \rightarrow D_{j} \rightarrow D_{j-1}
      \rightarrow \ldots
    </Display>
    The product is of this form:
    <Display>
      \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow D_{j}
      \rightarrow D_{j-1} \rightarrow \ldots
    </Display>
    where the map <Math>C_{i} \rightarrow D_{j}</Math> is the
    composition of the maps <Math>C_{i} \rightarrow A</Math>
    and <Math>A \rightarrow D_{j}</Math>. Also, the
    object <Math>D_{j}</Math> is in degree <Math>j</Math>.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C2;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(0,0) -> 0
gap> C3;
0 -> -1:(1,1) -> -2:(2,2) -> -3:(1,1) -> 0
gap> YonedaProduct(C2,C3);
0 -> 1:(0,1) -> 0:(1,0) -> -1:(2,2) -> -2:(2,2) -> -3:(1,1) -> 0 ]]>
</Example>

<ManSection>
  <Oper Name="BrutalTruncationBelow" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace all objects with degree <Math>j</Math>
  &lt; <Math>i</Math> with zero. The differentials affected will
  also become zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BrutalTruncationAbove" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace all objects with degree <Math>j</Math>
  &gt; <Math>i</Math> with zero. The differentials affected will also
  become zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BrutalTruncation" Arg="C,i,j" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i, j</Arg> -- integers.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Brutally truncates in both ends. The integer arguments
  must be ordered such that <Arg>i</Arg> &gt; <Arg>j</Arg>.
  </Description>
</ManSection>


</Section>


<Section>
<Heading>Chain maps</Heading>

Work in progress.



</Section>

</Chapter>
