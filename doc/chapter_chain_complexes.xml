<Chapter>
<Heading>Chain complexes</Heading>

<Section>
<Heading>Introduction</Heading> If <M>\mathcal{A}</M> is an abelian
category, then a chain complex of objects of <M>\mathcal A</M> is a
sequence 
<Display>
  \cdots \longrightarrow C_{i+1} \stackrel{d_{i+1}}{\longrightarrow}
  C_i \stackrel{d_i}{\longrightarrow} C_{i-1}
  \stackrel{d_{i-1}}{\longrightarrow} \cdots
</Display>
where <M>C_i</M> is an object of <M>\mathcal A</M> for all <M>i</M>,
and <M>d_i</M> is a morphism of <M>\mathcal A</M> for all <M>i</M>
such that the composition of two consecutive maps is zero.  The maps
are called the differentials of the complex.  A complex is called
<E>bounded above</E> (resp. below) if there is a bound <M>b</M> such
that <M>C_i = 0</M> for all <M>i&gt;b</M> (resp. <M>i&lt;b</M>). A
complex is <E>bounded</E> if it is both bounded below and bounded
above.
<P />
The challenge when representing chain complexes in software is to
handle their infinite nature.  If a complex is not bounded, or not
known to be bounded, how can we represent it in an immutable way?  Our
solution is to use a category called <C>InfList</C> (for "infinite
list") to store the differentials of the complex.  The properties of
the <C>IsInfList</C> category is described in <Ref Sect="InfLists"/>.
An <C>IsComplex</C> object consists of one <C>IsInfList</C> for the
differentials, and it also has an <C>IsCat</C> object as an attribute.
The <C>IsCat</C> category is a representation of an abelian category,
see <Ref Sect="Cats" />.
<P />
To work with bounded complexes one does not need to know much about
the <C>IsInfList</C> category.  A bounded complex can be created by
simply giving a list of the differentials and the degree of the first
differential as input (see <Ref Func="FiniteComplex"/>), and to create
a stalk complex the stalk object and its degree suffers as input (see
<Ref Func="StalkComplex"/>).  In both cases an <C>IsCat</C> object is
also needed.

<Example><![CDATA[
 gap> C := FiniteComplex(cat, 1, [g,f]);
 0 -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> 0 
 gap> Ms := StalkComplex(cat, M, 3);
 0 -> 3:(2,2) -> 0 ]]>
</Example>
</Section>

<Section Label="InfLists">
<Heading>Infinite lists</Heading> 
<ManSection>
  <Filt Type="Var" Name="PositiveInfinity"/>
  <Description>

  </Description>
</ManSection>

<ManSection>
<Filt Type="Category" Name="IsInfList"/>
<Description>
  An infinite list is an immutable representation of a list with
  possibly infinite range of indeces.  It consists of three parts: The
  "middle part" is finite and covers some range <M>[a,b]</M> of
  indices, the "positive part" covers the range <M>[b+1,\infty]</M> of
  indices, and the "negative part" convers the range
  <M>(-\infty,a-1]</M> of indices.
  <P />
  Each of the two infinite parts are described in one of the following
  ways: (1) A finite list which is repeated indefinitely; (2) A
  function which takes an index in the list as argument and returns
  the corresponding list item; (3) A function which takes an item from
  the list as argument and returns the next item.
</Description>
</ManSection>

</Section>

<Section Label="Cats">
<Heading>Representation of categories</Heading>

A chain complex consists of objects and morphisms from some category.
In QPA, this category will usually be the category of right modules
over some quotient of a path algebra.

<ManSection>
<Filt Type="Category" Name="IsCat"/>
<Description>
The category for categories. A category is a record, storing a number
of properties that is specified within each category. Two categories can
be compared using <C>=</C>. Currently, the only implemented category
is the one of right modules over a (quotient of a) path algebra.
</Description>
</ManSection>

<ManSection>
<Oper Name="CatOfRightAlgebraModules" Arg="A"/>
  <Description>Arguments: <Arg>A</Arg> -- a (quotient of a) path
  algebra.<Br />
  </Description>
  <Returns>The category mod <Math>A</Math>.
  </Returns>
  <Description>
    mod <Math>A</Math> has several properties, which can be accessed
    using the <C>.</C> mark. Some of the properties store
    functions. All properties are demonstrated in the following
    example.
    <List>
      <Item><C>zeroObj</C> -- returns the zero module of
      mod <Math>A</Math>.</Item>
      <Item><C>isZeroObj</C> -- returns true if the given module is zero.</Item>
      <Item><C>zeroMap</C> -- returns the ZeroMapping function.</Item>
      <Item><C>isZeroMapping</C> -- returns the IsZero test.</Item>
      <Item><C>composeMaps</C> -- returns the composition of the two
      given maps.</Item>
      <Item><C>ker</C> -- returns the Kernel function.</Item>
      <Item><C>im</C> -- returns the Image function.</Item>
      <Item><C>isExact</C> -- returns true if two consecutive maps
      are exact. </Item>
    </List>
  </Description>
</ManSection>

<Example><![CDATA[
gap> alg;
<algebra-with-one over Rationals, with 7 generators>
gap> # L, M, and N are alg-modules
gap> # f: L --> M and g: M --> N are non-zero morphisms
gap> cat := CatOfRightAlgebraModules(alg);
<cat: right modules over algebra>
gap> cat.zeroObj;
<right-module over <algebra-with-one over Rationals, with 7 generators>>
gap> cat.isZeroObj(M);
false
gap> cat.zeroMap(M,N);
<mapping: <3-dimensional right-module over AlgebraWithOne( Rationals, 
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ])> -> 
  <1-dimensional right-module over AlgebraWithOne( Rationals,
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
gap> cat.composeMaps(g,f);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c]]
  -> <1-dimensional right-module over AlgebraWithOne( Rationals,
  [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*v4], [(1)*a], [(1)*b], [(1)*c] ] )> >
gap> cat.ker(g);
<2-dimensional right-module over <algebra-with-one over Rationals,
  with 7 generators>>
gap> cat.isExact(g,f);
false ]]>
</Example>

</Section>


<Section>
<Heading>Making a complex</Heading>

The most general constructor for complexes is the function
<Ref Func="Complex"/>.  In addition to this, there are constructors
for common special cases:
<List>
<Item><Ref Func="ZeroComplex"/></Item>
<Item><Ref Func="StalkComplex"/></Item>
<Item><Ref Func="FiniteComplex"/></Item>
<Item><Ref Func="ShortExactSequence"/></Item>
</List>
<!-- TODO: ComplexByDifferentialList -->

<ManSection>
<Filt Type="Category" Name="IsComplex"/>
<Description>
The category for chain complexes.
</Description>
</ManSection>

<ManSection>
<Filt Type="Category" Name="IsZeroComplex"/>
<Description>
Category for zero complexes, subcategory of <Ref Filt="IsComplex"/>.
</Description>
</ManSection>

<ManSection>
<Func Name="Complex"
      Arg="cat, baseDegree, middle, positive, negative"/>
<Returns>A newly created chain complex</Returns>
<Description>
The first argument, <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The rest of the arguments describe the differentials of the complex.
These are divided into three parts: one finite (<Q>middle</Q>) and two
infinite (<Q>positive</Q> and <Q>negative</Q>).  The positive part
contains all differentials in degrees higher than those in the middle
part, and the negative part contains all differentials in degrees
lower than those in the middle part.  (The middle part may be placed
anywhere, so the positive part can -- despite its name -- contain some
differentials of negative degree.  Conversely, the negative part can
contain some differentials of positive degree.)<P/>

The argument <Arg>middle</Arg> is a list containing the differentials
for the middle part.  The argument <Arg>baseDegree</Arg> gives the
degree of the first differential in this list.  The second
differential is placed in degree <M><Arg>baseDegree</Arg>+1</M>, and
so on.  Thus, the middle part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>).
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero objects and zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the differentials in <Code>L</Code> repeated infinitely many times.
  The convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the differential which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the differentials in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>Complex</Code> constructor, but will be called later as
  the differentials in this part are needed.  The function
  call <Code>f(C,i)</Code> (where <Code>C</Code> is the complex
  and <Code>i</Code> an integer) should produce the differential in
  degree <Code>i</Code>.  The function may use <Code>C</Code> to look
  up other differentials in the complex, as long as this does not
  cause an infinite loop.  If <Code>store</Code> is <Code>true</Code>
  (or not specified), each computed differential is stored, and they
  are computed in order from the one closest to the middle part,
  regardless of which order they are requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the differentials in this part.  For the first
  differential in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next differential, <Code>f</Code> is called with
  the first differential as argument, and so on.  Thus, the
  differentials are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each differential is stored when it has been computed.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ZeroComplex" Arg="cat"/>
<Returns>A newly created zero complex</Returns>
<Description>
This function creates a zero complex (a complex consisting of only
zero objects and zero morphisms) over the category described by the
<Ref Filt="IsCat"/> object <Arg>cat</Arg>.
</Description>
</ManSection>

<ManSection>
<Func Name="FiniteComplex" Arg="cat, baseDegree, differentials"/>
<Returns>A newly created complex</Returns>
<Description>
This function creates a complex where all but finitely many objects
are the zero object.<P/>

The argument <Arg>cat</Arg> is an <Ref Filt="IsCat"/> object
describing the category to create a chain complex over.<P/>

The argument <Arg>differentials</Arg> is a list of morphisms.  The
argument <Arg>baseDegree</Arg> gives the degree for the first
differential in this list.  The subsequent differentials are placed in
degrees <M><Arg>baseDegree</Arg>+1</M>, and so on.<P/>

This means that the <Arg>differentials</Arg> argument specifies the
differentials in degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>);
</Display>
and thus implicitly the objects in degrees
<Display>
<Arg>baseDegree</Arg> - 1,\quad
<Arg>baseDegree</Arg>,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>differentials</Arg>).
</Display>
All other objects in the complex are zero.
</Description>
</ManSection>

<Example><![CDATA[
gap> # L, M and N are modules over the same algebra A
gap> # cat is the category mod A
gap> # f: L --> M and g: M --> N maps
gap> C := FiniteComplex(cat, 1, [g,f]);
0 -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> 0 ]]>
</Example>

<ManSection>
  <Func Name="StalkComplex" Arg="cat, obj, degree" />
  <Description>
    Arguments: <Arg>cat</Arg> -- a category, <Arg>obj</Arg> -- an
    object in <Arg>cat</Arg>, <Arg>degree</Arg> -- the
    degree <Arg>obj</Arg> should be placed in.<Br />
  </Description>
  <Returns>a newly created complex.
  </Returns>
  <Description>
    The new complex is a stalk complex with <Arg>obj</Arg> in
    position <Arg>degree</Arg>, and zero elsewhere.
  </Description>
</ManSection>

<Example><![CDATA[
gap> Ms := StalkComplex(cat, M, 3);
0 -> 3:(2,2) -> 0 ]]>
</Example>

<ManSection>
  <Func Name="ShortExactSequence" Arg="cat, f, g" />
  <Description>
    Arguments: <Arg>cat</Arg> -- a category, <Arg>f</Arg>
    and <Arg>g</Arg> -- maps in <Arg>cat</Arg>,
    where <Arg>f</Arg>: <Math>A \rightarrow B</Math>
    and <Arg>g</Arg>: <Math>B \rightarrow C</Math>.<Br />
  </Description>
  <Returns>a newly created complex.
  </Returns>
  <Description>If the sequence <Math>0 \rightarrow A \rightarrow B \rightarrow
  C \rightarrow 0</Math> is exact, this complex  (with <Math>B</Math>
  in degree 0) is returned.
  </Description>
</ManSection>

<Example><![CDATA[
gap> ses := ShortExactSequence(cat, f, g);
0 -> 1:(0,0,1,0) -> 0:(0,1,1,1) -> -1:(0,1,0,1) -> 0 ]]>
</Example>



</Section>


<Section>
<Heading>Information about a complex</Heading>

<ManSection>
  <Attr Name="CatOfComplex" Arg="C"/>
  <Returns>
    The category the objects of the complex <Arg>C</Arg> live in.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="ObjectOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>
    The object at position <Arg>i</Arg> in the complex.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="DifferentialOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>
    The map in <Arg>C</Arg> between objects at
    positions <Math>i</Math> and <Math>i-1</Math>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="DifferentialsOfComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex<Br />
  </Description>
  <Returns>
    The differentials of the complex, stored as an <C>IsInfList</C>
    object.
  </Returns>
</ManSection>

<ManSection>
  <Oper Name="CyclesOfComplex" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer. <Br />
  </Description>
  <Returns>The <Math>i</Math>-cycle of the complex, that is the
  subobject <Math>Ker(d_i)</Math> of <C>ObjectOfComplex(C,i)</C>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BoundariesOfComplex" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer. <Br />
  </Description>
  <Returns> The <Math>i</Math>-boundary of the complex, that is the
  subobject <Math>Im(d_{i+1})</Math> of <C>ObjectOfComplex(C,i)</C>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="HomologyOfComplex" Arg="C,i" />
  <Description>
    Arguments:  <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns> The <Math>i</Math>th homology of the complex, that
  is, <Math>Ker(d_i)/Im(d_{i+1})</Math>.
  </Returns>
  <Description>Note: this operation is currently not available. When
  working in the category of right <Math>kQ/I</Math>-modules, it is
  possible to "cheat" and use the following procedure to compute the
  homology of a complex:
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;                     
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> # Want to compute the homology in degree 2
gap> f := DifferentialOfComplex(C,3);
<mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> g := KernelInclusion(DifferentialOfComplex(C,2));
  <mapping: <2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 4-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> # We know that Im f is included in Ker g, so can find the
gap> # lifting morphism h from C_3 to Ker g.
gap> h := LiftingInclusionMorphisms(g,f);
  <mapping: <1-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> ->
  < 2-dimensional right-module over AlgebraWithOne( Rationals, 
  [ [(1)*v1], [(1)*v2], [(1)*a], [(1)*b] ] )> >
gap> # The cokernel of h is Ker g / Im f 
gap> Homology := CoKernel(h);
<1-dimensional right-module over <algebra-with-one over Rationals, with 
  4 generators>> ]]>
</Example>

<ManSection>
  <Oper Name="IsFiniteComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is a finite complex, false otherwise.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Oper Name="UpperBound" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>If it exists: The smallest integer <Math>i</Math> such that
  the object at position <Math>i</Math> is non-zero, but for
  all <Math>j &gt; i</Math> the object at position <Math>j</Math> is zero.
  </Returns>
  <Description>If <Arg>C</Arg> is not a finite complex, the operation
  will return fail or infinity, depending on how <Arg>C</Arg> was defined.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LowerBound" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>If it exists: The greatest integer <Math>i</Math> such that
  the object at position <Math>i</Math> is non-zero, but for
  all <Math>j &lt; i</Math> the object at position <Math>j</Math> is zero.
  </Returns>
  <Description>If <Arg>C</Arg> is not a finite complex, the operation
  will return fail or negative infinity, depending on how <Arg>C</Arg>
  was defined.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LengthOfComplex" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>the length of the complex.
  </Returns>
  <Description>The length is defined as follows: If <Arg>C</Arg> is a
  zero complex, the length is zero. If <Arg>C</Arg> is a finite
  complex, the lenght is the upper bound -- the lower bound +
  1. If <Arg>C</Arg> is an inifinite complex, the lenght is infinity.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="HighestKnownDegree" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>The greatest integer <Math>i</Math> such that the object at
  position <Math>i</Math> is known (or computed).
  </Returns>
  <Description>For a finite complex, this will be infinity.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="LowestKnownDegree" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>The smallest integer <Math>i</Math> such that the object at
  position <Math>i</Math> is known (or computed).
  </Returns>
  <Description>For a finite complex, this will be negative infinity.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> IsFiniteComplex(C);
true
gap> UpperBound(C);
4
gap> LowerBound(C);
0
gap> LengthOfComplex(C);
5
gap> HighestKnownDegree(C);
+inf
gap> LowestKnownDegree(C);
-inf ]]>
</Example>

<ManSection>
  <Prop Name="IsExactSequence" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact at every position.
  </Returns>
  <Description>If the complex is not finite and not repeating, the
  function fails.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="IsExactInDegree" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact at position <Arg>i</Arg>.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Prop Name="IsShortExactSequence" Arg="C" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex.<Br />
  </Description>
  <Returns>true if <Arg>C</Arg> is exact and of the form 
    <Display>
      \ldots \rightarrow 0 \rightarrow A \rightarrow B \rightarrow C
      \rightarrow 0 \rightarrow \ldots
    </Display>
    This could be positioned in any degree (as opposed to the
    construction of a short exact sequence, where <Math>B</Math> will
    be put in degree zero).
  </Returns>
  <Description>
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;                
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> IsExactSequence(C);
false
gap> IsExactInDegree(C,1);
true
gap> IsExactInDegree(C,2);
false ]]>
</Example>

<ManSection>
  <Oper Name="ForEveryDegree" Arg="C,func" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>func</Arg> -- a
    function operating on two consecutive maps.<Br />
  </Description>
  <Returns>true if <Arg>func</Arg> returns true for any two
  consecutive differentials, fail if this can not be decided, false
  otherwise.
  </Returns>
</ManSection>

</Section>


<Section>
<Heading>Transforming and combining complexes</Heading>

<ManSection>
  <Oper Name="Shift" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A new complex, which is a shift of <Arg>C</Arg>.
  </Returns>
  <Description>If <Arg>i</Arg> &gt; 0, the complex is shifted to the
  left. If <Arg>i</Arg> &lt; 0, the complex is shifted to the
  right. Note that shifting might change the differentials: In the
  shifted complex, <Math>d_{new}</Math> is defined to
  be <Math>(-1)^i d_{old}</Math>.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(2,2) -> 0
gap> Shift(C,1);
0 -> 3:(0,1) -> 2:(1,0) -> 1:(2,2) -> 0:(1,1) -> -1:(2,2) -> 0
gap> D := Shift(C,-1);
0 -> 5:(0,1) -> 4:(1,0) -> 3:(2,2) -> 2:(1,1) -> 1:(2,2) -> 0
gap> dc := DifferentialOfComplex(C,3)!.maps;
[ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
gap> dd := DifferentialOfComplex(D,4)!.maps;
[ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ]
gap> MatricesOfPathAlgebraMatModuleHomomorphism(dc);
[ [ [ 1, 0 ] ], [ [ 0, 0 ] ] ]
gap> MatricesOfPathAlgebraMatModuleHomomorphism(dd);
[ [ [ -1, 0 ] ], [ [ 0, 0 ] ] ] ]]>
</Example>

<ManSection>
  <Oper Name="ShiftUnsigned" Arg="C, i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A new complex, which is a shift of <Arg>C</Arg>.
  </Returns>
  <Description>Does the same as <C>Shift</C>, except it does not
  change the sign of the differential. Although this is a
  non-mathematical definition of shift, it is still useful for
  technical purposes, when manipulating and creating complexes.
  </Description>
</ManSection>


<ManSection>
  <Oper Name="YonedaProduct" Arg="C, D" />
  <Description>
    Arguments: <Arg>C</Arg>, <Arg>D</Arg> -- complexes.<Br />
  </Description>
  <Returns>The Yoneda product of the two complexes, which is a complex.
  </Returns>
  <Description>To compute the Yoneda product, <Arg>C</Arg>
  and <Arg>D</Arg> must be such that the object in
  degree <C>LowerBound(C)</C> equals the object in
  degree <C>UpperBound(D)</C>, that is
    <Display>
      \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow A
      \rightarrow 0 \rightarrow \ldots
    </Display>
    <Display>
      \ldots \rightarrow 0 \rightarrow A \rightarrow D_{j} \rightarrow D_{j-1}
      \rightarrow \ldots
    </Display>
    The product is of this form:
    <Display>
      \ldots \rightarrow C_{i+1} \rightarrow C_{i} \rightarrow D_{j}
      \rightarrow D_{j-1} \rightarrow \ldots
    </Display>
    where the map <Math>C_{i} \rightarrow D_{j}</Math> is the
    composition of the maps <Math>C_{i} \rightarrow A</Math>
    and <Math>A \rightarrow D_{j}</Math>. Also, the
    object <Math>D_{j}</Math> is in degree <Math>j</Math>.
  </Description>
</ManSection>

<Example><![CDATA[
gap> C2;
0 -> 4:(0,1) -> 3:(1,0) -> 2:(2,2) -> 1:(1,1) -> 0:(0,0) -> 0
gap> C3;
0 -> -1:(1,1) -> -2:(2,2) -> -3:(1,1) -> 0
gap> YonedaProduct(C2,C3);
0 -> 1:(0,1) -> 0:(1,0) -> -1:(2,2) -> -2:(2,2) -> -3:(1,1) -> 0 ]]>
</Example>

<ManSection>
  <Oper Name="BrutalTruncationBelow" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace all objects with degree <Math>j</Math>
  &lt; <Math>i</Math> with zero. The differentials affected will
  also become zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BrutalTruncationAbove" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace all objects with degree <Math>j</Math>
  &gt; <Math>i</Math> with zero. The differentials affected will also
  become zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="BrutalTruncation" Arg="C,i,j" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i, j</Arg> -- integers.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Brutally truncates in both ends. The integer arguments
  must be ordered such that <Arg>i</Arg> &gt; <Arg>j</Arg>.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="SyzygyTruncation" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace the object in degree <Math>i</Math> with the
  kernel of <Math>d_i</Math>, and <M>d_{i+1}</M> with the natural
  inclusion. All objects in degree <M>j &gt; i+1</M> are replaced with
  zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="CosyzygyTruncation" Arg="C,i" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Replace the object in degree <Math>i-2</Math> with the
  cokernel of <Math>d_i</Math>, and <M>d_{i-1}</M> with the natural
  projection. All objects in degree <M>j &lt; i-2</M> are replaced with
  zero.
  </Description>
</ManSection>

<ManSection>
  <Oper Name="SyzygyCosyzygyTruncation" Arg="C,i,j" />
  <Description>
    Arguments: <Arg>C</Arg> -- a complex, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>A newly created complex.
  </Returns>
  <Description>Performs both the above truncations. The integer
  arguments must be ordered such that <Arg>i</Arg> &gt; <Arg>j</Arg>.
  </Description>
</ManSection>



</Section>


<Section>
<Heading>Chain maps</Heading>

An <Ref Filt="IsChainMap"/> object represents a chain map between two
complexes over the same category.

<ManSection>
<Filt Type="Category" Name="IsChainMap"/>
<Description>
The category for chain maps.
</Description>
</ManSection>

<ManSection>
<Func Name="ChainMap"
      Arg="source, range, basePosition, middle, positive, negative"/>
  <Description>
    Arguments:
    <Arg>source</Arg>, <Arg>range</Arg> -- complexes,
    <Arg>basePosition</Arg> -- an integer,
    <Arg>middle</Arg> -- a list of morphisms,
    <Arg>positive</Arg> -- a list or the string <Code>"zero"</Code>,
    <Arg>negative</Arg> -- a list or the string <Code>"zero"</Code>.
    <Br />
  </Description>
<Returns>A newly created chain map</Returns>
<Description>
The arguments <Arg>source</Arg> and <Arg>range</Arg> are the complexes
which the new chain map should map between.<P/>

The rest of the arguments describe the individual morphisms which
constitute the chain map, in a similar way to the last four arguments
to the <Ref Func="Complex"/> function.<P/>

The morphisms of the chain map are divided into three parts: one
finite (<Q>middle</Q>) and two infinite (<Q>positive</Q>
and <Q>negative</Q>).  The positive part contains all morphisms in
degrees higher than those in the middle part, and the negative part
contains all morphisms in degrees lower than those in the middle
part.  (The middle part may be placed anywhere, so the positive part
can -- despite its name -- contain some morphisms of negative
degree.  Conversely, the negative part can contain some morphisms
of positive degree.)<P/>

The argument <Arg>middle</Arg> is a list containing the morphisms
for the middle part.  The argument <Arg>baseDegree</Arg> gives the
degree of the first morphism in this list.  The second
morphism is placed in degree <M><Arg>baseDegree</Arg>+1</M>, and
so on.  Thus, the middle part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>) - 1.
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the morphisms in <Code>L</Code> repeated infinitely many times.  The
  convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the morphism which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.  (Using this only makes sense if the objects of both
  the source and range complex repeat in a compatible way.)</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the morphisms in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>ChainMap</Code> constructor, but will be called later as
  the morphisms in this part are needed.  The function
  call <Code>f(M,i)</Code> (where <Code>M</Code> is the chain map
  and <Code>i</Code> an integer) should produce the morphism in
  degree <Code>i</Code>.  The function may use <Code>M</Code> to look
  up other morphisms in the chain map (and to access the source and
  range complexes), as long as this does not cause an infinite loop.
  If <Code>store</Code> is <Code>true</Code> (or not specified), each
  computed morphism is stored, and they are computed in order from the
  one closest to the middle part, regardless of which order they are
  requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the morphisms in this part.  For the first
  morphism in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next morphism, <Code>f</Code> is called with
  the first morphism as argument, and so on.  Thus, the
  morphisms are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each morphism is stored when it has been computed.
</Item>
</List>
</Description>
</ManSection>

<ManSection>
<Func Name="ZeroChainMap" Arg="source, range"/>
<Returns>A newly created zero chain map</Returns>
<Description>
This function creates a zero chain map (a chain map in which every
morphism is zero) from the complex <Arg>source</Arg> to the
complex <Arg>range</Arg>.<P/>

(TODO: this function is not implemented.)
</Description>
</ManSection>

<ManSection>
<Func Name="FiniteChainMap" Arg="source, range, baseDegree, morphisms"/>
<Returns>A newly created chain map</Returns>
<Description>
This function creates a complex where all but finitely many morphisms
are zero.<P/>

The arguments <Arg>source</Arg> and <Arg>range</Arg> are the complexes
which the new chain map should map between.<P/>

The argument <Arg>morphisms</Arg> is a list of morphisms.  The
argument <Arg>baseDegree</Arg> gives the degree for the first morphism
in this list.  The subsequent morphisms are placed in
degrees <M><Arg>baseDegree</Arg>+1</M>, and so on.<P/>

This means that the <Arg>morphisms</Arg> argument specifies the
morphisms in degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots \quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>morphisms</Arg>) - 1.
</Display>
All other morphisms in the chain map are zero.<P/>

(TODO: this function is not implemented.)
</Description>
</ManSection>

<ManSection>
<Func Name="ComplexAndChainMaps"
      Arg="sourceComplexes, rangeComplexes, basePosition, middle, positive, negative"/>
  <Description>
    Arguments:
    <Arg>sourceComplexes</Arg> -- a list of complexes,
    <Arg>rangeComplexes</Arg> -- a list of complexes,
    <Arg>basePosition</Arg> -- an integer,
    <Arg>middle</Arg> -- a list of morphisms,
    <Arg>positive</Arg> -- a list or the string <Code>"zero"</Code>,
    <Arg>negative</Arg> -- a list or the string <Code>"zero"</Code>.
    <Br />
  </Description>
<Returns>A list consisting of a newly created complex, and one or
  more newly created chain maps.</Returns>
<Description>
This is a combined constructor to make one complex and a set of chain
maps at the same time.  All the chain maps will have the new complex
as either source or range.<P/>

The argument <Arg>sourceComplexes</Arg> is a list of the complexes
to be sources of the chain maps which have the new complex as range.
The argument <Arg>rangeComplexes</Arg> is a list of the complexes
to be ranges of the chain maps which have the new complex as source.<P/>

Let <M>S</M> and <M>R</M> stand for the lengths of the
lists <Arg>sourceComplexes</Arg> and <Arg>rangeComplexes</Arg>,
respectively.  Then the number of new chain maps which are created
is <M>S+R</M>.<P/>

The last four arguments describe the individual differentials of the
new complex, as well as the inidividual morphisms which constitute
each of the new chain maps.  These arguments are treated in a similar
way to the last four arguments to the <Ref Func="Complex"/> and
<Ref Func="ChainMap"/> constructors.  In those constructors, the last
four arguments describe, for each degree, how to get the differential
or morphism for that degree.  Here, we for each degree need both a
differential for the complex, and one morphism for each chain map.  So
for each degree <M>i</M>, we will have a list
<Display>
L_i =
[ d_i,
  m_i^1, \ldots, m_i^S,
  n_i^1, \ldots, n_i^R ],
</Display>
where <M>d_i</M> is the differential for the new complex in
degree <M>i</M>, <M>m_i^j</M> is the morphism in degree <M>i</M> of
the chain map from <Code>sourceComplexes[j]</Code> to the new complex,
and <M>n_i^j</M> is the morphism in degree <M>i</M> of the chain map
from the new complex to <Code>rangeComplexes[j]</Code>.<P/>

The degrees of the new complex and chain maps are divided into three
parts: one finite (<Q>middle</Q>) and two infinite (<Q>positive</Q>
and <Q>negative</Q>).  The positive part contains all degrees higher
than those in the middle part, and the negative part contains all
degrees lower than those in the middle part.<P/>

The argument <Arg>middle</Arg> is a list containing the
lists <M>L_i</M> for the middle part.  The
argument <Arg>baseDegree</Arg> gives the degree of the first morphism
in this list.  The second morphism is placed in
degree <M><Arg>baseDegree</Arg>+1</M>, and so on.  Thus, the middle
part consists of the degrees
<Display>
<Arg>baseDegree</Arg>,\quad
<Arg>baseDegree</Arg> + 1,\quad
\ldots\quad
<Arg>baseDegree</Arg> + \text{Length}(<Arg>middle</Arg>) - 1.
</Display>

Each of the arguments <Arg>positive</Arg> and <Arg>negative</Arg> can
be one of the following:
<List>
<Item>The string <Code>"zero"</Code>, meaning that the part contains
  only zero morphisms.</Item>
<Item>A list of the form <Code>[ "repeat", L ]</Code>,
  where <Code>L</Code> is a list of morphisms.  The part will contain
  the morphisms in <Code>L</Code> repeated infinitely many times.  The
  convention for the order of elements in <Code>L</Code> is
  that <Code>L[1]</Code> is the morphism which is closest to the
  middle part, and <Code>L[Length(L)]</Code> is farthest away from the
  middle part.  (Using this only makes sense if the objects of both
  the source and range complex repeat in a compatible way.)</Item>
<Item>A list of the form <Code>[ "pos", f ]</Code> or <Code>[ "pos",
  f, store ]</Code>, where <Code>f</Code> is a function of two
  arguments, and <Code>store</Code> (if included) is a boolean.  The
  function <Code>f</Code> is used to compute the morphisms in this
  part.  The function <Code>f</Code> is not called immediately by
  the <Code>ChainMap</Code> constructor, but will be called later as
  the morphisms in this part are needed.  The function
  call <Code>f(M,i)</Code> (where <Code>M</Code> is the chain map
  and <Code>i</Code> an integer) should produce the morphism in
  degree <Code>i</Code>.  The function may use <Code>M</Code> to look
  up other morphisms in the chain map (and to access the source and
  range complexes), as long as this does not cause an infinite loop.
  If <Code>store</Code> is <Code>true</Code> (or not specified), each
  computed morphism is stored, and they are computed in order from the
  one closest to the middle part, regardless of which order they are
  requested in.</Item>
<Item>A list of the form <Code>[ "next", f, init ]</Code>,
  where <Code>f</Code> is a function of one argument,
  and <Code>init</Code> is a morphism.  The function <Code>f</Code> is
  used to compute the morphisms in this part.  For the first
  morphism in the part (that is, the one closest to the middle
  part), <Code>f</Code> is called with <Code>init</Code> as
  argument.  For the next morphism, <Code>f</Code> is called with
  the first morphism as argument, and so on.  Thus, the
  morphisms are
  <Display>
    f(\text{init}),\quad
    f^2(\text{init}),\quad
    f^3(\text{init}),\quad \ldots
  </Display>
  Each morphism is stored when it has been computed.
</Item>
</List>

The return value of the <Code>ComplexAndChainMaps</Code> constructor
is a list
<Display>
[ C,
  M_1, \ldots, M_S,
  N_1, \ldots, N_R ],
</Display>
where <M>C</M> is the new complex, <M>M_1,\ldots,M_S</M> are the new
chain maps with <M>C</M> as range, and <M>N_1,\ldots,N_R</M> are the
new chain maps with <M>C</M> as source.
</Description>
</ManSection>

<ManSection>
  <Oper Name="MorphismOfChainMap" Arg="M, i" />
  <Description>
    Arguments: <Arg>M</Arg> -- a chain map, <Arg>i</Arg> -- an integer.<Br />
  </Description>
  <Returns>
    The morphism at position <Arg>i</Arg> in the chain map.
  </Returns>
  <Description>
  </Description>
</ManSection>

<ManSection>
  <Attr Name="MorphismsOfChainMap" Arg="M" />
  <Description>
    Arguments: <Arg>M</Arg> -- a chain map<Br />
  </Description>
  <Returns>
    The morphisms of the chain map, stored as an <Ref Filt="IsInfList"/>
    object.
  </Returns>
</ManSection>


</Section>

</Chapter>
