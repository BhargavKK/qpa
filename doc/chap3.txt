  
  [1X3 Path Algebras[0X
  
  
  [1X3.1 Introduction[0X
  
  A  path algebra is an algebra constructed from a field $F$ and a quiver $Q$.
  The path algebra $FQ$ contains all finite linear combinations of elements of
  $Q$.  This  chapter  describes  the  functions  in  [5XQPA[0m  that deal with path
  algebras  and  quotients of path algebras. Path algebras are algebras so see
  Chapter   "ref:algebras"   for   functionality  such  as  generators,  basis
  functions, and mappings.
  
  [1X3.1-1 InfoPathAlgebra[0m
  
  [2X> InfoPathAlgebra_________________________________________________[0Xinfo class
  
  is the info class for functions dealing with path algebras.
  
  
  [1X3.2 Constructing Path Algebras[0X
  
  [1X3.2-1 PathAlgebra[0m
  
  [2X> PathAlgebra( [0X[3XF, Q[0X[2X ) ______________________________________________[0Xfunction
  [6XReturns:[0X  the path algebra $FG$ of [3XQ[0m over the field [3XF[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],[0X
    [4X> ["v","u","c"],["v","v","d"]]);[0X
    [4X<quiver with 2 vertices and 4 arrows>[0X
    [4Xgap> f := FiniteField(23);[0X
    [4XGF(23)[0X
    [4Xgap> fq := PathAlgebra(f,q);[0X
    [4X<algebra-with-one over GF(23), with 6 generators>[0X
  [4X------------------------------------------------------------------[0X
  
  \* NO: the FOLLOWING is not true:
  
  [1X3.2-2 OrderedBy[0m
  
  [2X> OrderedBy( [0X[3Xpath, algebra, ordering[0X[2X ) _____________________________[0Xfunction
  [6XReturns:[0X  a copy of [3Xpath algebra[0m whose elements are ordered by [3Xordering[0m. See
            Section [14X2.4[0m for more information on orderings.
  
  
  [1X3.3 Categories and Properties of Path Algebras[0X
  
  [1X3.3-1 IsPathAlgebra[0m
  
  [2X> IsPathAlgebra( [0X[3Xobject[0X[2X ) __________________________________________[0Xproperty
  
  is true when [3Xobject[0m is a path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsPathAlgebra(fq);[0X
    [4Xtrue[0X
    [4Xgap> IsPathAlgebra(q);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.4 Attributes and Operations for Path Algebras[0X
  
  [1X3.4-1 QuiverOfPathAlgebra[0m
  
  [2X> QuiverOfPathAlgebra( [0X[3Xobject[0X[2X ) ___________________________________[0Xattribute
  
  An attribute. Returns the quiver from which [3Xobject[0m was constructed.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> QuiverOfPathAlgebra(fq);[0X
    [4X<quiver with 2 vertices and 4 arrows>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-2 .[0m
  
  [2X> .( [0X[3XFQ, element[0X[2X ) ________________________________________________[0Xoperation
  
  The  operation [2X.[0m operates on a path algebra [3XFQ[0m and an element [3Xelement[0m, which
  is  a  vertex  or  an  arrow in the quiver Q. It returns the generator as an
  element of the path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> fq.v;[0X
    [4X(Z(23)^0)*v[0X
    [4Xgap> fq.b;[0X
    [4X(Z(23)^0)*b[0X
  [4X------------------------------------------------------------------[0X
  
  >OrderingOfAlgebra( [3Xpath algebra[0m ) returns the ordering of the quiver of the
  path algebra.
  
  
  [1X3.5 Operations on Path Algebra Elements[0X
  
  [1X3.5-1 <[0m
  
  [2X> <( [0X[3Xa, b[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X<[0m  operates  on elements [3Xa[0m and [3Xb[0m of a path algebra $FQ$, and
  they  are  compared using the ordering for the path algebra. See Section [14X2.4[0m
  for more information on orderings.
  
  [1X3.5-2 LeadingTerm[0m
  
  [2X> LeadingTerm( [0X[3Xelement[0X[2X ) __________________________________________[0Xoperation
  [2X> Tip( [0X[3Xelement[0X[2X ) __________________________________________________[0Xoperation
  
  The  operation  [2XLeadingTerm[0m  or  equivalently [2XTip[0m operates on an [3Xx[0m in a path
  algebra,  and  it  returns  is the term in [3Xelement[0m whose monomial is largest
  among  those monomials that have nonzero coefficients; this term is known as
  the *tip* of [3Xelement[0m.
  
  [1X3.5-3 LeadingCoefficient[0m
  
  [2X> LeadingCoefficient( [0X[3Xelement[0X[2X ) ___________________________________[0Xoperation
  [2X> TipCoefficient( [0X[3Xelement[0X[2X ) _______________________________________[0Xoperation
  
  The  operation [2XLeadingCoefficient[0m or equivalently [2XTipCoefficient[0m operates on
  an  [3Xelement[0m  in a path algebra, and it returns the coefficient of the tip of
  [3Xelement[0m. This is an element of the field.
  
  [1X3.5-4 LeadingMonomial[0m
  
  [2X> LeadingMonomial( [0X[3Xelement[0X[2X ) ______________________________________[0Xoperation
  [2X> TipMonomial( [0X[3Xelement[0X[2X ) __________________________________________[0Xoperation
  
  The  operation  [2XLeadingMonomial[0m  or  equivalently [2XTipMonomial[0m operates on an
  [3Xelement[0m  in  a  path  algebra,  and  it  returns  the monomial of the tip of
  [3Xelement[0m;  it  is  the  largest  monomial occurring in [3Xelement[0m with a nonzero
  coefficient.  This  is  an element of the underlying quiver, not of the path
  algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> elem := fq.a*fq.b*fq.c + fq.b*fq.d*fq.c+fq.d*fq.d;[0X
    [4X(Z(23)^0)*d^2+(Z(23)^0)*a*b*c+(Z(23)^0)*b*d*c[0X
    [4Xgap> LeadingTerm(elem);[0X
    [4X(Z(23)^0)*b*d*c[0X
    [4Xgap> LeadingCoefficient(elem);[0X
    [4XZ(23)^0[0X
    [4Xgap> LeadingMonomial(elem);[0X
    [4Xb*d*c[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-5 IsLeftUniform[0m
  
  [2X> IsLeftUniform( [0X[3Xelement[0X[2X ) ________________________________________[0Xoperation
  
  The operation [2XIsLeftUniform[0m operates on an [3Xelement[0m in a path algebra, and it
  returns true if each monomial in [3Xelement[0m has the same source vertex.
  
  [1X3.5-6 IsRightUniform[0m
  
  [2X> IsRightUniform( [0X[3Xelement[0X[2X ) _______________________________________[0Xoperation
  
  The  operation  [2XIsRightUniform[0m operates on an [3Xelement[0m in a path algebra, and
  it returns true if each monomial in [3Xelement[0m has the same target vertex.
  
  [1X3.5-7 IsUniform[0m
  
  [2X> IsUniform( [0X[3Xelement[0X[2X ) ____________________________________________[0Xoperation
  
  The  operation  [2XIsUniform[0m  operates  on an [3Xelement[0m in a path algebra, and it
  returns true if each monomial in [3Xelement[0m has both the same source vertex and
  the same target vertex.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsLeftUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> IsRightUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> IsUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> another := fq.a*fq.b + fq.b*fq.d*fq.c*fq.b*fq.d;[0X
    [4X(Z(23)^0)*a*b+(Z(23)^0)*b*d*c*b*d[0X
    [4Xgap> IsLeftUniform(another);[0X
    [4Xtrue[0X
    [4Xgap> IsRightUniform(another);[0X
    [4Xtrue[0X
    [4Xgap> IsUniform(another);[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-8 MappedExpression[0m
  
  [2X> MappedExpression( [0X[3Xexpr, gens1, gens2[0X[2X ) __________________________[0Xoperation
  
  The  operation [2XMappedExpression[0m operates on [3Xexpr[0m from a path algebra and and
  two  equal-length  lists  of generators [3Xgens1[0m and [3Xgens2[0m for subalgebras. The
  [3Xexpr[0m  must  be  in  the  subalgebra  generated  by [3Xgens1[0m. The lists define a
  mapping  of each generator in [3Xgens1[0m to the corresponding generator in [3Xgens2[0m.
  The value returned is the evaluation of the mapping at [3Xexpr[0m.
  
  
  [1X3.6 Constructing Quotients of Path Algebras[0X
  
  See Chapter "ref:algebras" on how to construct an ideal and a quotient of an
  algebra.  When  the  quotient is constructed, it is still a path algebra and
  thus  the same commands may be used with quotients. Also since a quotient is
  still an algebra, refer to "ref:algebras".
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);[0X
    [4X<two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,[0X
    [4X  (2 generators)>[0X
    [4Xgap> GeneratorsOfIdeal(I);[0X
    [4X[ (Z(23)^0)*a*b, (Z(23)^11)*b*c+(Z(23)^0)*d^2 ][0X
    [4Xgap> quot := fq/I;[0X
    [4X<algebra-with-one over GF(23), with 6 generators>[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.7 Attributes of Ideals[0X
  
  Groebner  Basis Of an Ideal: For many of the functions related to quotients,
  you  will  need  to  compute  a  Groebner  basis  of the ideal. Refer to the
  chapters "qpa:groebner basis" and "qpa:using opal with gap" to learn more.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> J := Ideal(fq,[fq.a*fq.b]);[0X
    [4X<two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,[0X
    [4X  (1 generators)>[0X
    [4Xgap> anotherquot := fq/J;[0X
    [4X<algebra-with-one over GF(23), with 6 generators>[0X
    [4Xgap> gb := GroebnerBasis(J,[fq.a*fq.b]);[0X
    [4X<complete two-sided Groebner basis containing 1 elements>[0X
    [4Xgap> SetIsCompleteGroebnerBasis(gb, true);[0X
    [4Xgap> IsCompleteGroebnerBasis(gb);[0X
    [4Xtrue[0X
    [4Xgap> gb = GroebnerBasisOfIdeal(J);[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.8 Categories and Properties of Quotients of Path Algebras[0X
  
  [1X3.8-1 IsSubalgebraFpPathAlgebra[0m
  
  [2X> IsSubalgebraFpPathAlgebra( [0X[3Xobject[0X[2X ) ______________________________[0Xproperty
  
  is true when [3Xobject[0m is a quotient of a path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsSubalgebraFpPathAlgebra(quot);[0X
    [4Xtrue[0X
    [4Xgap> IsSubalgebraFpPathAlgebra(fq);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.9 Attributes and Operations for Quotients of Path Algebras[0X
  
  [1X3.9-1 NormalFormFunction[0m
  
  [2X> NormalFormFunction( [0X[3Xobject[0X[2X ) ____________________________________[0Xattribute
  
  is  a  function that can compute normal forms for elements of [3Xobject[0m. It may
  be supplied by the user.
  
  [1X3.9-2 IsElementOfFpPathAlgebra[0m
  
  [2X> IsElementOfFpPathAlgebra( [0X[3Xobject[0X[2X ) _______________________________[0Xproperty
  
  is true if [3Xobject[0m is an element of some quotient of a path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> this := anotherquot.a*anotherquot.b;[0X
    [4X[(Z(23)^0)*a*b][0X
    [4Xgap> IsElementOfFpPathAlgebra(this);[0X
    [4Xtrue[0X
    [4Xgap> IsElementOfFpPathAlgebra(fq);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.9-3 Coefficients[0m
  
  [2X> Coefficients( [0X[3Xelement[0X[2X ) _________________________________________[0Xoperation
  
  The  operation  [2XCoefficients[0m  operates on an [3Xelement[0m of a quotient of a path
  algebra,  and  it  returns  the  coefficients of the [3Xelement[0m in terms of its
  canonical basis. Question: Does this only take one argument?
  
  [1X3.9-4 IsSelfinjective[0m
  
  [2X> IsSelfinjective( [0X[3XA[0X[2X ) ____________________________________________[0Xoperation
  
  The  function checks if the algebra [3XA[0m is finite dimensional (not implemented
  yet),  and  returns  true or false accorgin to whether [3XA[0m is selfinjective or
  not.
  
  [1X3.9-5 LoewyLength[0m
  
  [2X> LoewyLength( [0X[3XA[0X[2X ) ________________________________________________[0Xoperation
  
  The function returns the Loewy length of the algebra [3XA[0m, after having checked
  that [3XA[0m is a finite dimensional quotient of a path algebra.
  
  [1X3.9-6 CartanMatrix[0m
  
  [2X> CartanMatrix( [0X[3XA[0X[2X ) _______________________________________________[0Xoperation
  
  This  function  returns  the  Cartan  matrix  of the algebra [3XA[0m, after having
  checked that [3XA[0m is a finite dimensional quotient of a path algebra.
  
  [1X3.9-7 CoxeterMatrix[0m
  
  [2X> CoxeterMatrix( [0X[3XA[0X[2X ) ______________________________________________[0Xoperation
  
  This  function  returns  the  Coxeter  matrix of the algebra [3XA[0m, after having
  checked that [3XA[0m is a finite dimensional quotient of a path algebra.
  
  [1X3.9-8 CoxeterPolynomial[0m
  
  [2X> CoxeterPolynomial( [0X[3XA[0X[2X ) __________________________________________[0Xoperation
  
  This  function returns the Coxeter polynomial of the algebra [3XA[0m, after having
  checked that [3XA[0m is a finite dimensional quotient of a path algebra.
  
  [1X3.9-9 Centre/Center[0m
  
  [2X> Centre/Center( [0X[3XA[0X[2X ) ______________________________________________[0Xoperation
  
  This function returns the centre of the algebra [3XA[0m, after having checked that
  [3XA[0m  is  a  finite  dimensional  quotient  of a path algebra (the check is not
  implemented and also not implemented for path algebras).
  
  
  [1X3.10 Attributes and Operations on Elements of Quotients of Path Algebra[0X
  
  [1X3.10-1 IsNormalForm[0m
  
  [2X> IsNormalForm( [0X[3Xelement[0X[2X ) _________________________________________[0Xoperation
  
  The  operation  [2XIsNormalForm[0m operates on an [3Xelement[0m from a path algebra, and
  it is true if [3Xelement[0m is known to be in normal form.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsNormalForm(this); [0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.10-2 <[0m
  
  [2X> <( [0X[3Xa, b[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X<[0m operates on two elements [3Xa[0m and [3Xb[0m from a path algebra $FQ$,
  and it compares them using the ordering for the path algebra.
  
  [1X3.10-3 ElementOfFpPathAlgebra[0m
  
  [2X> ElementOfFpPathAlgebra( [0X[3Xfamily, element, computenormal[0X[2X ) ________[0Xoperation
  
  The  operation  [2XElementOfFpPathAlgebra[0m  operates  on  an  [3Xelement[0m  in a path
  algebra,  and  it  projects  it  into  the  quotient  given  by  [3Xfamily[0m.  If
  [3Xcomputenormal[0m  is true, then the normal form of the projection of [3Xelement[0m is
  returned.
  
  [1X3.10-4 OriginalPathAlgebra[0m
  
  [2X> OriginalPathAlgebra( [0X[3Xalgebra[0X[2X ) __________________________________[0Xoperation
  
  The  operation  [2XOriginalPathAlgebra[0m  operates  on  an  [3Xalgebra[0m.  If  it is a
  quotient  of  a  path  algebra or just a path algebra itself, it returns the
  path  algebra  it was constructed from. Otherwise it returns an error saying
  that the algebra entered was not a quotient of a path algebra.
  
  
  [1X3.11 Predefined classes of quotient of path algebras[0X
  
  [1X3.11-1 NakayamaAlgebra[0m
  
  [2X> NakayamaAlgebra( [0X[3Xadmiss-seq, field[0X[2X ) _____________________________[0Xfunction
  [6XReturns:[0X  the  Nakayama  algebra  corresponding  to the addmissible sequence
            [3Xadmiss-seq[0m  over  the  field  [3Xfield[0m,  or  [9Xthe  admissible sequence
            entered[0m if entered sequence is not an admissible sequence.
  
  This  function creates a Nakayama algebra from an admissible sequence over a
  field.
  
  
  [1X3.12 Tensor products of path algebras[0X
  
  If  Lambda  and  Gamma are quotients of path algebras over the same field F,
  then their tensor product Lambda tensor_F Gamma is also a quotient of a path
  algebra over F.
  
  The quiver for the tensor product path algebra is the [2XQuiverProduct[0m ([14X3.12-1[0m)
  of the quivers of the original algebras.
  
  The  operation [2XTensorProductOfAlgebras[0m ([14X3.12-6[0m) computes the tensor products
  of two quotients of path algebras as a quotient of a path algebra.
  
  [1X3.12-1 QuiverProduct[0m
  
  [2X> QuiverProduct( [0X[3XQ1, Q2[0X[2X ) _________________________________________[0Xoperation
  
  Creates the product quiver [3XQ1[0m quiverproduct [3XQ2[0m. A vertex in [3XQ1[0m quiverproduct
  [3XQ2[0m  which  is made by combining a vertex named [10Xu[0m in [3XQ1[0m with a vertex [10Xv[0m in [3XQ2[0m
  is  named  [10Xu_v[0m.  Arrows  are  named similarly (they are made by combining an
  arrow from one quiver with a vertex from the other).
  
  [1X3.12-2 QuiverProductDecomposition[0m
  
  [2X> QuiverProductDecomposition( [0X[3XQ[0X[2X ) _________________________________[0Xattribute
  
  Contains  the  original  quivers  [3XQ[0m is a product of, if [3XQ[0m was created by the
  [2XQuiverProduct[0m  ([14X3.12-1[0m)  operation. The value of this attribute is an object
  in the category [2XIsQuiverProductDecomposition[0m ([14X3.12-3[0m).
  
  [1X3.12-3 IsQuiverProductDecomposition[0m
  
  [2X> IsQuiverProductDecomposition________________________________________[0Xfilter
  
  Category  for  objects  containing  information about the relation between a
  product quiver and the quivers it is a product of. The quiver factors can be
  extracted  from  the  decomposition  object  by  using the [] notation (like
  accessing  elements of a list). The decomposition object is also used by the
  operations   [2XIncludeInProductQuiver[0m  ([14X3.12-4[0m)  and  [2XProjectFromProductQuiver[0m
  ([14X3.12-5[0m).
  
  [1X3.12-4 IncludeInProductQuiver[0m
  
  [2X> IncludeInProductQuiver( [0X[3XL, Q[0X[2X ) __________________________________[0Xoperation
  
  Includes  paths  q_1  and  q_2  from  two  quivers into the product of these
  quivers.  If  at  least one of q_1 and q_2 is a vertex, there is exactly one
  possible  inclusion.  If  they are both non-trivial paths, there are several
  possibilities.  This operation constructs the path which is the inclusion of
  q_1  at the source of q_2 multiplied with the inclusion of q_2 at the target
  of q_1.
  
  The  argument [3XL[0m is a list containing the paths q_1 and q_2 to be included; Q
  is the product quiver to include them in.
  
  [1X3.12-5 ProjectFromProductQuiver[0m
  
  [2X> ProjectFromProductQuiver( [0X[3Xi, p[0X[2X ) ________________________________[0Xoperation
  
  Returns  the  projection of the product quiver path [3Xp[0m to one of the factors.
  Which factor it should be projected to is specified by the argument [3Xi[0m.
  
  The  following  example  shows how the operations related to quiver products
  are used.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q2 := Quiver( [ "v1", "v2", "v3" ],[0X
    [4X                      [ [ "v1", "v2", "b" ],[0X
    [4X                        [ "v2", "v3", "c" ] ] );[0X
    [4X<quiver with 3 vertices and 2 arrows>[0X
    [4Xgap> q1_q2 := QuiverProduct( q1, q2 );[0X
    [4X<quiver with 6 vertices and 7 arrows>[0X
    [4Xgap> q1_q2.u1_b * q1_q2.a_v2;[0X
    [4Xu1_b*a_v2[0X
    [4Xgap> IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );[0X
    [4Xa_v1*u2_b*u2_c[0X
    [4Xgap> ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );[0X
    [4Xb*c[0X
    [4Xgap> q1_q2_dec := QuiverProductDecomposition( q1_q2 );[0X
    [4X<object>[0X
    [4Xgap> q1_q2_dec[ 1 ];[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q1_q2_dec[ 1 ] = q1;[0X
    [4Xtrue[0X
    [4X  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.12-6 TensorProductOfAlgebras[0m
  
  [2X> TensorProductOfAlgebras( [0X[3XFQ1, FQ2[0X[2X ) _____________________________[0Xoperation
  
  The  operation  [2XTensorProductOfAlgebras[0m  produces  the tensor product of two
  (quotients of) path algebras [3XFQ1[0m and [3XFQ2[0m. The result is a quotient of a path
  algebra,  whose  quiver  is the [2XQuiverProduct[0m ([14X3.12-1[0m) of the quivers of the
  operands.
  
  [1X3.12-7 SimpleTensor[0m
  
  [2X> SimpleTensor( [0X[3XL, T[0X[2X ) ____________________________________________[0Xoperation
  
  The operation [2XSimpleTensor[0m produces a simple tensor x tensor y in the tensor
  product  of  two  path  algebras.  The  argument  [3XL[0m is a list containing the
  elements  x  and  y.  These  should  be  elements of two (quotients of) path
  algebras,   and  [3XT[0m  the  tensor  product  of  these  algebras  (produced  by
  [2XTensorProductOfAlgebras[0m ([14X3.12-6[0m)).
  
  [1X3.12-8 TensorProductDecomposition[0m
  
  [2X> TensorProductDecomposition( [0X[3XT[0X[2X ) _________________________________[0Xattribute
  
  For   a   tensor   product  of  quotients  of  path  algebras  (produced  by
  [2XTensorProductOfAlgebras[0m  ([14X3.12-6[0m)),  this  attribute  contains a list of the
  factors in the tensor product.
  
  The  following  example  shows  how  the  operations  for tensor products of
  quotients of path algebras are used.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q2 := Quiver( [ "v1", "v2", "v3", "v4" ],[0X
    [4X                      [ [ "v1", "v2", "b" ],[0X
    [4X                        [ "v1", "v3", "c" ],[0X
    [4X                        [ "v2", "v4", "d" ],[0X
    [4X                        [ "v3", "v4", "e" ] ] );[0X
    [4X<quiver with 4 vertices and 4 arrows>[0X
    [4Xgap> fq1 := PathAlgebra( Rationals, q1 );[0X
    [4X<algebra-with-one over Rationals, with 3 generators>[0X
    [4Xgap> fq2 := PathAlgebra( Rationals, q2 );[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );[0X
    [4X<two-sided ideal in <algebra-with-one over Rationals, with 8 generators>,[0X
    [4X (1 generators)>[0X
    [4Xgap> quot := fq2 / I;[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> t := TensorProductOfAlgebras( fq1, quot );[0X
    [4X<algebra-with-one over Rationals, with 20 generators>[0X
    [4Xgap> SimpleTensor( [ fq1.a, quot.b ], t );[0X
    [4X[(1)*a_v1*u2_b][0X
    [4Xgap> t_dec := TensorProductDecomposition( t );[0X
    [4X[ <algebra-with-one over Rationals, with 3 generators>, [0X
    [4X  <algebra-with-one over Rationals, with 8 generators> ][0X
    [4Xgap> t_dec[ 1 ] = fq1;[0X
    [4Xtrue[0X
    [4X  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.12-9 EnvelopingAlgebra[0m
  
  [2X> EnvelopingAlgebra( [0X[3XFQ[0X[2X ) _________________________________________[0Xoperation
  
  Produces  the  enveloping algebra [3XFQ[0m^e = [3XFQ[0m tensor [3XFQ[0m^op of [3XFQ[0m, which should
  be (a quotient of) a path algebra.
  
  [1X3.12-10 IsEnvelopingAlgebra[0m
  
  [2X> IsEnvelopingAlgebra( [0X[3XA[0X[2X ) ________________________________________[0Xattribute
  
  True if and only if [3XA[0m is the result of a call to [2XEnvelopingAlgebra[0m ([14X3.12-9[0m).
  
