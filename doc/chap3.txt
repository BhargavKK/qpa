  
  [1X3 Path Algebras[0X
  
  
  [1X3.1 Introduction[0X
  
  A  path  algebra  is an algebra constructed from a field $F$ (see chapter 56
  and 57 in the [5XGAP[0m manual for information about fields) and a quiver $Q$. The
  path  algebra  $FQ$ contains all finite linear combinations of paths of $Q$.
  This chapter describes the functions in [5XQPA[0m that deal with path algebras and
  quotients  of  path algebras. Path algebras are algebras, so see chapter 60:
  Algebras  in  the  [5XGAP[0m  manual  for  functionality such as generators, basis
  functions, and mappings.
  
  
  [1X3.2 Constructing Path Algebras[0X
  
  [1X3.2-1 PathAlgebra[0m
  
  [2X> PathAlgebra( [0X[3XF, Q[0X[2X ) ______________________________________________[0Xfunction
  
  Arguments: F -- a field, Q -- a quiver.
  
  [6XReturns:[0X  the path algebra $FQ$ of [3XQ[0m over the field [3XF[0m.
  
  For  construction  of fields, see the [5XGAP[0m documentation. The elements of the
  path algebra $FQ$ will be ordered by left length-lexicographic ordering.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q := Quiver( ["u","v"] , [ ["u","u","a"], ["u","v","b"],[0X
    [4X>["v","u","c"], ["v","v","d"] ] );[0X
    [4X<quiver with 2 vertices and 4 arrows>[0X
    [4Xgap> F := Rationals;[0X
    [4XRationals[0X
    [4Xgap> FQ := PathAlgebra(F,Q);[0X
    [4X<algebra-with-one over Rationals, with 5 generators> [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.3 Categories and Properties of Path Algebras[0X
  
  [1X3.3-1 IsPathAlgebra[0m
  
  [2X> IsPathAlgebra( [0X[3Xobject[0X[2X ) __________________________________________[0Xproperty
  
  Arguments: [3Xobject[0m -- any object in [5XGAP[0m.
  
  [6XReturns:[0X  true whenever [3Xobject[0m is a path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsPathAlgebra(FQ);[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.4 Attributes and Operations for Path Algebras[0X
  
  [1X3.4-1 QuiverOfPathAlgebra[0m
  
  [2X> QuiverOfPathAlgebra( [0X[3XFQ[0X[2X ) _______________________________________[0Xattribute
  
  Arguments: [3XFQ[0m -- a path algebra.
  
  [6XReturns:[0X  the quiver from which [3XFQ[0m was constructed.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> QuiverOfPathAlgebra(FQ);[0X
    [4X<quiver with 2 vertices and 4 arrows> [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.4-2 OrderingOfAlgebra[0m
  
  [2X> OrderingOfAlgebra( [0X[3XFQ[0X[2X ) _________________________________________[0Xattribute
  
  Arguments: [3XFQ[0m -- a path algebra.
  
  [6XReturns:[0X  the ordering of the quiver of the path algebra.
  
  [13XNote:[0m  As  of  the  current  version  of [5XQPA[0m, only left length lexicographic
  ordering is supported.
  
  [1X3.4-3 .[0m
  
  [2X> .( [0X[3XFQ, generator[0X[2X ) ______________________________________________[0Xoperation
  
  Arguments:  [3XFQ[0m  --  a path algebra, [3Xgenerator[0m -- a vertex or an arrow in the
  quiver [3XQ[0m.
  
  [6XReturns:[0X  the [3Xgenerator[0m as an element of the path algebra.
  
  Other elements of the path algebra can be constructed as linear combinations
  of the generators. For further operations on elements, see below.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> FQ.a;[0X
    [4X(1)*a[0X
    [4Xgap> FQ.v;[0X
    [4X(1)*v[0X
    [4Xgap> elem := 2*FQ.a - 3*FQ.v;[0X
    [4X(-3)*v+(2)*a [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.5 Operations on Path Algebra Elements[0X
  
  [1X3.5-1 ElementOfPathAlgebra[0m
  
  [2X> ElementOfPathAlgebra( [0X[3XPA, path[0X[2X ) ________________________________[0Xoperation
  
  Arguments:  [3XPA[0m -- a path algebra, [3Xpath[0m -- a path in the quiver from which PA
  was constructed.
  
  [6XReturns:[0X  The  embedding  of  [3Xpath[0m  into  the path algebra [3XPA[0m, or it returns
            false  if  [3Xpath[0m  is not an element of the quiver from which PA was
            constructed.
  
  [1X3.5-2 <[0m
  
  [2X> <( [0X[3Xa, b[0X[2X ) _______________________________________________________[0Xoperation
  
  Arguments: [3Xa[0m and [3Xb[0m -- two elements of the same path algebra.
  
  [6XReturns:[0X  True  whenever  [3Xa[0m  is smaller than [3Xb[0m, according to the ordering of
            the path algebra.
  
  [1X3.5-3 IsLeftUniform[0m
  
  [2X> IsLeftUniform( [0X[3Xelement[0X[2X ) ________________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  true if each monomial in [3Xelement[0m has the same source vertex, false
            otherwise.
  
  [1X3.5-4 IsRightUniform[0m
  
  [2X> IsRightUniform( [0X[3Xelement[0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  true if each monomial in [3Xelement[0m has the same target vertex, false
            otherwise.
  
  [1X3.5-5 IsUniform[0m
  
  [2X> IsUniform( [0X[3Xelement[0X[2X ) ____________________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  true whenever [3Xelement[0m is both left and right uniform.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> IsLeftUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> IsRightUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> IsUniform(elem);[0X
    [4Xfalse[0X
    [4Xgap> another := FQ.a*FQ.b + FQ.b*FQ.d*FQ.c*FQ.b*FQ.d;[0X
    [4X(1)*a*b+(1)*b*d*c*b*d[0X
    [4Xgap> IsLeftUniform(another);[0X
    [4Xtrue[0X
    [4Xgap> IsRightUniform(another);[0X
    [4Xtrue[0X
    [4Xgap> IsUniform(another);[0X
    [4Xtrue [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-6 LeadingTerm[0m
  
  [2X> LeadingTerm( [0X[3Xelement[0X[2X ) __________________________________________[0Xoperation
  [2X> Tip( [0X[3Xelement[0X[2X ) __________________________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  the  term  in  [3Xelement[0m  whose  monomial  is  largest  among  those
            monomials  that  have  nonzero coefficients (known as the "tip" of
            [3Xelement[0m).
  
  [13XNote: [0m The two operations are equivalent.
  
  [1X3.5-7 LeadingCoefficient[0m
  
  [2X> LeadingCoefficient( [0X[3Xelement[0X[2X ) ___________________________________[0Xoperation
  [2X> TipCoefficient( [0X[3Xelement[0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  the  coefficient of the tip of [3Xelement[0m (which is an element of the
            field).
  
  [13XNote: [0m The two operations are equivalent.
  
  [1X3.5-8 LeadingMonomial[0m
  
  [2X> LeadingMonomial( [0X[3Xelement[0X[2X ) ______________________________________[0Xoperation
  [2X> TipMonomial( [0X[3Xelement[0X[2X ) __________________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of the path algebra.
  
  [6XReturns:[0X  the  monomial  of  the  tip of [3Xelement[0m (which is an element of the
            underlying quiver, not of the path algebra).
  
  [13XNote: [0m The two operations are equivalent.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> elem := FQ.a*FQ.b*FQ.c + FQ.b*FQ.d*FQ.c+FQ.d*FQ.d;[0X
    [4X(1)*d^2+(1)*a*b*c+(1)*b*d*c[0X
    [4Xgap> LeadingTerm(elem);[0X
    [4X(1)*b*d*c[0X
    [4Xgap> LeadingCoefficient(elem);[0X
    [4X1[0X
    [4Xgap> mon := LeadingMonomial(elem);[0X
    [4Xb*d*c[0X
    [4Xgap> mon in FQ;[0X
    [4Xfalse[0X
    [4Xgap> mon in Q;[0X
    [4Xtrue [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.5-9 MakeUniformOnRight[0m
  
  [2X> MakeUniformOnRight( [0X[3Xelems[0X[2X ) _____________________________________[0Xoperation
  
  Arguments: [3Xelems[0m -- a list of elements in a path algebra.
  
  [6XReturns:[0X  a  list  of  right  uniform  elements generated by each element of
            [3Xelems[0m.
  
  [1X3.5-10 MappedExpression[0m
  
  [2X> MappedExpression( [0X[3Xexpr, gens1, gens2[0X[2X ) __________________________[0Xoperation
  
  Arguments:   [3Xexpr[0m  --  element  of  a  path  algebra,  [3Xgens1[0m  and  [3Xgens2[0m  --
  equal-length lists of generators for subalgebras.
  
  [6XReturns:[0X  [3Xexpr[0m as an element of the subalgebra generated by [3Xgens2[0m.
  
  The  element  [3Xexpr[0m  must  be in the subalgebra generated by [3Xgens1[0m. The lists
  define  a  mapping of each generator in [3Xgens1[0m to the corresponding generator
  in [3Xgens2[0m. The value returned is the evaluation of the mapping at [3Xexpr[0m.
  
  [1X3.5-11 VertexPosition[0m
  
  [2X> VertexPosition( [0X[3Xelement[0X[2X ) _______________________________________[0Xoperation
  
  Arguments:  [3Xelement[0m  --  an  element  of the path algebra on the form $k*v$,
  where  $v$ is a vertex of the underlying quiver and $k$ is an element of the
  field.
  
  [6XReturns:[0X  the  position  of  the  vertex  [3Xv[0m  in  the list of vertices of the
            quiver.
  
  
  [1X3.6 Constructing Quotients of Path Algebras[0X
  
  See  Chapter 60: Algebras in the [5XGAP[0m manual on how to construct an ideal and
  a  quotient  of  an algebra. When the quotient is constructed, it is still a
  path  algebra  [?!]  and thus the commands introduced for path algebras also
  works with quotients.
  
  
  [1X3.7 Ideals and operations on ideals[0X
  
  [1X3.7-1 Ideal[0m
  
  [2X> Ideal( [0X[3XFQ, elems[0X[2X ) _______________________________________________[0Xfunction
  
  Arguments: [3XFQ[0m -- a path algebra, [3Xelems[0m -- a list of elements in [3XFQ[0m.
  
  [6XReturns:[0X  the   ideal   of   [3XFQ[0m   generated   by  [3Xelems[0m  with  the  property
            [2XIsIdealInPathAlgebra[0m ([14X3.8-1[0m).
  
  For more on ideals, see the [5XGAP[0m reference manual (chapter 60.6).
  [13XTechnical  info:[0m  Ideal is a synonym for a global GAP function TwoSidedIdeal
  which     calls     an    operation    TwoSidedIdealByGenerators    (synonym
  IdealByGenerators) for an algebra (FLMLOR).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> I := Ideal(FQ, [FQ.a - FQ.b*FQ.c, FQ.d*FQ.d]); [0X
    [4X<two-sided ideal in <algebra-with-one over Rationals, with 6[0X
    [4X  generators>, (2 generators)>[0X
    [4Xgap> GeneratorsOfIdeal(I);[0X
    [4X[ (1)*a+(-1)*b*c, (1)*d^2 ] [0X
    [4Xgap> IsIdealInPathAlgebra(I);[0X
    [4Xtrue [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.7-2 NthPowerOfArrowIdeal[0m
  
  [2X> NthPowerOfArrowIdeal( [0X[3XFQ, n[0X[2X ) ___________________________________[0Xoperation
  
  Arguments: [3XFQ[0m -- a path algebra, [3Xn[0m -- a positive integer.
  
  [6XReturns:[0X  the ideal generated all the paths of length [3Xn[0m in [3XFQ[0m.
  
  [1X3.7-3 AddNthPowerToRelations[0m
  
  [2X> AddNthPowerToRelations( [0X[3XFQ, rels, n[0X[2X ) ___________________________[0Xoperation
  
  Arguments: [3XFQ[0m -- a path algebra, [3Xrels[0m -- a (possibly empty) list of elements
  in [3XFQ[0m, [3Xn[0m -- a positive integer.
  
  [6XReturns:[0X  the  list  [3Xrels[0m  with  the  paths of length [3Xn[0m of [3XFQ[0m appended (will
            change the list [3Xrels[0m).
  
  [1X3.7-4 \in (elt. in path alg. and ideal)[0m
  
  [2X> \in (elt. in path alg. and ideal)( [0X[3Xelt, I[0X[2X ) _____________________[0Xoperation
  
  Arguments: [3Xelt[0m - an element in a path algebra, [3XI[0m - an ideal in the same path
  algebra (i.e. with [2XIsIdealInPathAlgebra[0m ([14X3.8-1[0m) property).
  
  [6XReturns:[0X  true, if [3Xelt[0m belongs to [3XI[0m.
  
  It  performs  the  membership  test  for  an  ideal  in  path  algebra using
  completely reduced Groebner bases machinery.
  [13XTechnical info:[0m For the efficiency reasons, it computes Groebner basis for [3XI[0m
  only   if   it   has   not   been   computed  yet.  Similarly,  it  performs
  CompletelyReduceGroebnerBasis  only  if  it  has  not  been reduced yet. The
  method can change the existing Groebner basis.
  [13XRemark:[0m It works only in case [3XI[0m is in the arrow ideal.
  
  
  [1X3.8 Categories and properties of ideals[0X
  
  [1X3.8-1 IsIdealInPathAlgebra[0m
  
  [2X> IsIdealInPathAlgebra( [0X[3XI[0X[2X ) ________________________________________[0Xproperty
  
  Arguments: [3XI[0m -- an IsFLMLOR object.
  
  [6XReturns:[0X  true whenever [3XI[0m is an ideal in a path algebra.
  
  [1X3.8-2 IsAdmissibleIdeal[0m
  
  [2X> IsAdmissibleIdeal( [0X[3XI[0X[2X ) ___________________________________________[0Xproperty
  
  Arguments: [3XI[0m -- an IsIdealInPathAlgebra object.
  
  [6XReturns:[0X  true  whenever  [3XI[0m is an [13Xadmissible[0m ideal in a path algebra, i.e. [3XI[0m
            is  a  subset of R^2 and [3XI[0m contains R^n for some n, where R is the
            arrow ideal.
  
  [13XTechnical  note:[0m  The second condition is checked by verifying if respective
  quotient  algebra  is  finite  dimensional  (and  this  uses  Groebner bases
  machinery).
  
  [1X3.8-3 IsMonomialIdeal[0m
  
  [2X> IsMonomialIdeal( [0X[3XI[0X[2X ) _____________________________________________[0Xproperty
  
  Arguments: [3XI[0m -- an IsIdealInPathAlgebra object.
  
  [6XReturns:[0X  true  whenever  [3XI[0m is a [13Xmonomial[0m ideal in a path algebra, i.e. [3XI[0m is
            generated by a set of monomials (= "zero-relations").
  
  [13XTechnical  note:[0m It uses the observation: [3XI[0m is a monomial ideal iff Groebner
  basis  of  [3XI[0m is a set of monomials. It computes Groebner basis for [3XI[0m only in
  case   it  has  not  been  computed  yet  and  a  usual  set  of  generators
  (GeneratorsOfIdeal) is not a set of monomials.
  
  [1X3.8-4 IsQuadraticIdeal[0m
  
  [2X> IsQuadraticIdeal( [0X[3Xrels[0X[2X ) ________________________________________[0Xoperation
  
  Arguments: [3Xrels[0m -- a list of elements in a path algebra.
  
  [6XReturns:[0X  true  whenever  [3Xrels[0m  is  a list of elements in the linear span of
            degree  two  elements of a path algebra. It returns false whenever
            [3Xrels[0m  is  a  list  of  elements  in a path algebra, but not in the
            linear  span of degree two of a path algebra. Otherwise it returns
            fail.
  
  
  [1X3.9 Operations on ideals[0X
  
  [1X3.9-1 ProductOfIdeals[0m
  
  [2X> ProductOfIdeals( [0X[3XI, J[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3XI, J[0m -- two ideals in a path algebra [3XKQ[0m.
  
  [6XReturns:[0X  the  ideal  formed  by the product of the ideals [3XI[0m and [3XJ[0m, whenever
            the ideal [3XJ[0m admits finitely many nontips in [3XKQ[0m.
  
  The  function  checks  if the two ideals are ideals in the same path algebra
  and that [3XJ[0m admits finitely many nontips in [3XKQ[0m.
  
  [1X3.9-2 QuadraticPerpOfPathAlgebraIdeal[0m
  
  [2X> QuadraticPerpOfPathAlgebraIdeal( [0X[3Xrels[0X[2X ) _________________________[0Xoperation
  
  Arguments: [3Xrels[0m -- a list of elements in a path algebra.
  
  [6XReturns:[0X  fail  if  [3Xrels[0m  is  not  a  list of elements in the linear span of
            degree  two  elements of a path algebra [3XKQ[0m. Otherwise it returns a
            list of length two, where the first element is a set of generators
            for  the  ideal  $[3Xrels[0m^\perp$  in  opposite  algebra of [3XKQ[0m and the
            second element is the opposite algebra of [3XKQ[0m.
  
  
  [1X3.10 Attributes of ideals[0X
  
  For  many  of the functions related to quotients, you will need to compute a
  Groebner  basis  of  the  ideal.  This  is  done  with the GBNP package. The
  following  example shows how to set a Groebner basis for an ideal (note that
  this  must  be  done  before  the quotient is constructed). See the next two
  chapters for more on Groebner bases.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> rels := [FQ.a - FQ.b*FQ.c, FQ.d*FQ.d];[0X
    [4X[ (1)*a+(-1)*b*c, (1)*d^2 ][0X
    [4Xgap> gb := GBNPGroebnerBasis(rels, FQ); [0X
    [4X[ (-1)*a+(1)*b*c, (1)*d^2 ][0X
    [4Xgap> I := Ideal(FQ, gb);[0X
    [4X<two-sided ideal in <algebra-with-one over Rationals, with 6[0X
    [4X  generators>, (2 generators)>[0X
    [4Xgap> GroebnerBasis(I, gb);[0X
    [4X<complete two-sided Groebner basis containing 2 elements>[0X
    [4Xgap> quot := FQ/I;[0X
    [4X<algebra-with-one over Rationals, with 6 generators> [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.11 Categories and Properties of Quotients of Path Algebras[0X
  
  [1X3.11-1 IsQuotientOfPathAlgebra[0m
  
  [2X> IsQuotientOfPathAlgebra( [0X[3Xobject[0X[2X ) ________________________________[0Xproperty
  
  Argument: [3Xobject[0m -- any object in [5XGAP[0m.
  
  [6XReturns:[0X  true whenever [3Xobject[0m is a quotient of a path algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> quot := FQ/I;[0X
    [4X<algebra-with-one over Rationals, with 6 generators>[0X
    [4Xgap> IsQuotientOfPathAlgebra(quot);[0X
    [4Xtrue[0X
    [4Xgap> IsQuotientOfPathAlgebra(FQ);   [0X
    [4Xfalse [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.11-2 IsFiniteDimensional[0m
  
  [2X> IsFiniteDimensional( [0X[3XA[0X[2X ) _________________________________________[0Xproperty
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  true whenever [3XA[0m is a finite dimensional algebra.
  
  [13XTechnical  note:[0m  For  a  path  algebra it uses a standard [5XGAP[0m method. For a
  quotient  of  a  path  algebra it uses Groebner bases machinery (it computes
  Groebner basis for the ideal only in case it has not been computed yet).
  
  
  [1X3.12 Attributes and Operations for Quotients of Path Algebras[0X
  
  [1X3.12-1 Dimension[0m
  
  [2X> Dimension( [0X[3XA[0X[2X ) __________________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  the  dimension  of  the  algebra  [3XA[0m  or  [13Xinfinity[0m  in case [3XA[0m is an
            infinite dimensional algebra.
  
  [13XTechnical  note:[0m For a path algebra it uses a standard [5XGAP[0m method (it breaks
  for  infinite  dimensional  case!). For a quotient of a path algebra it uses
  Groebner  bases  machinery (it computes Groebner basis for the ideal only in
  case it has not been computed yet).
  
  [1X3.12-2 IsSelfinjectiveAlgebra[0m
  
  [2X> IsSelfinjectiveAlgebra( [0X[3XA[0X[2X ) ______________________________________[0Xproperty
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  fail  if [3XA[0m is not finite dimensional. Otherwise it returns true or
            false according to whether [3XA[0m is selfinjective or not.
  
  [1X3.12-3 IsSymmetricAlgebra[0m
  
  [2X> IsSymmetricAlgebra( [0X[3XA[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  fail  if  [3XA[0m  is not finite dimensional or does not have a Groebner
            basis.  Otherwise  it returns true or false according to whether [3XA[0m
            is symmetric or not.
  
  [1X3.12-4 IsWeaklySymmetricAlgebra[0m
  
  [2X> IsWeaklySymmetricAlgebra( [0X[3XA[0X[2X ) ___________________________________[0Xoperation
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  fail  if  [3XA[0m  is not finite dimensional or does not have a Groebner
            basis.  Otherwise  it returns true or false according to whether [3XA[0m
            is weakly symmetric or not.
  
  [1X3.12-5 LoewyLength[0m
  
  [2X> LoewyLength( [0X[3XA[0X[2X ) ________________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  fail  if  [3XA[0m  is  not  finite dimensional. Otherwise it returns the
            Loewy length of the algebra [3XA[0m.
  
  [1X3.12-6 CartanMatrix[0m
  
  [2X> CartanMatrix( [0X[3XA[0X[2X ) _______________________________________________[0Xoperation
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  the Cartan matrix of the algebra [3XA[0m, after having checked that [3XA[0m is
            a finite dimensional quotient of a path algebra.
  
  [1X3.12-7 CoxeterMatrix[0m
  
  [2X> CoxeterMatrix( [0X[3XA[0X[2X ) ______________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  the  Coxeter  matrix of the algebra [3XA[0m, after having checked that [3XA[0m
            is a finite dimensional quotient of a path algebra.
  
  [1X3.12-8 CoxeterPolynomial[0m
  
  [2X> CoxeterPolynomial( [0X[3XA[0X[2X ) __________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  the Coxeter polynomial of the algebra [3XA[0m, after having checked that
            [3XA[0m is a finite dimensional quotient of a path algebra.
  
  [1X3.12-9 Centre/Center[0m
  
  [2X> Centre/Center( [0X[3XA[0X[2X ) ______________________________________________[0Xoperation
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  the  centre  of  the  algebra  [3XA[0m, after having checked that [3XA[0m is a
            finite  dimensional  quotient  of a path algebra (the check is not
            implemented and also not implemented for path algebras).
  
  
  [1X3.13 Attributes and Operations on Elements of Quotients of Path Algebra[0X
  
  [1X3.13-1 IsElementOfQuotientOfPathAlgebra[0m
  
  [2X> IsElementOfQuotientOfPathAlgebra( [0X[3Xobject[0X[2X ) _______________________[0Xproperty
  
  Arguments: [3Xobject[0m -- any object in [5XGAP[0m.
  
  [6XReturns:[0X  true  whenever  [3Xobject[0m  is  an  element of some quotient of a path
            algebra.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> elem := quot.a*quot.b;[0X
    [4X[(1)*a*b][0X
    [4Xgap> IsElementOfQuotientOfPathAlgebra(elem);[0X
    [4Xtrue[0X
    [4Xgap> IsElementOfQuotientOfPathAlgebra(FQ.a*FQ.b);    [0X
    [4Xfalse [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.13-2 Coefficients[0m
  
  [2X> Coefficients( [0X[3Xelement[0X[2X ) _________________________________________[0Xoperation
  
  The  operation  [2XCoefficients[0m  operates on an [3Xelement[0m of a quotient of a path
  algebra,  and  it  returns  the  coefficients of the [3Xelement[0m in terms of its
  canonical basis.
  [13XNote: Not in QPA, takes two arguments in [5XGAP[0m[13X.[0m
  
  [1X3.13-3 IsNormalForm[0m
  
  [2X> IsNormalForm( [0X[3Xelement[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3Xelement[0m -- an element of a path algebra.
  
  [6XReturns:[0X  true if [3Xelement[0m is known to be in normal form.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X gap> IsNormalForm(elem);  [0X
    [4X true  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.13-4 <[0m
  
  [2X> <( [0X[3Xa, b[0X[2X ) _______________________________________________________[0Xoperation
  
  Arguments: [3Xa[0m and [3Xb[0m -- elements from a path algebra.
  
  [6XReturns:[0X  true whenever [3Xa[0m < [3Xb[0m.
  
  [1X3.13-5 ElementOfQuotientOfPathAlgebra[0m
  
  [2X> ElementOfQuotientOfPathAlgebra( [0X[3Xfamily, element, computenormal[0X[2X ) [0Xoperation
  
  Arguments:  [3Xfamily[0m  -- a family of elements, [3Xelement[0m -- an element of a path
  algebra, [3Xcomputenormal[0m -- true or false.
  
  [6XReturns:[0X  The  projection  of  [3Xelement[0m into the quotient given by [3Xfamily[0m. If
            [3Xcomputenormal[0m  is  true, then the normal form of the projection of
            [3Xelement[0m is returned.
  
  [3Xfamily[0m  is  the  ElementsFamily  of  the  family  of  the algebra [3Xelement[0m is
  projected into.
  
  [1X3.13-6 OriginalPathAlgebra[0m
  
  [2X> OriginalPathAlgebra( [0X[3Xalgebra[0X[2X ) __________________________________[0Xattribute
  
  Arguments: [3Xalgebra[0m -- an algebra.
  
  [6XReturns:[0X  a path algebra.
  
  If  [3Xalgebra[0m  is  a quotient of a path algebra or just a path algebra itself,
  the  returned algebra is the path algebra it was constructed from. Otherwise
  it  returns an error saying that the algebra entered was not a quotient of a
  path algebra.
  
  
  [1X3.14 Predefined classes of (quotients of) path algebras[0X
  
  [1X3.14-1 CanonicalAlgebra[0m
  
  [2X> CanonicalAlgebra( [0X[3Xfield, weights[, relcoeff][0X[2X ) __________________[0Xoperation
  
  Arguments:  [3Xfield[0m  --  a  field,  [3Xweights[0m -- a list of positive integers, [,
  relcoeff -- a list of non-zero elements in the field.
  
  [6XReturns:[0X  the  canonical algebra over the [3Xfield[0m with the quiver given by the
            weight   sequence   [3Xweights[0m   and   the  relations  given  by  the
            coefficients [3Xrelcoeff[0m.
  
  It  function  checks  if  all  the  [3Xweights[0m are greater or equal to two, the
  number  of weights is at least two, the number of coefficients is the number
  of  [3Xweights[0m  -  2,  the  coefficients  for  the  relations  are in field and
  non-zero.  If  only  the  two  first arguments are given, then the number of
  weights must be two.
  
  [1X3.14-2 KroneckerAlgebra[0m
  
  [2X> KroneckerAlgebra( [0X[3Xfield, n[0X[2X ) ____________________________________[0Xoperation
  
  Arguments: [3Xfield[0m -- a field, [3Xn[0m -- a positive integer.
  
  [6XReturns:[0X  the [3Xn[0m-Kronecker algebra over the field [3Xfield[0m.
  
  It  function checks if the number [3Xn[0m of arrows is greater or equal to two and
  returns an error message if not.
  
  [1X3.14-3 NakayamaAlgebra[0m
  
  [2X> NakayamaAlgebra( [0X[3Xadmiss-seq, field[0X[2X ) _____________________________[0Xfunction
  
  Arguments: [3Xadmiss-seq[0m -- a list of positive integers, [3Xfield[0m -- a field.
  
  [6XReturns:[0X  The  Nakayama  algebra  corresponding to [3Xadmiss-seq[0m over the field
            [3Xfield[0m.  If the entered sequence is not an admissible sequence, the
            sequence is returned.
  
  The [3Xadmiss-seq[0m consists of the dimensions of the projective representations.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> alg := NakayamaAlgebra([2,1], Rationals);[0X
    [4X<algebra-with-one over Rationals, with 3 generators>[0X
    [4Xgap> QuiverOfPathAlgebra(alg);[0X
    [4X<quiver with 2 vertices and 1 arrows>  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.14-4 TruncatedPathAlgebra[0m
  
  [2X> TruncatedPathAlgebra( [0X[3XF, Q, n[0X[2X ) _________________________________[0Xoperation
  
  Arguments: [3XF[0m -- a field, [3XQ[0m -- a quiver, [3Xn[0m -- a positive integer.
  
  [6XReturns:[0X  the truncated path algebra [3XKQ/I[0m, where [3XI[0m is the ideal generated by
            all paths of length [3Xn[0m in [3XKQ[0m.
  
  [1X3.14-5 IsSpecialBiserialQuiver[0m
  
  [2X> IsSpecialBiserialQuiver( [0X[3XQ[0X[2X ) _____________________________________[0Xproperty
  
  Arguments: [3XQ[0m -- a quiver.
  
  [6XReturns:[0X  true  whenever [3XQ[0m is a [13X"special biserial"[0m quiver, i.e. every vertex
            in [3XQ[0m is a source (resp. target) of at most 2 arrows.
  
  [13XNote:[0m  e.g. a path algebra of one loop IS NOT special biserial, but one loop
  IS  special  biserial quiver (cf. [2XIsSpecialBiserialAlgebra[0m ([14X3.14-6[0m) and also
  an Example below).
  
  [1X3.14-6 IsSpecialBiserialAlgebra[0m
  
  [2X> IsSpecialBiserialAlgebra( [0X[3XA[0X[2X ) ____________________________________[0Xproperty
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  true  whenever [3XA[0m is a [13Xspecial biserial algebra[0m, i.e. [3XA[0m=KQ/I, where
            Q  is  [2XIsSpecialBiserialQuiver[0m  ([14X3.14-5[0m), I is an admissible ideal
            ([2XIsAdmissibleIdeal[0m ([14X3.8-2[0m)) and I satisfies the "special biserial"
            conditions, i.e.:
            for any arrow a there exists at most one arrow b such that ab does
            not  belong to I and there exists at most one arrow c such that ca
            does not belong to I.
  
  [13XNote:[0m  e.g. a path algebra of one loop IS NOT special biserial, but one loop
  IS special biserial quiver (cf. [2XIsSpecialBiserialQuiver[0m ([14X3.14-5[0m)).
  
  [1X3.14-7 IsStringAlgebra[0m
  
  [2X> IsStringAlgebra( [0X[3XA[0X[2X ) _____________________________________________[0Xproperty
  
  Arguments: [3XA[0m -- a path algebra or a quotient of a path algebra.
  
  [6XReturns:[0X  true  whenever  [3XA[0m  is  a  [13Xstring[0m  (special biserial) algebra, i.e.
            [3XA[0m=KQ/I  is  a  special  biserial algebra ([2XIsSpecialBiserialAlgebra[0m
            ([14X3.14-6[0m) and I is generated by monomials (= "zero-relations") (cf.
            [2XIsMonomialIdeal[0m ([14X3.8-3[0m)).
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q := Quiver(1, [ [1,1,"a"], [1,1,"b"] ]);;  [0X
    [4Xgap> A := PathAlgebra(Rationals, Q);;[0X
    [4Xgap> IsSpecialBiserialAlgebra(A); IsStringAlgebra(A);[0X
    [4Xfalse[0X
    [4Xfalse[0X
    [4Xgap> rel1 := [A.a*A.b, A.a^2, A.b^2];  [0X
    [4X[ (1)*a*b, (1)*a^2, (1)*b^2 ][0X
    [4Xgap> I1 := Ideal(A, rel1);;  quo1 := A/I1;;[0X
    [4Xgap> IsSpecialBiserialAlgebra(quo1); IsStringAlgebra(quo1);[0X
    [4Xtrue[0X
    [4Xtrue[0X
    [4Xgap> rel2 := [A.a*A.b-A.b*A.a, A.a^2, A.b^2];  [0X
    [4X[ (1)*a*b+(-1)*b*a, (1)*a^2, (1)*b^2 ][0X
    [4Xgap> I2 := Ideal(A, rel2);; quo2 := A/I2;;[0X
    [4Xgap> IsSpecialBiserialAlgebra(quo2); IsStringAlgebra(quo2);[0X
    [4Xtrue[0X
    [4Xfalse[0X
    [4Xgap> rel3 := [A.a*A.b+A.b*A.a, A.a^2, A.b^2, A.b*A.a];   [0X
    [4X[ (1)*a*b+(1)*b*a, (1)*a^2, (1)*b^2, (1)*b*a ][0X
    [4Xgap> I3 := Ideal(A, rel3);; quo3 := A/I3;;[0X
    [4Xgap> IsSpecialBiserialAlgebra(quo3); IsStringAlgebra(quo3);[0X
    [4Xtrue[0X
    [4Xtrue[0X
    [4Xgap> rel4 := [A.a*A.b, A.a^2, A.b^3]; [0X
    [4X[ (1)*a*b, (1)*a^2, (1)*b^3 ][0X
    [4Xgap> I4 := Ideal(A, rel4);; quo4 := A/I4;;[0X
    [4Xgap> IsSpecialBiserialAlgebra(quo4); IsStringAlgebra(quo4);[0X
    [4Xfalse[0X
    [4Xfalse [0X
    [4X  [0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.15 Opposite algebras[0X
  
  [1X3.15-1 OppositeQuiver[0m
  
  [2X> OppositeQuiver( [0X[3XQ[0X[2X ) _____________________________________________[0Xattribute
  
  Arguments: [3XQ[0m -- a quiver.
  
  [6XReturns:[0X  the opposite quiver [3XQ[0m^op.
  
  This  attribute  contains the opposite quiver of a quiver, that is, a quiver
  which is the same except that every arrow goes in the opposite direction.
  
  The  operation  [2XOppositePath[0m  ([14X3.15-2[0m)  takes  a  path  in  a  quiver to the
  corresponding path in the opposite quiver.
  
  The  opposite  of  the opposite of a quiver Q is isomorphic to Q. In QPA, we
  regard    these    two    quivers    to   be   the   same,   so   the   call
  [10XOppositeQuiver(OppositeQuiver(Q))[0m returns the object [10XQ[0m.
  
  [1X3.15-2 OppositePath[0m
  
  [2X> OppositePath( [0X[3Xp[0X[2X ) _______________________________________________[0Xoperation
  
  Arguments: [3Xp[0m -- a path.
  
  [6XReturns:[0X  the path corresponding to [3Xp[0m in the opposite quiver.
  
  The  following  example  illustrates  the use of [2XOppositeQuiver[0m ([14X3.15-1[0m) and
  [2XOppositePath[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q := Quiver( [ "u", "v" ], [ [ "u", "u", "a" ], [ "u", "v", "b" ] ] );[0X
    [4X<quiver with 2 vertices and 2 arrows>[0X
    [4Xgap> Qop := OppositeQuiver(Q);[0X
    [4X<quiver with 2 vertices and 2 arrows>[0X
    [4Xgap> VerticesOfQuiver( Qop );[0X
    [4X[ u_op, v_op ][0X
    [4Xgap> ArrowsOfQuiver( Qop );[0X
    [4X[ a_op, b_op ][0X
    [4Xgap> OppositePath( Q.a * Q.b );[0X
    [4Xb_op*a_op[0X
    [4Xgap> IsIdenticalObj( Q, OppositeQuiver( Qop ) );[0X
    [4Xtrue[0X
    [4Xgap> OppositePath( Qop.b_op * Qop.a_op );[0X
    [4Xa*b[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.15-3 OppositePathAlgebra[0m
  
  [2X> OppositePathAlgebra( [0X[3XA[0X[2X ) ________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a path algebra or quotient of path algebra.
  
  [6XReturns:[0X  the opposite algebra [3XA[0m^op.
  
  This attribute contains the opposite algebra of an algebra.
  
  The opposite algebra of a path algebra is the path algebra over the opposite
  quiver  (as  given  by  [2XOppositeQuiver[0m  ([14X3.15-1[0m)). The opposite algebra of a
  quotient  of  a  path  algebra  has  the  opposite  quiver  and the opposite
  relations of the original algebra.
  
  The function [2XOppositePathAlgebraElement[0m ([14X3.15-4[0m) takes an algebra element to
  the corresponding element in the opposite algebra.
  
  The  opposite of the opposite of an algebra A is isomorphic to A. In QPA, we
  regard    these    two    algebras   to   be   the   same,   so   the   call
  [10XOppositePathAlgebra(OppositePathAlgebra(A))[0m returns the object [10XA[0m.
  
  [1X3.15-4 OppositePathAlgebraElement[0m
  
  [2X> OppositePathAlgebraElement( [0X[3Xx[0X[2X ) __________________________________[0Xfunction
  
  Arguments: [3Xx[0m -- a path.
  
  [6XReturns:[0X  the element corresponding to [3Xx[0m in the opposite algebra.
  
  The  following  example  illustrates the use of [2XOppositePathAlgebra[0m ([14X3.15-3[0m)
  and [2XOppositePathAlgebraElement[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q := Quiver( [ "u", "v" ], [ [ "u", "u", "a" ], [ "u", "v", "b" ] ] );[0X
    [4X<quiver with 2 vertices and 2 arrows>[0X
    [4Xgap> A := PathAlgebra( Rationals, Q );[0X
    [4X<Rationals[<quiver with 2 vertices and 2 arrows>]>[0X
    [4Xgap> OppositePathAlgebra( A );[0X
    [4X<Rationals[<quiver with 2 vertices and 2 arrows>]>[0X
    [4Xgap> OppositePathAlgebraElement( A.u + 2*A.a + 5*A.a*A.b );[0X
    [4X(1)*u_op+(2)*a_op+(5)*b_op*a_op[0X
    [4Xgap> IsIdenticalObj( A, OppositePathAlgebra( OppositePathAlgebra( A ) ) );[0X
    [4Xtrue[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X3.16 Tensor products of path algebras[0X
  
  If  Lambda  and  Gamma are quotients of path algebras over the same field F,
  then their tensor product Lambda tensor_F Gamma is also a quotient of a path
  algebra over F.
  
  The quiver for the tensor product path algebra is the [2XQuiverProduct[0m ([14X3.16-1[0m)
  of the quivers of the original algebras.
  
  The  operation [2XTensorProductOfAlgebras[0m ([14X3.16-6[0m) computes the tensor products
  of two quotients of path algebras as a quotient of a path algebra.
  
  [1X3.16-1 QuiverProduct[0m
  
  [2X> QuiverProduct( [0X[3XQ1, Q2[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3XQ1[0m and [3XQ2[0m -- quivers.
  
  [6XReturns:[0X  the product quiver [3XQ1[0m quiverproduct [3XQ2[0m.
  
  A  vertex in [3XQ1[0m quiverproduct [3XQ2[0m which is made by combining a vertex named [10Xu[0m
  in  [3XQ1[0m  with a vertex [10Xv[0m in [3XQ2[0m is named [10Xu_v[0m. Arrows are named similarly (they
  are  made  by  combining  an  arrow  from  one quiver with a vertex from the
  other).
  
  [1X3.16-2 QuiverProductDecomposition[0m
  
  [2X> QuiverProductDecomposition( [0X[3XQ[0X[2X ) _________________________________[0Xattribute
  
  Arguments: [3XQ[0m -- a quiver.
  
  [6XReturns:[0X  the  original  quivers  [3XQ[0m is a product of, if [3XQ[0m was created by the
            [2XQuiverProduct[0m ([14X3.16-1[0m) operation.
  
  The   value   of   this   attribute   is   an   object   in   the   category
  [2XIsQuiverProductDecomposition[0m ([14X3.16-3[0m).
  
  [1X3.16-3 IsQuiverProductDecomposition[0m
  
  [2X> IsQuiverProductDecomposition( [0X[3Xobject[0X[2X ) ___________________________[0Xcategory
  
  Arguments: [3Xobject[0m -- any object in [5XGAP[0m.
  
  Category  for  objects  containing  information about the relation between a
  product quiver and the quivers it is a product of. The quiver factors can be
  extracted  from  the  decomposition  object  by  using the [] notation (like
  accessing  elements of a list). The decomposition object is also used by the
  operations   [2XIncludeInProductQuiver[0m  ([14X3.16-4[0m)  and  [2XProjectFromProductQuiver[0m
  ([14X3.16-5[0m).
  
  [1X3.16-4 IncludeInProductQuiver[0m
  
  [2X> IncludeInProductQuiver( [0X[3XL, Q[0X[2X ) __________________________________[0Xoperation
  
  Arguments:  [3XL[0m  --  a  list  containing the paths q_1 and q_2, Q -- a product
  quiver.
  
  [6XReturns:[0X  a path in [3XQ[0m.
  
  Includes  paths  q_1  and  q_2  from  two  quivers into the product of these
  quivers, [3XQ[0m. If at least one of q_1 and q_2 is a vertex, there is exactly one
  possible  inclusion.  If  they are both non-trivial paths, there are several
  possibilities.  This operation constructs the path which is the inclusion of
  q_1  at the source of q_2 multiplied with the inclusion of q_2 at the target
  of q_1.
  
  [1X3.16-5 ProjectFromProductQuiver[0m
  
  [2X> ProjectFromProductQuiver( [0X[3Xi, p[0X[2X ) ________________________________[0Xoperation
  
  Arguments: [3Xi[0m -- a positive integer, [3Xp[0m -- a path in the product quiver.
  
  [6XReturns:[0X  the projection of the product quiver path [3Xp[0m to one of the factors.
            Which  factor  it  should  be  projected  to  is  specified by the
            argument [3Xi[0m.
  
  The  following  example  shows how the operations related to quiver products
  are used.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q2 := Quiver( [ "v1", "v2", "v3" ],[0X
    [4X                      [ [ "v1", "v2", "b" ],[0X
    [4X                        [ "v2", "v3", "c" ] ] );[0X
    [4X<quiver with 3 vertices and 2 arrows>[0X
    [4Xgap> q1_q2 := QuiverProduct( q1, q2 );[0X
    [4X<quiver with 6 vertices and 7 arrows>[0X
    [4Xgap> q1_q2.u1_b * q1_q2.a_v2;[0X
    [4Xu1_b*a_v2[0X
    [4Xgap> IncludeInProductQuiver( [ q1.a, q2.b * q2.c ], q1_q2 );[0X
    [4Xa_v1*u2_b*u2_c[0X
    [4Xgap> ProjectFromProductQuiver( 2, q1_q2.a_v1 * q1_q2.u2_b * q1_q2.u2_c );[0X
    [4Xb*c[0X
    [4Xgap> q1_q2_dec := QuiverProductDecomposition( q1_q2 );[0X
    [4X<object>[0X
    [4Xgap> q1_q2_dec[ 1 ];[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q1_q2_dec[ 1 ] = q1;[0X
    [4Xtrue  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.16-6 TensorProductOfAlgebras[0m
  
  [2X> TensorProductOfAlgebras( [0X[3XFQ1, FQ2[0X[2X ) _____________________________[0Xoperation
  
  Arguments: [3XFQ1[0m and [3XFQ2[0m -- (quotients of) path algebras.
  
  [6XReturns:[0X  The tensor product of [3XFQ1[0m and [3XFQ2[0m.
  
  The   result  is  a  quotient  of  a  path  algebra,  whose  quiver  is  the
  [2XQuiverProduct[0m ([14X3.16-1[0m) of the quivers of the operands.
  
  [1X3.16-7 SimpleTensor[0m
  
  [2X> SimpleTensor( [0X[3XL, T[0X[2X ) ____________________________________________[0Xoperation
  
  Arguments: [3XL[0m -- a list containing two elements x and y of two (quotients of)
  path algebras, [3XT[0m -- the tensor product of these algebras.
  
  [6XReturns:[0X  the simple tensor x tensor y.
  
  x  tensor  y is in the tensor product [3XT[0m (produced by [2XTensorProductOfAlgebras[0m
  ([14X3.16-6[0m)).
  
  [1X3.16-8 TensorProductDecomposition[0m
  
  [2X> TensorProductDecomposition( [0X[3XT[0X[2X ) _________________________________[0Xattribute
  
  Arguments: [3XT[0m -- a tensor product of path algebras.
  
  [6XReturns:[0X  a list of the factors in the tensor product.
  
  [3XT[0m should be produced by [2XTensorProductOfAlgebras[0m ([14X3.16-6[0m)).
  
  The  following  example  shows  how  the  operations  for tensor products of
  quotients of path algebras are used.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> q1 := Quiver( [ "u1", "u2" ], [ [ "u1", "u2", "a" ] ] );[0X
    [4X<quiver with 2 vertices and 1 arrows>[0X
    [4Xgap> q2 := Quiver( [ "v1", "v2", "v3", "v4" ],[0X
    [4X                      [ [ "v1", "v2", "b" ],[0X
    [4X                        [ "v1", "v3", "c" ],[0X
    [4X                        [ "v2", "v4", "d" ],[0X
    [4X                        [ "v3", "v4", "e" ] ] );[0X
    [4X<quiver with 4 vertices and 4 arrows>[0X
    [4Xgap> fq1 := PathAlgebra( Rationals, q1 );[0X
    [4X<algebra-with-one over Rationals, with 3 generators>[0X
    [4Xgap> fq2 := PathAlgebra( Rationals, q2 );[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> I := Ideal( fq2, [ fq2.b * fq2.d - fq2.c * fq2.e ] );[0X
    [4X<two-sided ideal in <algebra-with-one over Rationals, with 8 generators>,[0X
    [4X (1 generators)>[0X
    [4Xgap> quot := fq2 / I;[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> t := TensorProductOfAlgebras( fq1, quot );[0X
    [4X<algebra-with-one over Rationals, with 20 generators>[0X
    [4Xgap> SimpleTensor( [ fq1.a, quot.b ], t );[0X
    [4X[(1)*a_v1*u2_b][0X
    [4Xgap> t_dec := TensorProductDecomposition( t );[0X
    [4X[ <algebra-with-one over Rationals, with 3 generators>, [0X
    [4X  <algebra-with-one over Rationals, with 8 generators> ][0X
    [4Xgap> t_dec[ 1 ] = fq1;[0X
    [4Xtrue [0X
  [4X------------------------------------------------------------------[0X
  
  [1X3.16-9 EnvelopingAlgebra[0m
  
  [2X> EnvelopingAlgebra( [0X[3XA[0X[2X ) __________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a (quotient of) a path algebra.
  
  [6XReturns:[0X  the enveloping algebra [3XA[0m^e = [3XA[0m^op tensor [3XA[0m of [3XA[0m
  
  [1X3.16-10 IsEnvelopingAlgebra[0m
  
  [2X> IsEnvelopingAlgebra( [0X[3XA[0X[2X ) _________________________________________[0Xproperty
  
  Arguments: [3XA[0m -- an algebra.
  
  [6XReturns:[0X  true if and only if [3XA[0m is the result of a call to [2XEnvelopingAlgebra[0m
            ([14X3.16-9[0m).
  
  [1X3.16-11 AlgebraAsModuleOfEnvelopingAlgebra[0m
  
  [2X> AlgebraAsModuleOfEnvelopingAlgebra( [0X[3XAenv[0X[2X ) ______________________[0Xattribute
  
  Arguments:  [3XAenv[0m -- the enveloping algebra of a (quotient of) a path algebra
  [3XA[0m.
  
  [6XReturns:[0X  the algebra [3XA[0m as a right module over the enveloping algebra [3XAenv[0m.
  
