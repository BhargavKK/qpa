  
  [1X6 Right Modules over Path Algebras[0X
  
  There are two implementations of right modules over path algebras. The first
  type  are  matrix  modules  that  are  defined  by  vector spaces and linear
  transformations.  The  second  type  are  presentations  defined  by  vertex
  projective modules.
  
  
  [1X6.1 Matrix Modules[0X
  
  The first implementation of right modules over path algebras views them as a
  collection  of  vector spaces and linear transformations. Each vertex in the
  path  algebra  is  associated  with  a  vector  space  over the field of the
  algebra.  For  each  vertex  $v$ of the algebra there is a vector space $V$.
  Arrows  of the algebra are then associated with linear transformations which
  map  the vector space of the source vertex to the vector space of the target
  vertex.  For  example,  if  $a$  is an arrow from $v$ to $w$ then there is a
  transformation  from  vector space $V$ to $W$. In practice when creating the
  modules  all  we  need  to know is the transformations and we can create the
  vector  spaces  of  the  correct  dimension,  and  check  to  make  sure the
  dimensions all agree. We can create a module in this way as follows.
  
  [1X6.1-1 RightModuleOverPathAlgebra[0m
  
  [2X> RightModuleOverPathAlgebra( [0X[3XA, mats[0X[2X ) ____________________________[0Xfunction
  [6XReturns:[0X  a representation over a path algebra.
  
  In  the  function call, [3XA[0m is the path algebra. The list of matrices [3Xmats[0m can
  take on three different forms.
  
  1) The argument [3Xmats[0m can be a list of blocks of matrices where each block is
  of  the  form,  `["name of arrow",matrix]'. So if you named your arrows when
  you  created  the  quiver,  then  you can associate a matrix with that arrow
  explicitly.
  
  2)  The  argument  [3Xmats[0m is just a list of matrices, and the matrices will be
  associated  to  the  arrows in the order of arrow creation. If when creating
  the  quiver,  the  arrow $a$ was created first, then $a$ would be associated
  with the first matrix.
  
  3)  The  method  is  very much the same as the second method. If [3Xarrows[0m is a
  list  of  the  arrows of the quiver (obtained for instance through [10Xarrows :=
  ArrowsOfQuiver(Q);[0m),    the    argument    [3Xmats[0m    can   have   the   format
  [10X[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].[0m
  
  If  you  would  like  the  trivial vector space at any vertex, then for each
  incoming arrow "a", associate it with a list of the form [10X["a",[n,0]][0m where n
  is  the  dimension  of  the  vector space at the source vertex of the arrow.
  Likewise  for  all  outgoing  arrows  "b", associate them to a block of form
  [10X["b",[0,n]][0m  where  n  is  the  dimension  of the vector space at the target
  vertex of the arrow.
  
  A  warning  though,  the  function assumes that you do not mix the styles of
  inputting  the  matrices/linear  transformations associated to the arrows in
  the quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise
  an  error will be returned. The function verifies that the dimensions of the
  matrices  and  vector  spaces are correct and match, and that each arrow has
  only one matrix assigned to it.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); [0X
    [4X<quiver with 2 vertices and 3 arrows>[0X
    [4Xgap> P := PathAlgebra(Rationals, Q);[0X
    [4X<algebra-with-one over Rationals, with 5 generators>[0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X> ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>> [0X
    [4Xgap> mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; [0X
    [4Xgap> N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>> [0X
    [4Xgap> arrows := ArrowsOfQuiver(Q);[0X
    [4X[ a, b, c ][0X
    [4Xgap> mats := [[arrows[1], [[1,0,0],[0,1,0]]], [0X
    [4X> [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;[0X
    [4Xgap> N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>>[0X
    [4Xgap> # Next we give the vertex simple associate to vertex 1. [0X
    [4Xgap> M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4X					generators>> [0X
    [4Xgap> # Finally, the next defines the zero representation of the quiver.[0X
    [4Xgap> M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4X					generators>> [0X
    [4Xgap> Dimension(M);[0X
    [4X0[0X
    [4Xgap> Basis(M);[0X
    [4XBasis( <[0X
    [4X0-dimensional right-module over <algebra-with-one over Rationals, with [0X
    [4X5 generators>>, [  ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.2 Categories Of Matrix Modules[0X
  
  [1X6.2-1 IsPathAlgebraMatModule[0m
  
  [2X> IsPathAlgebraMatModule( [0X[3Xobject[0X[2X ) ___________________________________[0Xfilter
  
  These  matrix  modules  fall  under  the category `IsAlgebraModule' with the
  added  filter  of `IsPathAlgebraMatModule'. Operations available for algebra
  modules  can be applied to path algebra modules. See "ref:representations of
  algebras"  for  more  details. These modules are also vector spaces over the
  field  of the path algebra. So refer to "ref:vector spaces" for descriptions
  of the basis and elementwise operations available.
  
  
  [1X6.3 Acting on Module Elements[0X
  
  [1X6.3-1 ^[0m
  
  [2X> ^( [0X[3Xm, p[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation [2X^[0m operates on an element [3Xm[0m in a module and a path [3Xp[0m in a path
  algebra,  and it returns the element [3Xm[0m multiplied with [3Xp[0m. When you act on an
  module  element  $m$  by  an arrow $a$ from $v$ to $w$, the component of $m$
  from  $V$ is acted on by $L$ the transformation associated to $a$ and placed
  in the component $W$ . All other components are given the value $0$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # Using the path algebra P from the above example. [0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X> ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>> [0X
    [4Xgap> B:=BasisVectors(Basis(M));[0X
    [4X[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 0, 0, 1 ] ] ][0X
    [4Xgap> B[1]+B[3];[0X
    [4X[ [ 1, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> 4*B[2];[0X
    [4X[ [ 0, 4 ], [ 0, 0, 0 ] ][0X
    [4Xgap> m:=5*B[1]+2*B[4]+B[5];[0X
    [4X[ [ 5, 0 ], [ 0, 2, 1 ] ][0X
    [4Xgap> m^(P.a*P.b-P.c);[0X
    [4X[ [ 0, 5 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[1]^P.a;[0X
    [4X[ [ 0, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> B[2]^P.b;[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[4]^(P.b*P.c);[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.4 Operations on representations[0X
  
  [1X6.4-1 DimensionVector[0m
  
  [2X> DimensionVector( [0X[3XM[0X[2X ) ____________________________________________[0Xoperation
  [6XReturns:[0X  the  dimension vector of the representation [3XM[0m. The argument [3XM[0m must
            be a [10XPathAlgebraMatModule[0m.
  
  A  shortcoming  of  this  that it is not defined for modules of quotients of
  path algebras.
  
  [1X6.4-2 MatricesOfPathAlgebraMatModule[0m
  
  [2X> MatricesOfPathAlgebraMatModule( [0X[3XM[0X[2X ) _____________________________[0Xoperation
  [6XReturns:[0X  a  list  of  the  matrices  that defines the representation [3XM[0m as a
            right  module of the acting path algebra. The argument [3XM[0m must be a
            [10XPathAlgebraMatModule[0m.
  
  The  list  of  matrices  that are returned are not the same identical to the
  matrices  entered to define the representation if there is zero vector space
  in  at  least  one  vertex.  Then  zero matrices of the appropriate size are
  returned.  A  shortcoming  of  this  that  it  is not defined for modules of
  quotients of path algebras.
  
  
  [1X6.5 Special representations[0X
  
  Here  we  collect  the  predefined  representations/modules  over  a  finite
  dimensional quotient of a path algebra.
  
  [1X6.5-1 IndecomposableProjectiveRepresentations[0m
  
  [2X> IndecomposableProjectiveRepresentations( [0X[3XKQ, rels[0X[2X ) _____________[0Xoperation
  [6XReturns:[0X  a list of all the indecomposable projective representations over a
            finite  dimensional  quotient  of  a  path  algebra  [3XKQ[0m modulo the
            relations [3Xrels[0m.
  
  The  function  checks  if  the  quotient  [3XKQ/(rels)[0m  is a finite dimensional
  algebra,  and  returns  an  error  message  otherwise.  A shortcoming of the
  current implementation is that it only returns the indecomposable projective
  representations/modules as modules over [3XKQ[0m, instead of [3XKQ/(rels)[0m.
  
  [1X6.5-2 IndecomposableInjectiveRepresentations[0m
  
  [2X> IndecomposableInjectiveRepresentations( [0X[3XKQ, rels[0X[2X ) ______________[0Xoperation
  [6XReturns:[0X  a  list of all the indecomposable injective representations over a
            finite  dimensional  quotient  of  a  path  algebra  [3XKQ[0m modulo the
            relations [3Xrels[0m.
  
  The  function  checks  if  the  quotient  [3XKQ/(rels)[0m  is a finite dimensional
  algebra,  and  returns  an  error  message  otherwise.  A shortcoming of the
  current  implementation is that it only returns the indecomposable injective
  representations/modules as modules over [3XKQ[0m, instead of [3XKQ/(rels)[0m.
  
  [1X6.5-3 VertexSimpleRepresentations[0m
  
  [2X> VertexSimpleRepresentations( [0X[3XKQ, rels[0X[2X ) _________________________[0Xoperation
  [6XReturns:[0X  a list of all the simple representations over a finite dimensional
            quotient of a path algebra [3XKQ[0m modulo the relations [3Xrels[0m.
  
  A  shortcoming  of  the  current  implementation is that it only returns the
  vertex  simple  representations/modules  as  modules  over  [3XKQ[0m,  instead  of
  [3XKQ/(rels)[0m.
  
  [1X6.5-4 ZeroRepresentation[0m
  
  [2X> ZeroRepresentation( [0X[3XKQ, rels[0X[2X ) __________________________________[0Xoperation
  [6XReturns:[0X  the  zero  representation  over  a  quotient  of a path algebra [3XKQ[0m
            modulo the relations [3Xrels[0m.
  
  A shortcoming of the current implementation is that it only returns the zero
  representation as modules over [3XKQ[0m, instead of [3XKQ/(rels)[0m.
  
  
  [1X6.6 Functors on representations[0X
  
  [1X6.6-1 DualOfPathAlgebraMatModule[0m
  
  [2X> DualOfPathAlgebraMatModule( [0X[3XM[0X[2X ) _________________________________[0Xoperation
  
  Takes the a representation [3XM[0m of a path algebra $KQ$ and produces the dual of
  this  representation  over the opposite path algebra [3XKQ_op[0m. A shortcoming of
  this  function  is  that  it cannot have representation over a quotient of a
  path algebra as an argument.
  
  
  [1X6.7 Vertex Projective Presentations[0X
  
  In  general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a
  projective  module of $R$. Then we can form a direct sum of these projective
  modules  together  to  form larger projective module. One can construct more
  general modules by providing a [3Xvertex projective presentation[0m. In this case,
  $M$   is   the   cokernel   as   given  by  the  following  exact  sequence:
  $\oplus_{j=1}^{r}  w(j)R  \rightarrow  \oplus_{i=1}^{g} v(i)R \rightarrow{M}
  \rightarrow   0$   for   some   map  between  $\oplus_{j=1}^{r}  w(j)R$  and
  $\oplus_{i=1}^{g}  v(i)R$.  The  maps  $w$  and $v$ map the integers to some
  idempotent in $R$.
  
  [1X6.7-1 RightProjectiveModule[0m
  
  [2X> RightProjectiveModule( [0X[3XA, verts[0X[2X ) ________________________________[0Xfunction
  [6XReturns:[0X  the  right  projective  module  over  [3XA[0m which is the direct sum of
            projective  modules  of  the  form [3XvA[0m where the vertices are taken
            from the list of vertices [3Xverts[0m.
  
  In this implemenation the algebra can be a quotient of a path algebra. So if
  the  list  was  $[v,w]$  then  the module created will be the direct sum $vA
  \oplus  wA$,  in  that order. Elements of the modules are vectors of algebra
  elements,  and  in  each component, each path begins with the vertex in that
  position in the list of vertices. Right projective modules are implementated
  as   algebra   modules  (see  "ref:Representations  of  Algebras")  and  all
  operations  for  algebra modules are applicable to right projective modules.
  In particular, one can construct submodules using `SubAlgebraModule'.
  
  Here we create the right projective module $P = vA \oplus vA \oplus wA$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> F:=GF(11);[0X
    [4XGF(11)[0X
    [4Xgap> Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);[0X
    [4X<quiver with 3 vertices and 3 arrows>[0X
    [4Xgap> A:=PathAlgebra(F,Q);[0X
    [4X<algebra-with-one over GF(11), with 6 generators>[0X
    [4Xgap> P:=RightProjectiveModule(A,[A.v,A.v,A.w]);[0X
    [4X<right-module over <algebra-with-one over GF(11), with 6 generators>>[0X
    [4Xgap> Dimension(P);[0X
    [4X12[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-2 Vectorize[0m
  
  [2X> Vectorize( [0X[3XM, components[0X[2X ) _______________________________________[0Xfunction
  [6XReturns:[0X  a  vector  in  the  module  [3XM[0m from a list of path algebra elements
            [3Xcomponents[0m, which defines the components in the resulting vector.
  
  The  returned vector is normalized, so the vector's components may not match
  the input components.
  
  In  the  following  example,  we  create  two  elements in $P$, perform some
  elementwise  operations,  and  then  construct  a  submodule  using  the two
  elements as generators.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);[0X
    [4X[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ][0X
    [4Xgap> p2:=Vectorize(P,[A.a,A.b,A.w]);[0X
    [4X[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ][0X
    [4Xgap> 2*p1 + p2;[0X
    [4X[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ][0X
    [4Xgap> S:=SubAlgebraModule(P,[p1,p2]);[0X
    [4X<right-module over <algebra-with-one of dimension 8 over GF(11)>>[0X
    [4Xgap> Dimension(S);[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-3 ^[0m
  
  [2X> ^( [0X[3Xm, a[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X^[0m operates on an element [3Xm[0m in a module and an element [3Xa[0m in a
  path algebra, and it returns the element [3Xm[0m multiplied with [3Xa[0m. This action is
  defined by multiplying each component in [3Xm[0m by [3Xa[0m on the right.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p2^(A.c - A.w);[0X
    [4X[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, [0X
    [4X  (Z(11)^5)*w+(Z(11)^0)*c ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-4 <[0m
  
  [2X> <( [0X[3Xm1, m2[0X[2X ) _____________________________________________________[0Xoperation
  
  The  operation  [2X<[0m  operates  on  elements [3Xm1[0m and [3Xm2[0m in ????, and it compares
  them.  The  result  is  `true'  if  [3Xm1[0m  is less than [3Xm2[0m and false otherwise.
  Elements are compared componentwise from left to right using the ordering of
  the  underlying  algebra.  The  element [3Xm1[0m is less than [3Xm2[0m if the first time
  components are not equal, the component of [3Xm1[0m is less than the corresponding
  component of [3Xm2[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1 < p2;[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-5 /[0m
  
  [2X> /( [0X[3XM, N[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X/[0m  operates on two finite dimensional modules [3XM[0m and [3XN[0m over a
  path  algebra?,  and  it  constructs the factor module $M/N$. This module is
  again  a right algebra module, and all applicable methods and operations are
  available for the resulting factor module. Furthermore, the resulting module
  is a vector space, so operations for computing bases and dimensions are also
  available.
  
  This
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> PS := P/S;[0X
    [4X<9-dimensional right-module over <algebra-with-one of dimension[0X
    [4X8 over GF(11)>> [0X
    [4Xgap> Basis(PS);[0X
    [4XBasis( <9-dimensional right-module over <algebra-with-one of dimension [0X
    [4X8 over GF(11)>>, [ [ [ <zero> of ..., <zero> of ...,[0X
    [4X(Z(11)^0)*w ] ],  [0X
    [4X  [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b*c, <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ] ] )[0X
  [4X------------------------------------------------------------------[0X
  
