  
  [1X6 Right Modules over Path Algebras[0X
  
  There are two implementations of right modules over path algebras. The first
  type  are  matrix  modules  that  are  defined  by  vector spaces and linear
  transformations.  The  second  type  are  presentations  defined  by  vertex
  projective modules.
  
  
  [1X6.1 Matrix Modules[0X
  
  The first implementation of right modules over path algebras views them as a
  collection  of  vector spaces and linear transformations. Each vertex in the
  path  algebra  is  associated  with  a  vector  space  over the field of the
  algebra.  For  each  vertex  $v$ of the algebra there is a vector space $V$.
  Arrows  of the algebra are then associated with linear transformations which
  map  the vector space of the source vertex to the vector space of the target
  vertex.  For  example,  if  $a$  is an arrow from $v$ to $w$ then there is a
  transformation  from  vector space $V$ to $W$. In practice when creating the
  modules  all  we  need  to know is the transformations and we can create the
  vector  spaces  of  the  correct  dimension,  and  check  to  make  sure the
  dimensions all agree. We can create a module in this way as follows.
  
  [1X6.1-1 RightModuleOverPathAlgebra[0m
  
  [2X> RightModuleOverPathAlgebra( [0X[3XA, mats[0X[2X ) ___________________________[0Xoperation
  [2X> RightModuleOverPathAlgebra( [0X[3XA, dim_vector, gens[0X[2X ) _______________[0Xoperation
  
  Arguments:  [3XA[0m -- a (quotient of a) path algebra, [3Xmats[0m -- a list of matrices,
  [3Xdim_vector[0m -- the dimension vector of the module, [3Xgens[0m -- a list of elements
  (generators). For further explanations, see below.
  
  [6XReturns:[0X  a  module over a path algebra or over a qoutient of a path algebra
            in the second variant.
  
  In  the  first  function  call,  the list of matrices [3Xmats[0m can take on three
  different forms.
  
  1) The argument [3Xmats[0m can be a list of blocks of matrices where each block is
  of  the  form,  `["name of arrow",matrix]'. So if you named your arrows when
  you  created  the  quiver,  then  you can associate a matrix with that arrow
  explicitly.
  
  2)  The  argument  [3Xmats[0m is just a list of matrices, and the matrices will be
  associated  to  the  arrows in the order of arrow creation. If when creating
  the  quiver,  the  arrow $a$ was created first, then $a$ would be associated
  with the first matrix.
  
  3)  The  method  is  very much the same as the second method. If [3Xarrows[0m is a
  list  of  the  arrows of the quiver (obtained for instance through [10Xarrows :=
  ArrowsOfQuiver(Q);[0m),    the    argument    [3Xmats[0m    can   have   the   format
  [10X[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].[0m
  
  If  you  would  like  the  trivial vector space at any vertex, then for each
  incoming arrow "a", associate it with a list of the form [10X["a",[n,0]][0m where n
  is  the  dimension  of  the  vector space at the source vertex of the arrow.
  Likewise  for  all  outgoing  arrows  "b", associate them to a block of form
  [10X["b",[0,n]][0m  where  n  is  the  dimension  of the vector space at the target
  vertex of the arrow.
  
  A  warning  though,  the  function assumes that you do not mix the styles of
  inputting  the  matrices/linear  transformations associated to the arrows in
  the quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise
  an  error will be returned. The function verifies that the dimensions of the
  matrices  and  vector  spaces are correct and match, and that each arrow has
  only one matrix assigned to it.
  
  In the second function call, the second argument [3Xdim_vector[0m is the dimension
  vector of the module, and the last argument [3Xgens[0m (maybe an empty list []) is
  a  list of elements of the form ["label",matrix]. This function constructs a
  right  module  over  a  (quotient of a) path algebra [3XA[0m with dimension vector
  [3Xdim_vector[0m,  and where the generators/arrows with a non-zero action is given
  in    the    list    [3Xgens[0m.    The    format    of    the    list   [3Xgens[0m   is
  [["a",[matrix_a]],["b",[matrix_b]],...],  where  "a"  and  "b" are labels of
  arrows  used  when  the  underlying  quiver  was created and matrix_? is the
  action of the algebra element corresponding to the arrow with label "?". The
  action of the arrows can be entered in any order. The function checks if the
  algebra  [3XA[0m  is  a  (quotient  of  a) path algebra and if the matrices of the
  action of the arrows have the correct size according to the dimension vector
  entered and also whether or not the relations of the algebra are satisfied.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap&gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); [0X
    [4X&lt;quiver with 2 vertices and 3 arrows&gt;[0X
    [4Xgap&gt; P := PathAlgebra(Rationals, Q);[0X
    [4X&lt;algebra-with-one over Rationals, with 5 generators&gt;[0X
    [4Xgap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X&gt; ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap&gt; M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt; [0X
    [4Xgap&gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; [0X
    [4Xgap&gt; N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt; [0X
    [4Xgap&gt; arrows := ArrowsOfQuiver(Q);[0X
    [4X[ a, b, c ][0X
    [4Xgap&gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], [0X
    [4X&gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;[0X
    [4Xgap&gt; N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt;[0X
    [4Xgap&gt; # Next we give the vertex simple associate to vertex 1. [0X
    [4Xgap&gt; M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4X					generators&gt;&gt; [0X
    [4Xgap&gt; # Finally, the next defines the zero representation of the quiver.[0X
    [4Xgap&gt; M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4X					generators&gt;&gt; [0X
    [4Xgap&gt; Dimension(M);[0X
    [4X0[0X
    [4Xgap&gt; Basis(M);[0X
    [4XBasis( &lt;[0X
    [4X0-dimensional right-module over &lt;algebra-with-one over Rationals, with [0X
    [4X5 generators&gt;&gt;, [  ] )[0X
    [4Xgap> # Using the above example.  [0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",[0X
    [4X[[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], [0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,[2,3],matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5 generators>>[0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,[2,3],[]);      [0X
    [4X<right-module over <algebra-with-one over Rationals, with 5 generators>>[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.2 Categories Of Matrix Modules[0X
  
  [1X6.2-1 IsPathAlgebraMatModule[0m
  
  [2X> IsPathAlgebraMatModule( [0X[3Xobject[0X[2X ) ___________________________________[0Xfilter
  [6XReturns:[0X  true  or false depending on whether [3Xobject[0m belongs to the category
            [10XIsPathAlgebraMatModule[0m.
  
  These  matrix  modules  fall  under  the category `IsAlgebraModule' with the
  added  filter  of `IsPathAlgebraMatModule'. Operations available for algebra
  modules  can be applied to path algebra modules. See "ref:representations of
  algebras"  for  more  details. These modules are also vector spaces over the
  field  of the path algebra. So refer to "ref:vector spaces" for descriptions
  of the basis and elementwise operations available.
  
  
  [1X6.3 Acting on Module Elements[0X
  
  [1X6.3-1 ^[0m
  
  [2X> ^( [0X[3Xm, p[0X[2X ) _______________________________________________________[0Xoperation
  
  Arguments: [3Xm[0m -- an element in a module, [3Xp[0m -- a path in a path algebra.
  
  [6XReturns:[0X  the element [3Xm[0m multiplied with [3Xp[0m.
  
  When  you  act on an module element $m$ by an arrow $a$ from $v$ to $w$, the
  component  of  $m$ from $V$ is acted on by $L$ the transformation associated
  to  $a$  and placed in the component $W$. All other components are given the
  value $0$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # Using the path algebra P from the above example. [0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X> ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>> [0X
    [4Xgap> B:=BasisVectors(Basis(M));[0X
    [4X[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 0, 0, 1 ] ] ][0X
    [4Xgap> B[1]+B[3];[0X
    [4X[ [ 1, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> 4*B[2];[0X
    [4X[ [ 0, 4 ], [ 0, 0, 0 ] ][0X
    [4Xgap> m:=5*B[1]+2*B[4]+B[5];[0X
    [4X[ [ 5, 0 ], [ 0, 2, 1 ] ][0X
    [4Xgap> m^(P.a*P.b-P.c);[0X
    [4X[ [ 0, 5 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[1]^P.a;[0X
    [4X[ [ 0, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> B[2]^P.b;[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[4]^(P.b*P.c);[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.4 Operations on representations[0X
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);[0X
    [4X<quiver with 3 vertices and 5 arrows>[0X
    [4Xgap> KQ := PathAlgebra(Rationals, Q);[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> gens := GeneratorsOfAlgebra(KQ);[0X
    [4X[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ][0X
    [4Xgap> u := gens[1];; v := gens[2];;[0X
    [4Xgap> w := gens[3];; a := gens[4];;[0X
    [4Xgap> b := gens[5];; c := gens[6];;[0X
    [4Xgap> d := gens[7];; e := gens[8];;[0X
    [4Xgap> rels := [d*e,c^2,a*c*d-b*d,e*a];;[0X
    [4Xgap> I:= Ideal(KQ,rels);;[0X
    [4Xgap> gb:= GBNPGroebnerBasis(rels,KQ);;[0X
    [4Xgap> gbb:= GroebnerBasis(I,gb);;[0X
    [4Xgap> A:= KQ/I;[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],[0X
    [4X["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;[0X
    [4Xgap> N:= RightModuleOverPathAlgebra(A,mat);                         [0X
    [4X<right-module over <algebra-with-one over Rationals, with 8 generators>>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.4-1 AnnihilatorOfModule[0m
  
  [2X> AnnihilatorOfModule( [0X[3XM[0X[2X ) ________________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module.
  
  [6XReturns:[0X  a  basis  of  the  annihilator  of  the  module  [3XM[0m  in  the finite
            dimensional algebra over which [3XM[0m is a module.
  
  [1X6.4-2 CommonDirectSummand[0m
  
  [2X> CommonDirectSummand( [0X[3XM, N[0X[2X ) _____________________________________[0Xoperation
  
  Arguments: [3XM[0m and [3XN[0m -- two path algebra modules.
  
  [6XReturns:[0X  a  list of four modules [[3XX[0m,[3XU[0m,[3XX[0m, [3XV[0m], where [3XX[0m is one common non-zero
            direct  summand of [3XM[0m and [3XN[0m, the sum of [3XX[0m and [3XU[0m is [3XM[0m and the sum of
            [3XX[0m  and [3XV[0m is [3XN[0m, if such a non-zero direct summand exists. Otherwise
            it returns false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-3 DecomposeModule[0m
  
  [2X> DecomposeModule( [0X[3XM[0X[2X ) ____________________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module.
  
  [6XReturns:[0X  a list of indecomposable modules whose direct sum is isomorphic to
            the module [3XM[0m.
  
  Warning:  the  function  is  not  properly  tested and it at best only works
  properly over finite fields.
  
  [1X6.4-4 DecomposeModuleWithMultiplicities[0m
  
  [2X> DecomposeModuleWithMultiplicities( [0X[3XM[0X[2X ) __________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module.
  
  [6XReturns:[0X  a  list  of  length  two,  where  the first entry is a list of all
            indecomposable  non-isomorphic direct summands of [3XM[0m and the second
            entry is the list of the multiplicities of these direct summand in
            the module [3XM[0m.
  
  Warning:  the  function  is  not  properly  tested and it at best only works
  properly over finite fields.
  
  [1X6.4-5 Dimension[0m
  
  [2X> Dimension( [0X[3XM[0X[2X ) __________________________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the dimension of the representation [3XM[0m.
  
  [1X6.4-6 DimensionVector[0m
  
  [2X> DimensionVector( [0X[3XM[0X[2X ) ____________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the dimension vector of the representation [3XM[0m.
  
  [1X6.4-7 DirectSumOfModules[0m
  
  [2X> DirectSumOfModules( [0X[3XL[0X[2X ) _________________________________________[0Xoperation
  
  Arguments:  [3XL[0m  -- a list of [10XPathAlgebraMatModule[0ms over the same (quotient of
  a) path algebra.
  
  [6XReturns:[0X  the direct sum of the representations contained in the list [3XL[0m.
  
  In    addition    three    attributes    are   attached   to   the   result,
  [10XIsDirectSumOfModules, DirectSumProjections[0m and [10XDirectSumInclusions[0m.
  
  [1X6.4-8 DirectSumInclusions[0m
  
  [2X> DirectSumInclusions( [0X[3XM[0X[2X ) ________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the list of inclusions from the individual modules to their direct
            sum,    when   a   direct   sum   has   been   constructed   using
            [10XDirectSumOfModules[0m.
  
  [1X6.4-9 DirectSumProjections[0m
  
  [2X> DirectSumProjections( [0X[3XM[0X[2X ) _______________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the  list  of  projections  from  the direct sum to the individual
            modules  used  to construct direct sum, when a direct sum has been
            constructed using [10XDirectSumOfModules[0m.
  
  [1X6.4-10 IsDirectSummand[0m
  
  [2X> IsDirectSummand( [0X[3XM, N[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3XM, N[0m -- two path algebra modules ([10XPathAlgebraMatModule[0ms).
  
  [6XReturns:[0X  true if [3XM[0m is isomorphic to a direct summand of [3XN[0m, otherwise false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-11 IsDirectSumOfModules[0m
  
  [2X> IsDirectSumOfModules( [0X[3XM[0X[2X ) _______________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  true if [3XM[0m is constructed via the command [10XDirectSumOfModules[0m.
  
  Using the example above.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> N2:=DirectSumOfModules([N,N]);[0X
    [4X<14-dimensional right-module over <algebra-with-one of dimension [0X
    [4X17 over Rationals>>[0X
    [4Xgap> proj:=DirectSumProjections(N2);[0X
    [4X[ <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> >, [0X
    [4X  <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> > ][0X
    [4Xgap> inc:=DirectSumInclusions(N2);  [0X
    [4X[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> >, [0X
    [4X  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> > ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.4-12 1stSyzygy[0m
  
  [2X> 1stSyzygy( [0X[3XM[0X[2X ) __________________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the first syzygy of the representation [3XM[0m as a representation.
  
  [1X6.4-13 IntersectionOfSubmodules[0m
  
  [2X> IntersectionOfSubmodules( [0X[3Xlist[0X[2X ) ________________________________[0Xoperation
  
  Arguments:  [3Xf,  g[0m or [3Xlist[0m -- two homomorphisms of PathAlgebraMatModules or a
  list of such.
  
  [6XReturns:[0X  the  subrepresentation  given  by  the  intersection  of  all  the
            submodules given by the inclusions [3Xf, g[0m or [3Xlist[0m.
  
  The  function  checks  if  [3Xlist[0m  is  non-empty  and  if $[3Xf[0m\colon M\to X$ and
  $[3Xg[0m\colon  N\to X$ or all the homomorphism in [3Xlist[0m have the same range and if
  they  all  are  inclusions.  If the function is given two arguments [3Xf[0m and [3Xg[0m,
  then  it returns $[f',g',g'*f]$, where $f'\colon E\to N$, $g'\colon E\to M$,
  $E$  is  the  pullback  of  [3Xf[0m  and  [3Xg[0m. For a list of inclusions it returns a
  monomorphism from a module isomorphic to the intersection to $X$.
  
  [1X6.4-14 IsInAdditiveClosure[0m
  
  [2X> IsInAdditiveClosure( [0X[3XM, N[0X[2X ) _____________________________________[0Xoperation
  
  Arguments: [3XM, N[0m -- two path algebra modules ([10XPathAlgebraMatModule[0ms).
  
  [6XReturns:[0X  true  if  [3XM[0m  is in the additive closure of the module [3XN[0m, otherwise
            false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-15 IsOmegaPeriodic[0m
  
  [2X> IsOmegaPeriodic( [0X[3XM, n[0X[2X ) _________________________________________[0Xoperation
  
  Arguments:  [3XM[0m  --  a  path  algebra module ([10XPathAlgebraMatModule[0m), [3Xn[0m -- be a
  positive integer.
  
  [6XReturns:[0X  [10Xi[0m,  where  [10Xi[0m is the smallest positive integer less or equal [10Xn[0m such
            that  the  representation [3XM[0m is isomorphic to the [10Xi[0m-th syzygy of [3XM[0m,
            and false otherwise.
  
  [1X6.4-16 IsInjectiveModule[0m
  
  [2X> IsInjectiveModule( [0X[3XM[0X[2X ) ___________________________________________[0Xproperty
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  true if the representation [3XM[0m is injective.
  
  [1X6.4-17 IsProjectiveModule[0m
  
  [2X> IsProjectiveModule( [0X[3XM[0X[2X ) __________________________________________[0Xproperty
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  true if the representation [3XM[0m is projective.
  
  [1X6.4-18 IsSemisimpleModule[0m
  
  [2X> IsSemisimpleModule( [0X[3XM[0X[2X ) __________________________________________[0Xproperty
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  true if the representation [3XM[0m is semisimple.
  
  [1X6.4-19 IsSimpleModule[0m
  
  [2X> IsSimpleModule( [0X[3XM[0X[2X ) ______________________________________________[0Xproperty
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  true if the representation [3XM[0m is simple.
  
  [1X6.4-20 LoewyLength[0m
  
  [2X> LoewyLength( [0X[3XM[0X[2X ) ________________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the Loewy length of the module [3XM[0m.
  
  The  function checks that the module [3XM[0m is a module over a finite dimensional
  quotient  of  a  path  algebra,  and  returns  fail  otherwise  (This is not
  implemented yet).
  
  [1X6.4-21 MaximalCommonDirectSummand[0m
  
  [2X> MaximalCommonDirectSummand( [0X[3XM, N[0X[2X ) ______________________________[0Xoperation
  
  Arguments: [3XM, N[0m -- two path algebra modules ([10XPathAlgebraMatModule[0ms).
  
  [6XReturns:[0X  a  list  of  three  modules  [[3XX[0m,[3XU[0m,[3XV[0m],  where [3XX[0m is a maximal common
            non-zero  direct  summand  of [3XM[0m and [3XN[0m, the sum of [3XX[0m and [3XU[0m is [3XM[0m and
            the sum of [3XX[0m and [3XV[0m is [3XN[0m, if such a non-zero maximal direct summand
            exists. Otherwise it returns false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-22 IsomorphicModules[0m
  
  [2X> IsomorphicModules( [0X[3XM, N[0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3XM, N[0m -- two path algebra modules ([10XPathAlgebraMatModule[0ms).
  
  [6XReturns:[0X  true or false depending on whether [3XM[0m and [3XN[0m are isomorphic or not.
  
  The  function  first checks if the modules [3XM[0m and [3XN[0m are modules over the same
  algebra,  and  returns fail if not. The function returns true if the modules
  are isomorphic, otherwise false.
  
  [1X6.4-23 MinimalGeneratingSetOfModule[0m
  
  [2X> MinimalGeneratingSetOfModule( [0X[3XM[0X[2X ) _______________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  a  minimal  generator  set of the module [3XM[0m as a module of the path
            algebra it is defined over.
  
  [1X6.4-24 MatricesOfPathAlgebraModule[0m
  
  [2X> MatricesOfPathAlgebraModule( [0X[3XM[0X[2X ) ________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  a  list  of  the  matrices  that defines the representation [3XM[0m as a
            right module of the acting path algebra.
  
  The  list  of  matrices  that are returned are not the same identical to the
  matrices  entered to define the representation if there is zero vector space
  in  at  least  one  vertex.  Then  zero matrices of the appropriate size are
  returned.  A  shortcoming  of  this  that  it  is not defined for modules of
  quotients of path algebras.
  
  [1X6.4-25 NthSyzygy[0m
  
  [2X> NthSyzygy( [0X[3XM, n[0X[2X ) _______________________________________________[0Xoperation
  
  Arguments:  [3XM[0m  --  a  path  algebra  module  ([10XPathAlgebraMatModule[0m),  [3Xn[0m -- a
  positive integer.
  
  [6XReturns:[0X  the  top  of the syzygies until a syzygy is projective or the [3Xn[0m-th
            syzygy has been computed.
  
  [1X6.4-26 NthSyzygyNC[0m
  
  [2X> NthSyzygyNC( [0X[3XM, n[0X[2X ) _____________________________________________[0Xoperation
  
  Arguments:  [3XM[0m  --  a  path  algebra  module  ([10XPathAlgebraMatModule[0m),  [3Xn[0m -- a
  positive integer.
  
  [6XReturns:[0X  the  [10Xn[0m-th  syzygy of the module [3XM[0m, unless the projective dimension
            of  [3XM[0m  is  less  or  equal  to  [10Xn-1[0m,  in which case it returns the
            projective dimension of [3XM[0m. It does not check if the [10Xn[0m-th syzygy is
            projective or not.
  
  [1X6.4-27 RadicalOfModule[0m
  
  [2X> RadicalOfModule( [0X[3XM[0X[2X ) ____________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the radical of the module [3XM[0m.
  
  This  returns  only the representation given by the radical of the module [3XM[0m.
  The  operation  [2XRadicalOfModuleInclusion[0m  ([14X7.3-19[0m) computes the inclusion of
  the radical of [3XM[0m into [3XM[0m.
  
  [1X6.4-28 RadicalSeries[0m
  
  [2X> RadicalSeries( [0X[3XM[0X[2X ) ______________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the radical series of the module [3XM[0m.
  
  The  function  gives  the radical series as a list of vectors [10X[n_1,...,n_s][0m,
  where  the  algebra  has  $s$  isomorphism classes of simple modules and the
  numbers  give  the  multiplicity  of  each  simple.  The first vector listed
  corresponds to the top layer, and so on.
  
  [1X6.4-29 SocleSeries[0m
  
  [2X> SocleSeries( [0X[3XM[0X[2X ) ________________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the socle series of the module [3XM[0m.
  
  The  function  gives  the  socle  series as a list of vectors [10X[n_1,...,n_s][0m,
  where  the  algebra  has  $s$  isomorphism classes of simple modules and the
  numbers  give  the  multiplicity  of  each  simple.  The  last vector listed
  corresponds to the socle layer, and so on backwards.
  
  [1X6.4-30 SocleOfModule[0m
  
  [2X> SocleOfModule( [0X[3XM[0X[2X ) ______________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the socle of the module [3XM[0m.
  
  This  operation  only  return  the  representation given by the socle of the
  module  [3XM[0m.  The  inclusion  the  socle  of  [3XM[0m  into  [3XM[0m can be computed using
  [2XSocleOfModuleInclusion[0m ([14X7.3-20[0m).
  
  [1X6.4-31 SubRepresentation[0m
  
  [2X> SubRepresentation( [0X[3XM, gens[0X[2X ) ____________________________________[0Xoperation
  
  Arguments:  [3XM[0m  --  a  path  algebra  module  ([10XPathAlgebraMatModule[0m), [3Xgens[0m --
  elements in [3XM[0m.
  
  [6XReturns:[0X  the submodule of the module [3XM[0m generated by the elements [3Xgens[0m.
  
  The  function checks if [3Xgens[0m are elements in [3XM[0m, and returns an error message
  otherwise.  The  inclusion  of  the submodule generated by the elements [3Xgens[0m
  into [3XM[0m can be computed using [2XSubRepresentationInclusion[0m ([14X7.3-21[0m).
  
  [1X6.4-32 SumOfSubmodules[0m
  
  [2X> SumOfSubmodules( [0X[3Xlist[0X[2X ) _________________________________________[0Xoperation
  
  Arguments:  [3Xf,  g[0m or [3Xlist[0m -- two homomorphisms of PathAlgebraMatModules or a
  list of such.
  
  [6XReturns:[0X  the subrepresentation given by the sum of all the submodules given
            by the inclusions [3Xf, g[0m or [3Xlist[0m.
  
  The  function  checks  if  [3Xlist[0m  is  non-empty  and  if $[3Xf[0m\colon M\to X$ and
  $[3Xg[0m\colon  N\to X$ or all the homomorphism in [3Xlist[0m have the same range and if
  they  all  are  inclusions.  If the function is given two arguments [3Xf[0m and [3Xg[0m,
  then  it returns $[h,f',g']$, where $h\colon M + N\to X$, $f'\colon M\to M +
  N$  and  $g'\colon  N\to  M  +  N$.  For  a  list of inclusions it returns a
  monomorphism  from  a module isomorphic to the sum of the subrepresentations
  to $X$.
  
  [1X6.4-33 SupportModuleElement[0m
  
  [2X> SupportModuleElement( [0X[3Xm[0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3Xm[0m -- an element of a path algebra module.
  
  [6XReturns:[0X  the  primitive  idempotents [3Xv[0m in the algebra over which the module
            containing the element [3Xm[0m is a module, such that [3Xm^v[0m is non-zero.
  
  The  function  checks  if [3Xm[0m is an element in a module over a (quotient of a)
  path algebra, and returns fail otherwise.
  
  [1X6.4-34 TopOfModule[0m
  
  [2X> TopOfModule( [0X[3XM[0X[2X ) ________________________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module ([10XPathAlgebraMatModule[0m).
  
  [6XReturns:[0X  the top of the module [3XM[0m.
  
  This  returns  only the representation given by the top of the module [3XM[0m. The
  operation  [2XTopOfModuleProjection[0m  ([14X7.3-22[0m)  computes  the  projection of the
  module [3XM[0m onto the top of the module [3XM[0m.
  
  
  [1X6.5 Special representations[0X
  
  Here  we  collect  the  predefined  representations/modules  over  a  finite
  dimensional quotient of a path algebra.
  
  [1X6.5-1 BasisOfProjectives[0m
  
  [2X> BasisOfProjectives( [0X[3XA[0X[2X ) _________________________________________[0Xoperation
  
  Arguments: [3XA[0m -- a finite dimensional (quotient of a) path algebra.
  
  [6XReturns:[0X  a   list   of   bases   for   all  the  indecomposable  projective
            representations   over   [3XA[0m.  The  basis  for  each  indecomposable
            projective is given a list of elements in nontips in [3XA[0m.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-2 IndecInjectiveModules[0m
  
  [2X> IndecInjectiveModules( [0X[3XA[0X[2X ) ______________________________________[0Xattribute
  
  Arguments:  [3XA[0m  --  a  finite  dimensional  (quotient  of  a)  path  algebra,
  (optional) [3Xlist[0m -- a list of integers.
  
  [6XReturns:[0X  a   list   of  all  the  non-isomorphic  indecomposable  injective
            representations over [3XA[0m.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-3 IndecProjectiveModules[0m
  
  [2X> IndecProjectiveModules( [0X[3XA[0X[2X ) _____________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a finite dimensional (quotient of a) path algebra.
  
  [6XReturns:[0X  a   list  of  all  the  non-isomorphic  indecomposable  projective
            representations over [3XA[0m.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-4 SimpleModules[0m
  
  [2X> SimpleModules( [0X[3XA[0X[2X ) ______________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a finite dimensional (quotient of a) path algebra.
  
  [6XReturns:[0X  a list of all the simple representations over [3XA[0m .
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-5 ZeroModule[0m
  
  [2X> ZeroModule( [0X[3XA[0X[2X ) _________________________________________________[0Xattribute
  
  Arguments: [3XA[0m -- a finite dimensional (quotient of a) path algebra.
  
  [6XReturns:[0X  the zero representation over [3XA[0m .
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  
  [1X6.6 Functors on representations[0X
  
  [1X6.6-1 DualOfModule[0m
  
  [2X> DualOfModule( [0X[3XM[0X[2X ) _______________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a representation of a path algebra $KQ$.
  
  [6XReturns:[0X  the dual of [3XM[0m over the opposite path algebra [3XKQ_op[0m.
  
  [1X6.6-2 DualOfModuleHomomorphism[0m
  
  [2X> DualOfModuleHomomorphism( [0X[3Xf[0X[2X ) ___________________________________[0Xattribute
  
  Arguments:  [3Xf[0m  --  a  map  between  two  representations [3XM[0m and [3XN[0m over a path
  algebra $A$.
  
  [6XReturns:[0X  the dual of this map over the opposite path algebra [3XA^op[0m.
  
  [1X6.6-3 DTr[0m
  
  [2X> DTr( [0X[3XM[, n][0X[2X ) ___________________________________________________[0Xoperation
  [2X> DualOfTranspose( [0X[3XM[, n][0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module, (optional) [3Xn[0m -- an integer.
  
  [6XReturns:[0X  the dual of the transpose of [3XM[0m when called with only one argument,
            while  it  returns  the dual of the transpose applied to [3XM[0m [3Xn[0m times
            otherwise.  If  [3Xn[0m  is  negative,  then powers of [10XTrD[0m are computed.
            [2XDualOfTranspose[0m is a synonym for [2XDTr[0m.
  
  [1X6.6-4 TrD[0m
  
  [2X> TrD( [0X[3XM[, n][0X[2X ) ___________________________________________________[0Xoperation
  [2X> TransposeOfDual( [0X[3XM[, n][0X[2X ) _______________________________________[0Xoperation
  
  Arguments: [3XM[0m -- a path algebra module, (optional) [3Xn[0m -- an integer.
  
  [6XReturns:[0X  the transpose of the dual of [3XM[0m when called with only one argument,
            while  it  returns  the transpose of the dual applied to [3XM[0m [3Xn[0m times
            otherwise.  If  [3Xn[0m  is  negative,  then powers of [10XTrD[0m are computed.
            [2XTransposeOfDual[0m is a synonym for [2XTrD[0m.
  
  [1X6.6-5 TransposeOfModule[0m
  
  [2X> TransposeOfModule( [0X[3XM[0X[2X ) __________________________________________[0Xattribute
  
  Arguments: [3XM[0m -- a path algebra module.
  
  [6XReturns:[0X  the transpose of the module [3XM[0m.
  
  
  [1X6.7 Vertex Projective Presentations[0X
  
  In  general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a
  projective  module of $R$. Then we can form a direct sum of these projective
  modules  together  to  form larger projective module. One can construct more
  general modules by providing a [3Xvertex projective presentation[0m. In this case,
  $M$   is   the   cokernel   as   given  by  the  following  exact  sequence:
  $\oplus_{j=1}^{r}  w(j)R  \rightarrow  \oplus_{i=1}^{g} v(i)R \rightarrow{M}
  \rightarrow   0$   for   some   map  between  $\oplus_{j=1}^{r}  w(j)R$  and
  $\oplus_{i=1}^{g}  v(i)R$.  The  maps  $w$  and $v$ map the integers to some
  idempotent in $R$.
  
  [1X6.7-1 RightProjectiveModule[0m
  
  [2X> RightProjectiveModule( [0X[3XA, verts[0X[2X ) ________________________________[0Xfunction
  
  Arguments: [3XA[0m -- a (quotient of a) path algebra, [3Xverts[0m -- a list of vertices.
  
  [6XReturns:[0X  the  right  projective  module  over  [3XA[0m which is the direct sum of
            projective  modules  of  the  form [3XvA[0m where the vertices are taken
            from [3Xverts[0m.
  
  In  this  implementation the algebra can be a quotient of a path algebra. So
  if  the  list was $[v,w]$ then the module created will be the direct sum $vA
  \oplus  wA$,  in  that order. Elements of the modules are vectors of algebra
  elements,  and  in  each component, each path begins with the vertex in that
  position in the list of vertices. Right projective modules are implementated
  as   algebra   modules  (see  "ref:Representations  of  Algebras")  and  all
  operations  for  algebra modules are applicable to right projective modules.
  In particular, one can construct submodules using `SubAlgebraModule'.
  
  Here we create the right projective module $P = vA \oplus vA \oplus wA$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> F:=GF(11);[0X
    [4XGF(11)[0X
    [4Xgap> Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);[0X
    [4X<quiver with 3 vertices and 3 arrows>[0X
    [4Xgap> A:=PathAlgebra(F,Q);[0X
    [4X<algebra-with-one over GF(11), with 6 generators>[0X
    [4Xgap> P:=RightProjectiveModule(A,[A.v,A.v,A.w]);[0X
    [4X<right-module over <algebra-with-one over GF(11), with 6 generators>>[0X
    [4Xgap> Dimension(P);[0X
    [4X12[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-2 Vectorize[0m
  
  [2X> Vectorize( [0X[3XM, components[0X[2X ) _______________________________________[0Xfunction
  
  Arguments:  [3XM[0m  --  a  module  over  a  path algebra, [3Xcomponents[0m -- a list of
  elements of [3XM[0m.
  
  [6XReturns:[0X  a  vector  in  [3XM[0m  from a list of path algebra elements [3Xcomponents[0m,
            which defines the components in the resulting vector.
  
  The  returned vector is normalized, so the vector's components may not match
  the input components.
  
  In  the  following  example,  we  create  two  elements in $P$, perform some
  elementwise  operations,  and  then  construct  a  submodule  using  the two
  elements as generators.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);[0X
    [4X[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ][0X
    [4Xgap> p2:=Vectorize(P,[A.a,A.b,A.w]);[0X
    [4X[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ][0X
    [4Xgap> 2*p1 + p2;[0X
    [4X[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ][0X
    [4Xgap> S:=SubAlgebraModule(P,[p1,p2]);[0X
    [4X<right-module over <algebra-with-one of dimension 8 over GF(11)>>[0X
    [4Xgap> Dimension(S);[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-3 ^[0m
  
  [2X> ^( [0X[3Xm, a[0X[2X ) _______________________________________________________[0Xoperation
  
  Arguments:  [3Xm[0m  --  an element of a path algebra module, [3Xa[0m -- an element of a
  path algebra.
  
  [6XReturns:[0X  the element [3Xm[0m multiplied with [3Xa[0m.
  
  This action is defined by multiplying each component in [3Xm[0m by [3Xa[0m on the right.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p2^(A.c - A.w);[0X
    [4X[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, [0X
    [4X  (Z(11)^5)*w+(Z(11)^0)*c ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-4 <[0m
  
  [2X> <( [0X[3Xm1, m2[0X[2X ) _____________________________________________________[0Xoperation
  
  Arguments: [3Xm1, m2[0m -- two elements of a module over a path algebra (?).
  
  [6XReturns:[0X  `true' if [3Xm1[0m is less than [3Xm2[0m and false otherwise.
  
  Elements are compared componentwise from left to right using the ordering of
  the  underlying  algebra.  The  element [3Xm1[0m is less than [3Xm2[0m if the first time
  components are not equal, the component of [3Xm1[0m is less than the corresponding
  component of [3Xm2[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1 < p2;[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-5 /[0m
  
  [2X> /( [0X[3XM, N[0X[2X ) _______________________________________________________[0Xoperation
  
  Arguments: [3XM, N[0m -- two finite dimensional modules over a path algebra (?).
  
  [6XReturns:[0X  the factor module $M/N$.
  
  This  module is again a right algebra module, and all applicable methods and
  operations  are  available for the resulting factor module. Furthermore, the
  resulting  module  is  a vector space, so operations for computing bases and
  dimensions are also available.
  
  This
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> PS := P/S;[0X
    [4X<9-dimensional right-module over <algebra-with-one of dimension[0X
    [4X8 over GF(11)>> [0X
    [4Xgap> Basis(PS);[0X
    [4XBasis( <9-dimensional right-module over <algebra-with-one of dimension [0X
    [4X8 over GF(11)>>, [ [ [ <zero> of ..., <zero> of ...,[0X
    [4X(Z(11)^0)*w ] ],  [0X
    [4X  [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b*c, <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ] ] )[0X
  [4X------------------------------------------------------------------[0X
  
