  
  [1X6 Right Modules over Path Algebras[0X
  
  There are two implementations of right modules over path algebras. The first
  type  are  matrix  modules  that  are  defined  by  vector spaces and linear
  transformations.  The  second  type  are  presentations  defined  by  vertex
  projective modules.
  
  
  [1X6.1 Matrix Modules[0X
  
  The first implementation of right modules over path algebras views them as a
  collection  of  vector spaces and linear transformations. Each vertex in the
  path  algebra  is  associated  with  a  vector  space  over the field of the
  algebra.  For  each  vertex  $v$ of the algebra there is a vector space $V$.
  Arrows  of the algebra are then associated with linear transformations which
  map  the vector space of the source vertex to the vector space of the target
  vertex.  For  example,  if  $a$  is an arrow from $v$ to $w$ then there is a
  transformation  from  vector space $V$ to $W$. In practice when creating the
  modules  all  we  need  to know is the transformations and we can create the
  vector  spaces  of  the  correct  dimension,  and  check  to  make  sure the
  dimensions all agree. We can create a module in this way as follows.
  
  [1X6.1-1 RightModuleOverPathAlgebra[0m
  
  [2X> RightModuleOverPathAlgebra( [0X[3XA, mats[0X[2X ) ___________________________[0Xoperation
  [2X> RightModuleOverQuotientOfPathAlgebra( [0X[3XA, mats[0X[2X ) _________________[0Xoperation
  [6XReturns:[0X  a module over a path algebra in the first variant, a module over a
            qoutient of a path algebra in the second variant.
  
  In  the  function  call,  [3XA[0m  is a (quotient of a ) path algebra. The list of
  matrices [3Xmats[0m can take on three different forms.
  
  1) The argument [3Xmats[0m can be a list of blocks of matrices where each block is
  of  the  form,  `["name of arrow",matrix]'. So if you named your arrows when
  you  created  the  quiver,  then  you can associate a matrix with that arrow
  explicitly.
  
  2)  The  argument  [3Xmats[0m is just a list of matrices, and the matrices will be
  associated  to  the  arrows in the order of arrow creation. If when creating
  the  quiver,  the  arrow $a$ was created first, then $a$ would be associated
  with the first matrix.
  
  3)  The  method  is  very much the same as the second method. If [3Xarrows[0m is a
  list  of  the  arrows of the quiver (obtained for instance through [10Xarrows :=
  ArrowsOfQuiver(Q);[0m),    the    argument    [3Xmats[0m    can   have   the   format
  [10X[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].[0m
  
  If  you  would  like  the  trivial vector space at any vertex, then for each
  incoming arrow "a", associate it with a list of the form [10X["a",[n,0]][0m where n
  is  the  dimension  of  the  vector space at the source vertex of the arrow.
  Likewise  for  all  outgoing  arrows  "b", associate them to a block of form
  [10X["b",[0,n]][0m  where  n  is  the  dimension  of the vector space at the target
  vertex of the arrow.
  
  A  warning  though,  the  function assumes that you do not mix the styles of
  inputting  the  matrices/linear  transformations associated to the arrows in
  the quiver. Furthermore, each arrow needs to be assigned a matrix, otherwise
  an  error will be returned. The function verifies that the dimensions of the
  matrices  and  vector  spaces are correct and match, and that each arrow has
  only one matrix assigned to it.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap&gt; Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]); [0X
    [4X&lt;quiver with 2 vertices and 3 arrows&gt;[0X
    [4Xgap&gt; P := PathAlgebra(Rationals, Q);[0X
    [4X&lt;algebra-with-one over Rationals, with 5 generators&gt;[0X
    [4Xgap&gt; matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X&gt; ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap&gt; M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt; [0X
    [4Xgap&gt; mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], [[0,0],[1,0]] ];; [0X
    [4Xgap&gt; N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt; [0X
    [4Xgap&gt; arrows := ArrowsOfQuiver(Q);[0X
    [4X[ a, b, c ][0X
    [4Xgap&gt; mats := [[arrows[1], [[1,0,0],[0,1,0]]], [0X
    [4X&gt; [arrows[2], [[0,1],[1,0],[0,1]]], [arrows[3], [[0,0],[1,0]]]];;[0X
    [4Xgap&gt; N := RightModuleOverPathAlgebra(P,mats); [0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4Xgenerators&gt;&gt;[0X
    [4Xgap&gt; # Next we give the vertex simple associate to vertex 1. [0X
    [4Xgap&gt; M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],["c",[[0]]]]);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4X					generators&gt;&gt; [0X
    [4Xgap&gt; # Finally, the next defines the zero representation of the quiver.[0X
    [4Xgap&gt; M :=[0X
    [4XRightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],["c",[0,0]]]);[0X
    [4X&lt;right-module over &lt;algebra-with-one over Rationals, with 5[0X
    [4X					generators&gt;&gt; [0X
    [4Xgap&gt; Dimension(M);[0X
    [4X0[0X
    [4Xgap&gt; Basis(M);[0X
    [4XBasis( &lt;[0X
    [4X0-dimensional right-module over &lt;algebra-with-one over Rationals, with [0X
    [4X5 generators&gt;&gt;, [  ] )[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.1-2 NewRightModuleOverPathAlgebra[0m
  
  [2X> NewRightModuleOverPathAlgebra( [0X[3XA, dim_vector, gens[0X[2X ) ____________[0Xoperation
  
  The first argument [3XA[0m is a (quotient of a ) path algebra, the second argument
  [3Xdim_vector[0m is the dimension vector of the module, and the last argument [3Xgens[0m
  (maybe an empty list []) is a list of elements of the form ["label",matrix].
  This  function constructs a right module over a (quotient of a) path algebra
  [3XA[0m  with  dimension vector [3Xdim_vector[0m, and where the generators/arrows with a
  non-zero  action  is  given in the list [3Xgens[0m. The format of the list [3Xgens[0m is
  [["a",[matrix_a]],["b",[matrix_b]],...],  where  "a"  and  "b" are labels of
  arrows  used  when  the  underlying  quiver  was created and matrix_? is the
  action of the algebra element corresponding to the arrow with label "?". The
  action of the arrows can be entered in any order. The function checks if the
  algebra  [3XA[0m  is  a  (quotient  of  a) path algebra and if the matrices of the
  action of the arrows have the correct size according to the dimension vector
  entered and also whether or not the relations of the algebra are satisfied.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # Using the above example.  [0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",[0X
    [4X[[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], [0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M:=NewRightModuleOverPathAlgebra(P,[2,3],matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5 generators>>[0X
    [4Xgap> M:=NewRightModuleOverPathAlgebra(P,[2,3],[]);      [0X
    [4X<right-module over <algebra-with-one over Rationals, with 5 generators>>[0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.2 Categories Of Matrix Modules[0X
  
  [1X6.2-1 IsPathAlgebraMatModule[0m
  
  [2X> IsPathAlgebraMatModule( [0X[3Xobject[0X[2X ) ___________________________________[0Xfilter
  
  These  matrix  modules  fall  under  the category `IsAlgebraModule' with the
  added  filter  of `IsPathAlgebraMatModule'. Operations available for algebra
  modules  can be applied to path algebra modules. See "ref:representations of
  algebras"  for  more  details. These modules are also vector spaces over the
  field  of the path algebra. So refer to "ref:vector spaces" for descriptions
  of the basis and elementwise operations available.
  
  
  [1X6.3 Acting on Module Elements[0X
  
  [1X6.3-1 ^[0m
  
  [2X> ^( [0X[3Xm, p[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation [2X^[0m operates on an element [3Xm[0m in a module and a path [3Xp[0m in a path
  algebra,  and it returns the element [3Xm[0m multiplied with [3Xp[0m. When you act on an
  module  element  $m$  by  an arrow $a$ from $v$ to $w$, the component of $m$
  from  $V$ is acted on by $L$ the transformation associated to $a$ and placed
  in the component $W$ . All other components are given the value $0$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> # Using the path algebra P from the above example. [0X
    [4Xgap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b", [[0,1],[1,0],[0,1]]],[0X
    [4X> ["c", [[0,0],[1,0]]]];[0X
    [4X[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ],[0X
    [4X  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ],[0X
    [4X  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ][0X
    [4Xgap> M := RightModuleOverPathAlgebra(P,matrices);[0X
    [4X<right-module over <algebra-with-one over Rationals, with 5[0X
    [4Xgenerators>> [0X
    [4Xgap> B:=BasisVectors(Basis(M));[0X
    [4X[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], [0X
    [4X  [ [ 0, 0 ], [ 0, 0, 1 ] ] ][0X
    [4Xgap> B[1]+B[3];[0X
    [4X[ [ 1, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> 4*B[2];[0X
    [4X[ [ 0, 4 ], [ 0, 0, 0 ] ][0X
    [4Xgap> m:=5*B[1]+2*B[4]+B[5];[0X
    [4X[ [ 5, 0 ], [ 0, 2, 1 ] ][0X
    [4Xgap> m^(P.a*P.b-P.c);[0X
    [4X[ [ 0, 5 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[1]^P.a;[0X
    [4X[ [ 0, 0 ], [ 1, 0, 0 ] ][0X
    [4Xgap> B[2]^P.b;[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
    [4Xgap> B[4]^(P.b*P.c);[0X
    [4X[ [ 0, 0 ], [ 0, 0, 0 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X6.4 Operations on representations[0X
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],[3,1,"e"]]);[0X
    [4X<quiver with 3 vertices and 5 arrows>[0X
    [4Xgap> KQ := PathAlgebra(Rationals, Q);[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> gens := GeneratorsOfAlgebra(KQ);[0X
    [4X[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ][0X
    [4Xgap> u := gens[1];; v := gens[2];;[0X
    [4Xgap> w := gens[3];; a := gens[4];;[0X
    [4Xgap> b := gens[5];; c := gens[6];;[0X
    [4Xgap> d := gens[7];; e := gens[8];;[0X
    [4Xgap> rels := [d*e,c^2,a*c*d-b*d,e*a];;[0X
    [4Xgap> I:= Ideal(KQ,rels);;[0X
    [4Xgap> gb:= GBNPGroebnerBasis(rels,KQ);;[0X
    [4Xgap> gbb:= GroebnerBasis(I,gb);;[0X
    [4Xgap> A:= KQ/I;[0X
    [4X<algebra-with-one over Rationals, with 8 generators>[0X
    [4Xgap> mat:=[["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],[0X
    [4X["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;[0X
    [4Xgap> N:= RightModuleOverQuotientOfPathAlgebra(A,mat);                         [0X
    [4X<right-module over <algebra-with-one over Rationals, with 8 generators>>[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.4-1 CommonDirectSummand[0m
  
  [2X> CommonDirectSummand( [0X[3XM, N[0X[2X ) _____________________________________[0Xoperation
  [6XReturns:[0X  a  list of four modules [[3XX[0m,[3XU[0m,[3XX[0m, [3XV[0m], where [3XX[0m is one common non-zero
            direct  summand of [3XM[0m and [3XN[0m, the sum of [3XX[0m and [3XU[0m is [3XM[0m and the sum of
            [3XX[0m  and [3XV[0m is [3XN[0m, if such a non-zero direct summand exists. Otherwise
            it returns false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-2 DimensionVector[0m
  
  [2X> DimensionVector( [0X[3XM[0X[2X ) ____________________________________________[0Xoperation
  [6XReturns:[0X  the  dimension vector of the representation [3XM[0m. The argument [3XM[0m must
            be a [10XPathAlgebraMatModule[0m.
  
  A  shortcoming  of  this  that it is not defined for modules of quotients of
  path algebras.
  
  [1X6.4-3 DimensionMatModule[0m
  
  [2X> DimensionMatModule( [0X[3XM[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  the  dimension  of  the representation [3XM[0m. The argument [3XM[0m must be a
            [10XPathAlgebraMatModule[0m.
  
  [1X6.4-4 DirectSummandTest[0m
  
  [2X> DirectSummandTest( [0X[3XM, N[0X[2X ) _______________________________________[0Xoperation
  [6XReturns:[0X  true if [3XM[0m is isomorphic to a direct summand of [3XN[0m, otherwise false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-5 DirectSumOfPathAlgebraMatModules[0m
  
  [2X> DirectSumOfPathAlgebraMatModules( [0X[3XL[0X[2X ) ___________________________[0Xoperation
  [6XReturns:[0X  the direct sum of the representations contained in the list [3XL[0m.
  
  The  argument  [3XL[0m  must  be  a  list  of [10XPathAlgebraMatModule[0m's over the same
  (quotient  of  a) path algebra. In addition three attributes are attached to
  the result, [10XIsDirectSum, DirectSumProjections[0m and [10XDirectSumInclusions[0m.
  
  [1X6.4-6 IsDirectSum[0m
  
  [2X> IsDirectSum( [0X[3XM[0X[2X ) ________________________________________________[0Xattribute
  
  An   attribute,   returns   true   is  [3XM[0m  is  constructed  via  the  command
  [10XDirectSumOfPathAlgebraMatModules[0m.
  
  [1X6.4-7 DirectSumInclusions[0m
  
  [2X> DirectSumInclusions( [0X[3XM[0X[2X ) ________________________________________[0Xattribute
  
  An  attribute, returns the list of inclusions from the individual modules to
  their   direct   sum,   when   a  direct  sum  has  been  constructed  using
  [10XDirectSumOfPathAlgebraMatModules[0m.
  
  [1X6.4-8 DirectSumProjections[0m
  
  [2X> DirectSumProjections( [0X[3XM[0X[2X ) _______________________________________[0Xattribute
  
  An  attribute,  returns  the  list of projections from the direct sum to the
  individual  modules used to construct direct sum, when a direct sum has been
  constructed using [10XDirectSumOfPathAlgebraMatModules[0m.
  
  Using the example above.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> N2:=DirectSumOfPathAlgebraMatModules([N,N]);[0X
    [4X<14-dimensional right-module over <algebra-with-one of dimension [0X
    [4X17 over Rationals>>[0X
    [4Xgap> proj:=DirectSumProjections(N2);[0X
    [4X[ <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> >, [0X
    [4X  <mapping: <14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> > ][0X
    [4Xgap> inc:=DirectSumInclusions(N2);  [0X
    [4X[ <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> >, [0X
    [4X  <mapping: <7-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> -> <[0X
    [4X    14-dimensional right-module over AlgebraWithOne( Rationals, [0X
    [4X    [ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [0X
    [4X      [(1)*e] ] )> > ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.4-9 1st_Syzygy[0m
  
  [2X> 1st_Syzygy( [0X[3XM[0X[2X ) _________________________________________________[0Xoperation
  [6XReturns:[0X  the  first syzygy of the representation [3XM[0m as a representation. The
            argument [3XM[0m must be a [10XPathAlgebraMatModule[0m.
  
  [1X6.4-10 InAdditiveClosureTest[0m
  
  [2X> InAdditiveClosureTest( [0X[3XM, N[0X[2X ) ___________________________________[0Xoperation
  [6XReturns:[0X  true  if  [3XM[0m  is in the additive closure of the module [3XN[0m, otherwise
            false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-11 IsOmegaPeriodic[0m
  
  [2X> IsOmegaPeriodic( [0X[3XM, n[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  [10Xi[0m,  where  [10Xi[0m is the smallest positive integer less or equal [10Xn[0m such
            that  the  representation [3XM[0m is isomorphic to the [10Xi[0m-th syzygy of [3XM[0m,
            and    false    otherwise.    The    argument    [3XM[0m   must   be   a
            [10XPathAlgebraMatModule[0m, and [3Xn[0m must be a positive integer.
  
  [1X6.4-12 IsInjectiveModule[0m
  
  [2X> IsInjectiveModule( [0X[3XM[0X[2X ) __________________________________________[0Xoperation
  [6XReturns:[0X  true  if the representation [3XM[0m is injective. The argument [3XM[0m must be
            a [10XPathAlgebraMatModule[0m.
  
  [1X6.4-13 IsOmegaPeriodicTest[0m
  
  [2X> IsOmegaPeriodicTest( [0X[3XM, n[0X[2X ) _____________________________________[0Xoperation
  [6XReturns:[0X  [10Xi[0m,  where  [10Xi[0m  less  or  equal  to  [10Xn[0m  and  the representation [3XM[0m is
            isomorphic  to the [10Xi[0m-th syzygy of [3XM[0m, or else false. The argument [3XM[0m
            must be a [10XPathAlgebraMatModule[0m and [10Xn[0m is a positive integer.
  
  [1X6.4-14 IsProjectiveModule[0m
  
  [2X> IsProjectiveModule( [0X[3XM[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  true if the representation [3XM[0m is projective. The argument [3XM[0m must be
            a [10XPathAlgebraMatModule[0m.
  
  [1X6.4-15 IsSemisimpleModule[0m
  
  [2X> IsSemisimpleModule( [0X[3XM[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  true if the representation [3XM[0m is semisimple. The argument [3XM[0m must be
            a [10XPathAlgebraMatModule[0m.
  
  [1X6.4-16 IsSimpleModule[0m
  
  [2X> IsSimpleModule( [0X[3XM[0X[2X ) _____________________________________________[0Xoperation
  [6XReturns:[0X  true  if  the representation [3XM[0m is simple. The argument [3XM[0m must be a
            [10XPathAlgebraMatModule[0m.
  
  [1X6.4-17 LoewyLength[0m
  
  [2X> LoewyLength( [0X[3XM[0X[2X ) ________________________________________________[0Xoperation
  [6XReturns:[0X  the Loewy length of the module [3XM[0m.
  
  The  function checks that the module [3XM[0m is a module over a finite dimensional
  quotient  of  a  path  algebra,  and  returns  fail  otherwise  (This is not
  implemented yet).
  
  [1X6.4-18 MaximalCommonDirectSummand[0m
  
  [2X> MaximalCommonDirectSummand( [0X[3XM, N[0X[2X ) ______________________________[0Xoperation
  [6XReturns:[0X  a  list  of  three  modules  [[3XX[0m,[3XU[0m,[3XV[0m],  where [3XX[0m is a maximal common
            non-zero  direct  summand  of [3XM[0m and [3XN[0m, the sum of [3XX[0m and [3XU[0m is [3XM[0m and
            the sum of [3XX[0m and [3XV[0m is [3XN[0m, if such a non-zero maximal direct summand
            exists. Otherwise it returns false.
  
  The  function  checks  if  [3XM[0m  and  [3XN[0m are [10XPathAlgebraMatModule[0ms over the same
  (quotient of a) path algebra.
  
  [1X6.4-19 ModuleIsomorphismTest[0m
  
  [2X> ModuleIsomorphismTest( [0X[3XM, N[0X[2X ) ___________________________________[0Xoperation
  [6XReturns:[0X  true or false depending on whether [3XM[0m and [3XN[0m are isomorphic or not.
  
  The  function  first checks if the modules [3XM[0m and [3XN[0m are modules over the same
  algebra,  and  returns fail if not. The function returns true if the modules
  are isomorphic, otherwise false.
  
  [1X6.4-20 nth_Syzygy[0m
  
  [2X> nth_Syzygy( [0X[3XM, n[0X[2X ) ______________________________________________[0Xoperation
  [6XReturns:[0X  the  top  of the syzygies until a syzygy is projective or the [3Xn[0m-th
            syzygy   has   been   computed.   The   argument   [3XM[0m   must  be  a
            [10XPathAlgebraMatModule[0m,  and  the  argument  [3Xn[0m  must  be  a positive
            integer.
  
  [1X6.4-21 nth_SyzygyNC[0m
  
  [2X> nth_SyzygyNC( [0X[3XM, n[0X[2X ) ____________________________________________[0Xoperation
  [6XReturns:[0X  the  [10Xn[0m-th  syzygy of the module [3XM[0m, unless the projective dimension
            of  [3XM[0m  is  less  or  equal  to  [10Xn-1[0m,  in which case it returns the
            projective dimension of [3XM[0m. It does not check if the [10Xn[0m-th syzygy is
            projective  or not. The argument [3XM[0m must be a [10XPathAlgebraMatModule[0m,
            and the argument [3Xn[0m must be a positive integer.
  
  [1X6.4-22 RadicalOfRep[0m
  
  [2X> RadicalOfRep( [0X[3XM[0X[2X ) _______________________________________________[0Xoperation
  [6XReturns:[0X  the radical of the module [3XM[0m.
  
  This  returns  only the representation given by the radical of the module [3XM[0m.
  The  operation  [2XRadicalOfRepInclusion[0m ([14X7.3-17[0m) computes the inclusion of the
  radical of [3XM[0m into [3XM[0m.
  
  [1X6.4-23 RadicalSeries[0m
  
  [2X> RadicalSeries( [0X[3XM[0X[2X ) ______________________________________________[0Xoperation
  [6XReturns:[0X  the radical series of the module [3XM[0m.
  
  The  function  gives  the radical series as a list of vectors [10X[n_1,...,n_s][0m,
  where  the  algebra  has  $s$  isomorphism classes of simple modules and the
  numbers  give  the  multiplicity  of  each  simple.  The first vector listed
  corresponds to the top layer, and so on.
  
  [1X6.4-24 SocleSeries[0m
  
  [2X> SocleSeries( [0X[3XM[0X[2X ) ________________________________________________[0Xoperation
  [6XReturns:[0X  the socle series of the module [3XM[0m.
  
  The  function  gives  the  socle  series as a list of vectors [10X[n_1,...,n_s][0m,
  where  the  algebra  has  $s$  isomorphism classes of simple modules and the
  numbers  give  the  multiplicity  of  each  simple.  The  last vector listed
  corresponds to the socle layer, and so on backwards.
  
  [1X6.4-25 SocleOfPathAlgebraMatModule[0m
  
  [2X> SocleOfPathAlgebraMatModule( [0X[3XM[0X[2X ) ________________________________[0Xoperation
  [6XReturns:[0X  the socle of the module [3XM[0m.
  
  This  operation  only  return  the  representation given by the socle of the
  module  [3XM[0m.  The  inclusion  the  socle  of  [3XM[0m  into  [3XM[0m can be computed using
  [2XSocleOfPathAlgebraMatModuleInclusion[0m ([14X7.3-18[0m).
  
  [1X6.4-26 SubRep[0m
  
  [2X> SubRep( [0X[3XM, gens[0X[2X ) _______________________________________________[0Xoperation
  [6XReturns:[0X  the submodule of the module [3XM[0m generated by the elements [3Xgens[0m.
  
  The  function checks if [3Xgens[0m are elements in [3XM[0m, and returns an error message
  otherwise.  The  inclusion  of  the submodule generated by the elements [3Xgens[0m
  into [3XM[0m can be computed using [2XSubRepInclusion[0m ([14X7.3-19[0m).
  
  [1X6.4-27 SupportModuleElement[0m
  
  [2X> SupportModuleElement( [0X[3Xm[0X[2X ) _______________________________________[0Xoperation
  [6XReturns:[0X  the  primitive  idempotents [3Xv[0m in the algebra over which the module
            containing the element [3Xm[0m is a module, such that [3Xm^v[0m is non-zero.
  
  The  function  checks  if [3Xm[0m is an element in a module over a (quotient of a)
  path algebra, and returns fail otherwise.
  
  [1X6.4-28 TopOfRep[0m
  
  [2X> TopOfRep( [0X[3XM[0X[2X ) ___________________________________________________[0Xoperation
  [6XReturns:[0X  the top of the module [3XM[0m.
  
  This  returns  only the representation given by the top of the module [3XM[0m. The
  operation  [2XTopOfRepProjection[0m ([14X7.3-20[0m) computes the projection of the module
  [3XM[0m onto the top of the module [3XM[0m.
  
  [1X6.4-29 GeneratorsOfRep[0m
  
  [2X> GeneratorsOfRep( [0X[3XM[0X[2X ) ____________________________________________[0Xoperation
  [6XReturns:[0X  a  minimal  generator  set of the module [3XM[0m as a module of the path
            algebra it is defined over.
  
  [1X6.4-30 MinimalSetOfGenerators[0m
  
  [2X> MinimalSetOfGenerators( [0X[3XM[0X[2X ) _____________________________________[0Xattribute
  [6XReturns:[0X  a  minimal  generator  set of the module [3XM[0m as a module of the path
            algebra it is defined over.
  
  [1X6.4-31 MatricesOfPathAlgebraMatModule[0m
  
  [2X> MatricesOfPathAlgebraMatModule( [0X[3XM[0X[2X ) _____________________________[0Xoperation
  [6XReturns:[0X  a  list  of  the  matrices  that defines the representation [3XM[0m as a
            right  module of the acting path algebra. The argument [3XM[0m must be a
            [10XPathAlgebraMatModule[0m.
  
  The  list  of  matrices  that are returned are not the same identical to the
  matrices  entered to define the representation if there is zero vector space
  in  at  least  one  vertex.  Then  zero matrices of the appropriate size are
  returned.  A  shortcoming  of  this  that  it  is not defined for modules of
  quotients of path algebras.
  
  
  [1X6.5 Special representations[0X
  
  Here  we  collect  the  predefined  representations/modules  over  a  finite
  dimensional quotient of a path algebra.
  
  [1X6.5-1 BasisOfProjectives[0m
  
  [2X> BasisOfProjectives( [0X[3XA[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  a   list   of   bases   for   all  the  indecomposable  projective
            representations  over  a  finite  dimensional (quotient of a) path
            algebra [3XA[0m. The basis for each indecomposable projective is given a
            list of elements in nontips in [3XA[0m.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-2 IndecomposableProjectiveRepresentations[0m
  
  [2X> IndecomposableProjectiveRepresentations( [0X[3XA[, list][0X[2X ) ____________[0Xoperation
  [6XReturns:[0X  a list of all the indecomposable projective representations over a
            finite  dimensional  (quotient of a) path algebra [3XA[0m, when only one
            argument  is  supplied.  The  second  argument should be a list of
            integers,   for   example   [1,  3,  4],  which  will  return  the
            indecomposable  projective  corresponding to vertex 1, 3 and 4, in
            this order.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-3 IndecomposableInjectiveRepresentations[0m
  
  [2X> IndecomposableInjectiveRepresentations( [0X[3XA[, list][0X[2X ) _____________[0Xoperation
  [6XReturns:[0X  a  list of all the indecomposable injective representations over a
            finite  dimensional  (quotient of a) path algebra [3XA[0m, when only one
            argument  is  supplied.  The  second  argument should be a list of
            integers,   for   example   [1,  3,  4],  which  will  return  the
            indecomposable  injective  corresponding  to vertex 1, 3 and 4, in
            this order.
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-4 VertexSimpleRepresentations[0m
  
  [2X> VertexSimpleRepresentations( [0X[3XA[0X[2X ) ________________________________[0Xoperation
  [6XReturns:[0X  a list of all the simple representations over a finite dimensional
            (quotient of a) path algebra [3XA[0m .
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  [1X6.5-5 ZeroRepresentation[0m
  
  [2X> ZeroRepresentation( [0X[3XA[0X[2X ) _________________________________________[0Xoperation
  [6XReturns:[0X  the  zero representation over a finite dimensional (quotient of a)
            path algebra [3XA[0m .
  
  The function checks if the algebra [3XA[0m is a finite dimensional (quotient of a)
  path algebra, and returns an error message otherwise.
  
  
  [1X6.6 Functors on representations[0X
  
  [1X6.6-1 DualOfPathAlgebraMatModule[0m
  
  [2X> DualOfPathAlgebraMatModule( [0X[3XM[0X[2X ) _________________________________[0Xoperation
  
  Takes the a representation [3XM[0m of a path algebra $KQ$ and produces the dual of
  this representation over the opposite path algebra [3XKQ_op[0m.
  
  [1X6.6-2 DualOfPathAlgebraMatModuleMap[0m
  
  [2X> DualOfPathAlgebraMatModuleMap( [0X[3Xf[0X[2X ) ______________________________[0Xoperation
  
  Takes  the  a  map [3Xf[0m between two representations [3XM[0m and [3XN[0m over a path algebra
  $A$ and produces the dual of this map over the opposite path algebra [3XA^op[0m.
  
  [1X6.6-3 DTr[0m
  
  [2X> DTr( [0X[3XM[0X[2X ) ________________________________________________________[0Xoperation
  [2X> DTr( [0X[3XM, n[0X[2X ) _____________________________________________________[0Xoperation
  [6XReturns:[0X  the dual of the transpose of the module [3XM[0m in the first variant. In
            the  second form it returns the dual of the transpose applied to [3XM[0m
            [3Xn[0m times. If [3Xn[0m is negative, then powers of [10XTrD[0m are computed.
  
  The argument [3XM[0m must be a [10XPathAlgebraMatModule[0m and [3Xn[0m must be an integer.
  
  [1X6.6-4 TrD[0m
  
  [2X> TrD( [0X[3XM[0X[2X ) ________________________________________________________[0Xoperation
  [2X> TrD( [0X[3XM, n[0X[2X ) _____________________________________________________[0Xoperation
  [6XReturns:[0X  the transpose of the dual of the module [3XM[0m in the first variant. In
            the  second form it returns the transpose of the dual applied to [3XM[0m
            [3Xn[0m times. If [3Xn[0m is negative, then powers of [10XTrD[0m are computed.
  
  The argument [3XM[0m must be a [10XPathAlgebraMatModule[0m and [3Xn[0m must be an integer.
  
  [1X6.6-5 TransposeOfModule[0m
  
  [2X> TransposeOfModule( [0X[3XM[0X[2X ) __________________________________________[0Xoperation
  [6XReturns:[0X  the transpose of the module [3XM[0m.
  
  The argument [3XM[0m must be a [10XPathAlgebraMatModule[0m.
  
  
  [1X6.7 Vertex Projective Presentations[0X
  
  In  general, if $R$ is a ring and $e$ is an idempotent of $R$ then $eR$ is a
  projective  module of $R$. Then we can form a direct sum of these projective
  modules  together  to  form larger projective module. One can construct more
  general modules by providing a [3Xvertex projective presentation[0m. In this case,
  $M$   is   the   cokernel   as   given  by  the  following  exact  sequence:
  $\oplus_{j=1}^{r}  w(j)R  \rightarrow  \oplus_{i=1}^{g} v(i)R \rightarrow{M}
  \rightarrow   0$   for   some   map  between  $\oplus_{j=1}^{r}  w(j)R$  and
  $\oplus_{i=1}^{g}  v(i)R$.  The  maps  $w$  and $v$ map the integers to some
  idempotent in $R$.
  
  [1X6.7-1 RightProjectiveModule[0m
  
  [2X> RightProjectiveModule( [0X[3XA, verts[0X[2X ) ________________________________[0Xfunction
  [6XReturns:[0X  the  right  projective  module  over  [3XA[0m which is the direct sum of
            projective  modules  of  the  form [3XvA[0m where the vertices are taken
            from the list of vertices [3Xverts[0m.
  
  In this implemenation the algebra can be a quotient of a path algebra. So if
  the  list  was  $[v,w]$  then  the module created will be the direct sum $vA
  \oplus  wA$,  in  that order. Elements of the modules are vectors of algebra
  elements,  and  in  each component, each path begins with the vertex in that
  position in the list of vertices. Right projective modules are implementated
  as   algebra   modules  (see  "ref:Representations  of  Algebras")  and  all
  operations  for  algebra modules are applicable to right projective modules.
  In particular, one can construct submodules using `SubAlgebraModule'.
  
  Here we create the right projective module $P = vA \oplus vA \oplus wA$.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> F:=GF(11);[0X
    [4XGF(11)[0X
    [4Xgap> Q:=Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],["w","x","c"]]);[0X
    [4X<quiver with 3 vertices and 3 arrows>[0X
    [4Xgap> A:=PathAlgebra(F,Q);[0X
    [4X<algebra-with-one over GF(11), with 6 generators>[0X
    [4Xgap> P:=RightProjectiveModule(A,[A.v,A.v,A.w]);[0X
    [4X<right-module over <algebra-with-one over GF(11), with 6 generators>>[0X
    [4Xgap> Dimension(P);[0X
    [4X12[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-2 Vectorize[0m
  
  [2X> Vectorize( [0X[3XM, components[0X[2X ) _______________________________________[0Xfunction
  [6XReturns:[0X  a  vector  in  the  module  [3XM[0m from a list of path algebra elements
            [3Xcomponents[0m, which defines the components in the resulting vector.
  
  The  returned vector is normalized, so the vector's components may not match
  the input components.
  
  In  the  following  example,  we  create  two  elements in $P$, perform some
  elementwise  operations,  and  then  construct  a  submodule  using  the two
  elements as generators.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1:=Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);[0X
    [4X[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ][0X
    [4Xgap> p2:=Vectorize(P,[A.a,A.b,A.w]);[0X
    [4X[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ][0X
    [4Xgap> 2*p1 + p2;[0X
    [4X[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, (Z(11)^0)*w+(Z(11))*c ][0X
    [4Xgap> S:=SubAlgebraModule(P,[p1,p2]);[0X
    [4X<right-module over <algebra-with-one of dimension 8 over GF(11)>>[0X
    [4Xgap> Dimension(S);[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-3 ^[0m
  
  [2X> ^( [0X[3Xm, a[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X^[0m operates on an element [3Xm[0m in a module and an element [3Xa[0m in a
  path algebra, and it returns the element [3Xm[0m multiplied with [3Xa[0m. This action is
  defined by multiplying each component in [3Xm[0m by [3Xa[0m on the right.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p2^(A.c - A.w);[0X
    [4X[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, [0X
    [4X  (Z(11)^5)*w+(Z(11)^0)*c ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-4 <[0m
  
  [2X> <( [0X[3Xm1, m2[0X[2X ) _____________________________________________________[0Xoperation
  
  The  operation  [2X<[0m  operates  on  elements [3Xm1[0m and [3Xm2[0m in ????, and it compares
  them.  The  result  is  `true'  if  [3Xm1[0m  is less than [3Xm2[0m and false otherwise.
  Elements are compared componentwise from left to right using the ordering of
  the  underlying  algebra.  The  element [3Xm1[0m is less than [3Xm2[0m if the first time
  components are not equal, the component of [3Xm1[0m is less than the corresponding
  component of [3Xm2[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> p1 < p2;[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  [1X6.7-5 /[0m
  
  [2X> /( [0X[3XM, N[0X[2X ) _______________________________________________________[0Xoperation
  
  The  operation  [2X/[0m  operates on two finite dimensional modules [3XM[0m and [3XN[0m over a
  path  algebra?,  and  it  constructs the factor module $M/N$. This module is
  again  a right algebra module, and all applicable methods and operations are
  available for the resulting factor module. Furthermore, the resulting module
  is a vector space, so operations for computing bases and dimensions are also
  available.
  
  This
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> PS := P/S;[0X
    [4X<9-dimensional right-module over <algebra-with-one of dimension[0X
    [4X8 over GF(11)>> [0X
    [4Xgap> Basis(PS);[0X
    [4XBasis( <9-dimensional right-module over <algebra-with-one of dimension [0X
    [4X8 over GF(11)>>, [ [ [ <zero> of ..., <zero> of ...,[0X
    [4X(Z(11)^0)*w ] ],  [0X
    [4X  [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], [0X
    [4X  [ [ <zero> of ..., (Z(11)^0)*b*c, <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], [0X
    [4X  [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ] ] )[0X
  [4X------------------------------------------------------------------[0X
  
