% -*- mode: Noweb; noweb-code-mode: latex-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QPA Project User Documentation
% DESCRIPTION: pathalg.tex
%
% Copyright, 1998, 1999 Virginia Polytechnic Institute and State University.
% Copyright, 1998, 1999 Virginia Tech QPA Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: pathalg.tex,v 1.1 2010/05/07 13:16:24 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Path Algebras}

A path algebra is an algebra
constructed from a field $F$ and a quiver $Q$.
The path algebra $FQ$ contains all finite linear combinations
of elements of $Q$.

This chapter describes the functions in {\QPA} that deal with path algebras
and quotients of path algebras.  Path algebras are algebras so see Chapter 
"ref:algebras" for functionality such as generators, basis functions, and mappings.

\>InfoPathAlgebra V

is the info class for functions dealing with path algebras.

%%  The path algebra functionality was designed and implemented
%%	by Craig A. Struble.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Path Algebras}

\>PathAlgebra( <F>, <Q> ) F

This constructions the path algebra $FQ$.

\beginexample 
gap> q := Quiver(["u","v"],[["u","u","a"],["u","v","b"],
> ["v","u","c"],["v","v","d"]]);
<quiver with 2 vertices and 4 arrows>
gap> f := FiniteField(23);
GF(23)
gap> fq := PathAlgebra(f,q);
<algebra-with-one over GF(23), with 6 generators>
\endexample

\* NO: the FOLLOWING is not true:

\>`OrderedBy( <path algebra>, <ordering> )'{Path Algebras:OrderedBy} F

returns a copy of <path algebra> whose elements are ordered
by <ordering>.
See "qpa:Orderings" for more information on orderings.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories and Properties of Path Algebras}

\>IsPathAlgebra( <object> ) P

is true when <object> is a path algebra.

\beginexample
gap> IsPathAlgebra(fq);
true
gap> IsPathAlgebra(q);
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Operations for Path Algebras}

\>QuiverOfPathAlgebra( <pathalgebra> ) A

returns the quiver from which <pathalgebra> was constructed.

\beginexample
gap> QuiverOfPathAlgebra(fq);
<quiver with 2 vertices and 4 arrows>
\endexample

\>`<FQ>.<element>'{path algebra record access} O

is primarily for accessing the quiver generators within a path algebra.

\beginexample
gap> fq.v;
(Z(23)^0)*v
gap> fq.b;
(Z(23)^0)*b
\endexample

\>OrderingOfAlgebra( <path algebra> )
returns the ordering of the quiver of the path algebra.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations on Path Algebra Elements}

\>`<a> \< <b>'{PathAlgebra:lessthan} O

Two elements of a path algebra $FQ$ are compared
using the ordering for the path algebra.
See "qpa:Orderings" for more information on orderings.

\>LeadingTerm( <element> ) O
\>Tip( <element> ) O

is the term in <element> whose monomial is largest
among those monomials that have nonzero coefficients;
this term is known as the *tip* of <element>.

\>LeadingCoefficient( <element> ) O
\>TipCoefficient( <element> ) O

is the coefficient of the tip of <element>.
This is an element of the field.

\>LeadingMonomial( <element> ) O
\>TipMonomial( <element> ) O

is the monomial of the tip of <element>;
it is the largest monomial occurring in <element>
with a nonzero coefficient.
This is an element of the underlying quiver,
not of the path algebra.

\beginexample
gap> elem := fq.a*fq.b*fq.c + fq.b*fq.d*fq.c+fq.d*fq.d;
(Z(23)^0)*d^2+(Z(23)^0)*a*b*c+(Z(23)^0)*b*d*c
gap> LeadingTerm(elem);
(Z(23)^0)*b*d*c
gap> LeadingCoefficient(elem);
Z(23)^0
gap> LeadingMonomial(elem);
b*d*c
\endexample

\>IsLeftUniform( <element> ) O

is true if each monomial in <element>
has the same source vertex.

\>IsRightUniform( <element> ) O

is true if each monomial in <element>
has the same target vertex.

\>IsUniform( <element> ) O

is true if each monomial in <element>
has both the same source vertex and the same target vertex.

\beginexample
gap> IsLeftUniform(elem);
false
gap> IsRightUniform(elem);
false
gap> IsUniform(elem);
false
gap> another := fq.a*fq.b + fq.b*fq.d*fq.c*fq.b*fq.d;
(Z(23)^0)*a*b+(Z(23)^0)*b*d*c*b*d
gap> IsLeftUniform(another);
true
gap> IsRightUniform(another);
true
gap> IsUniform(another);
true
\endexample

\>MappedExpression( <expr>, <gens1>, <gens2> ) O

takes <expr> from a path algebra
and two equal-length lists of generators <gens1> and <gens2>
for subalgebras.
The expression must be in the subalgebra generated
by <gens1>.
The lists define a mapping of each generator in <gens1>
to the corresponding generator in <gens2>.
The value returned is the evaluation of the mapping at <expr>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Constructing Quotients of Path Algebras}

See Chapter "ref:algebras" on how to construct an ideal and a quotient of
an algebra.  When the quotient is constructed, it is still a path algebra and
thus the same commands may be used with quotients.  Also since a quotient is 
still an algebra, refer to "ref:algebras".

\beginexample
gap> I := Ideal(fq,[fq.a * fq.b, fq.d * fq.d - fq.b * fq.c]);
<two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,
  (2 generators)>
gap> GeneratorsOfIdeal(I);
[ (Z(23)^0)*a*b, (Z(23)^11)*b*c+(Z(23)^0)*d^2 ]
gap> quot := fq/I;
<algebra-with-one over GF(23), with 6 generators>
\endexample


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes of Ideals}

\>Groebner Basis Of an Ideal

For many of the functions related to quotients, you will need to compute a 
Gr\accent127obner basis of the ideal.  Refer to the chapters "qpa:groebner basis" and 
"qpa:using opal with gap" to learn more.

\beginexample
gap> J := Ideal(fq,[fq.a*fq.b]);
<two-sided ideal in <algebra-with-one over GF(23), with 6 generators>,
  (1 generators)>
gap> anotherquot := fq/J;
<algebra-with-one over GF(23), with 6 generators>
gap> gb := GroebnerBasis(J,[fq.a*fq.b]);
<partial Groebner basis containing 1 elements>
gap> SetIsCompleteGroebnerBasis(gb, true);
gap> IsCompleteGroebnerBasis(gb);
true
gap> gb = GroebnerBasisOfIdeal(J);
true
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Categories and Properties of Quotients of Path Algebras}

\>IsSubalgebraFpPathAlgebra( <object> ) P

is true when <object> is a quotient of a path algebra.

\beginexample
gap> IsSubalgebraFpPathAlgebra(quot);
true
gap> IsSubalgebraFpPathAlgebra(fq);
false
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Operations for Quotients of Path Algebras}

\>RelatorsOfFpPathAlgebra( <quotient> ) A

returns the relators used to define <quotient>.

\beginexample
gap> OrderingOfAlgebra(anotherquot);
<length left lexicographic ordering>
gap> RelatorsOfFpPathAlgebra(anotherquot);
[ (Z(23)^0)*a*b ]
\endexample

\>NormalFormFunction( <quotient> ) A

is a function that can compute normal forms for elements
of <quotient>.
It may be supplied by the user.

\>IsElementOfFpPathAlgebra( <object> ) P

is true if <object> is an element of some quotient of a path algebra.

\beginexample
gap> this := anotherquot.a*anotherquot.b;
[(Z(23)^0)*a*b]
gap> IsElementOfFpPathAlgebra(this);
true
gap> IsElementOfFpPathAlgebra(fq);
false
\endexample

\>Coefficients( <element> ) O

returns the coefficients of the <element> of a quotient
of a path algebra
in terms of its canonical basis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Attributes and Operations on Elements
of Quotients of Path Algebra}

\>IsNormalForm( <element> ) O

is true if <element> is known to be in normal form.

\beginexample
gap> IsNormalForm(this);
false
\endexample

\>`<element-one> \< <element-two>'{nothing} O

Two elements of a path algebra $FQ$ are compared
using the ordering for the path algebra.

\>ElementOfFpPathAlgebra( <family>, <element>, <computenormal>) O

takes <element> in a path algebra and projects it into the quotient
given by <family>.
If <computenormal> is true,
then the normal form of the projection of <element> is returned.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
