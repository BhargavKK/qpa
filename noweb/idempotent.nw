%% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: Contains functions necessary for finding primitive
%              idempotents in simple algebras over finite fields
%
% Copyright, 2001 Virginia Polytechnic Institute and State University.
% Copyright, 2001 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: idempotent.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Primitive Idempotents}
\label{chapter:primidempotent}

\section{Overview}
\label{section:Overview of Primitive Idempotents}

Let $A$ be an algebra. An element $e \in A$
is \defitem{idempotent} if $e^2 = e$ and $e \neq 0$.
The element $e$ is a \defitem{primitive idempotent}
if $e$ is idempotent
and $e \neq f + g$
for all idempotents $f$ and $g$ in $A$.
In this chapter,
we implement code
for finding a complete orthogonal set
of primitive idempotents
in a simple $\fld{F}$-algebra,
where $\fld{F}$ is a finite field.

\section{Source Files}
\label{section:Source Files for Idempotents}

This file contains the declarations needed for idempotents.

<<[[idempotent.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: idempotent.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Declaration for Minimal Polynomials>>
<<Declaration of Zero Divisor>>
<<Declaration of Left Identity>>
<<Declaration of Singular Idempotent>>
<<Declaration of Primitive Idempotents>>
@

<<[[idempotent.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: idempotent.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Implementation of Minimal Polynomials>>
<<Implementation of Zero Divisor>>
<<Implementation of Left Identity>>
<<Implementation of Singular Idempotent>>
<<Implementation of Primitive Idempotents>>
@

\section{Minimal Polynomials}
\label{section:MinPoly}

GAP includes a minimal polynomial function that works for matrices,
but it does not work for general algebra elements. 
The function below calculates the minimal polynomial
of a general algebra element.

<<Declaration for Minimal Polynomials>>=
DeclareGlobalFunction("HOPF_MinPoly");
@

This is the implementation of the minimal polynomial code,
which is based on code in the GAP library. The parameter [[A]]
is the algebra being used, and [[a]] is the element for which
the minimal polynomial is found. Basically this loops until
the first power of [[a]] is found as a linear combination
of smaller powers of [[a]].

<<Implementation of Minimal Polynomials>>=
InstallGlobalFunction(HOPF_MinPoly,
    function( A, a )
        local F, vv, sp, x, cf, f;

        F := LeftActingDomain(A);
        vv := [ MultiplicativeNeutralElement( A ) ];
        sp := MutableBasis(F, vv);
        x := ShallowCopy(a);
        while not IsContainedInSpan( sp, x ) do
            Add(vv,x);
            CloseMutableBasis(sp, x);
            x := x*a;
        od;
        sp := UnderlyingLeftModule(ImmutableBasis(sp));
        cf := ShallowCopy( - Coefficients(BasisNC(sp,vv), x));
        Add(cf, One(F));
        f := ElementsFamily(FamilyObj(F));
        f := LaurentPolynomialByCoefficients( f, cf, 0 );
        return f;
    end);
@

\section{Zero Divisors}
\label{section:Zero Divisors}

In order to find primitive idempotents 
in a simple algebra $A$ defined over a finite field,
we need a zero divisor $x$ in the algebra.
This function finds a zero divisor
by randomly selecting elements
in $A$, finding one that has a minimal polynomial $m$
with a non-trivial factorization.
If $m = fg$,
then $f(x)g(x) = 0$ and $f(x) \neq 0$, $g(x) \neq 0$.
So $f(x)$ and $g(x)$ are zero divisors in $A$.

<<Declaration of Zero Divisor>>=
DeclareGlobalFunction("HOPF_ZeroDivisor");
@

<<Implementation of Zero Divisor>>=
InstallGlobalFunction(HOPF_ZeroDivisor, function(A)
    local F, d, b, bv, cf, x, m, facts, one, f, g;
    if IsCommutative(A) then
        return [];
    fi;

    F := LeftActingDomain(A);
    if not (IsFinite(F) and IsFiniteDimensional(A)) then
        Error("Algebra A must be finite.");
    fi;
    d := Dimension(A);
    b := CanonicalBasis(A);
    bv := BasisVectors(b);
    repeat
        cf := List([1..d], x -> Random(F));
        x := LinearCombination(bv, cf);
        m := HOPF_MinPoly(A, x);
        facts := Factors( PolynomialRing(F), m);
    until Length(facts) > 1;
    one := MultiplicativeNeutralElement(A);
    f := facts[1];
    g := Product(facts{[2..Length(facts)]});
    return [Value(f, x, one), Value(g, x, one)];
end);
@

\section{Left Identity}
\label{section:Left Identity}

We need to find a left identity
in a right module
to compute primitive idempotents.
The following code computes
a left identity in finite dimensional modules 
(as vector spaces).

<<Declaration of Left Identity>>=
DeclareGlobalFunction("HOPF_LeftIdentity");
@

<<Implementation of Left Identity>>=
InstallGlobalFunction(HOPF_LeftIdentity, function(A)
    local F, b, bv, n, equ, zero, one, zerovec, vec, row, p, sol,
          i, j;

    F := LeftActingDomain(A);
    b := CanonicalBasis(A);
    bv := BasisVectors(b);
    n := Dimension(A);

    equ := [];
    zero := Zero(F);
    one := One(F);
    zerovec := ListWithIdenticalEntries(n^2, zero);
    vec := ShallowCopy(zerovec);

    for i in [1..n] do
        row := ShallowCopy(zerovec);
        for j in [1..n] do
            p := (j-1)*n;
            row{[p+1..p+n]} := Coefficients(b, b[i]*b[j]);
        od;
        Add(equ, row);
        vec[ (i-1)*n + i ] := one;
    od;
    sol := SolutionMat(equ,vec);
    if sol <> fail then
        sol := LinearCombination(bv, sol);
    fi;
    return sol;
end);
@

\section{SingularIdempotent}
\label{section:SingularIdempotent}

The following code implements a procedure for finding a single
primitive idempotent in a simple algebra $A$ defined
over a finite field. This idempotent is then used to calculate
all primitive idempotents in a simple algebra defined
over a finite field. The algorithm for this function
originates in Friedl and \ronyai.

<<Declaration of Singular Idempotent>>=
DeclareGlobalFunction("HOPF_SingularIdempotent");
@

<<Implementation of Singular Idempotent>>=
InstallGlobalFunction(HOPF_SingularIdempotent, function(A)
    local z, b, bv, x, li, e;

    while not IsCommutative(A) do
        z := HOPF_ZeroDivisor(A);
        b := Basis(A);
        bv := BasisVectors(b);
        x := z[1];
        li := x*A;
        e := HOPF_LeftIdentity(li);

        A := Algebra(LeftActingDomain(A), List(bv, x->e*x*e));
    od;

    return MultiplicativeNeutralElement(A);
end);
@

\section{Primitive Idempotents}
\label{section:Primitive Idempotents}

This code calculates a list of primitive idempotents
for the simple algebra $A$. It is based on the algorithm
described by Eberly. % Include the citation.

The basic idea is to start with a single primitive idempotent
and to successively construct primitive idempotents
from the identity in the algebra.

<<Declaration of Primitive Idempotents>>=
DeclareGlobalFunction("PrimitiveIdempotents");
@

<<Implementation of Primitive Idempotents>>=
InstallGlobalFunction("PrimitiveIdempotents", function(A)
    local F, d, e, eA, r, m, E, b, one, i, s, j, x, e_hat;

    F := LeftActingDomain(A);
    d := Dimension(A);
    e := HOPF_SingularIdempotent(A);
    eA := e*A;
    r := Dimension(eA);  # Dimension of a copy of the center of A.
    m := d / r;          # Matrix dimension (rows and cols)
    E := List([1..m], x -> Zero(A));
    E[1] := e;
    s := Zero(A);
    one := MultiplicativeNeutralElement(A);
    b := BasisVectors(Basis(A));

    for i in [2..m] do
        s := s + E[i-1];
        j := 0;
        repeat
            j := j+1;
            x := (one - s)*b[j]*e;
        until x <> Zero(A);
        e_hat := HOPF_LeftIdentity(x*A);
        E[i] := e_hat*(one - s);
    od;
    return E;
end );
@