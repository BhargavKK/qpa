% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This file contains the implementation of functions needed
%              to decompose modules over Path Algebras
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: decomp.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Module Decomposition}
\label{chapter:Module Decomposition}

\section{Overview}
\label{section:DecompositionOverview}
This chapter contains functions needed for the decomposition of modules over 
path algebras.  The methods implemented include functions which find the idempotents necessary
in any decomposition of an algebra module, a function to compute the complement of a vector space and the
decomposition functions themselves.

\section{Source Files}
\label{section:DecompositionSourceFiles}

<<[[decomp.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: decomp.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Decomposition Declarations>>
@

<<[[decomp.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: decomp.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Decomposition Implementation>>
@

<<Decomposition Declarations>>=
DeclareOperation("ComplementInFullRowSpace", [IsRowSpace]);
<<Lifting Declarations>>
<<DecomposeModule Declaration>>
@

<<Decomposition Implementation>>=
<<Complement Of Row Space>>
<<Lifting Idempotents>>
<<Decomposing Path Algebra Modules>>
@

\section{Lifting Idempotents}

The following functons compute the primitive idempotents of an algebra, which can then be used
to decompose the algebra or modules.  For our problem, we use this function to compute
primitive idempotents of the endomorphism ring of a module, which when applied gives us the 
decomposition of that module.  The method for computing these idempotents is as follows.  First we 
mod out the Jacobson Radical of the algebra.  Next we use a standard gap funtion, [[CentralIdempotentsOfAlgebra]] to 
find the central idempotents of the quotient.  Now we use code implemented in the idempotents chapter to compute 
primitive idempotents in the simple algebras created from multiplying the quotient by its central idempotents.  Now
we have the primitive idempotents we want, except they are elements of the quotient, and so we must lift them back
to the original algebra. 

<<Lifting Declarations>>=
DeclareOperation("LiftIdempotentsForDecomposition",[IsAlgebraGeneralMapping,IsList]);
DeclareOperation("IdempotentsForDecomposition",[IsAlgebra]);
@

\paragraph
The following function lifts the idempotents given in the list back to the domain of the mapping.  It finds a 
preimage of each element in the list and changes the preimage until it is an idempotent.

<<Lifting Idempotents>>=
InstallMethod(LiftIdempotentsForDecomposition,
   "for an algebra mapping and list of idempotents",
   true,
   [IsAlgebraGeneralMapping,IsList],
   0,
   function(map,ids)

   local a,e,i,zero;

   ids:=List(ids,x->PreImagesRepresentative(map,x));
   a:=Source(map);
   zero:=Zero(a);
   e:=Zero(LeftActingDomain(a))*ids[1];
   for i in [1..Length(ids)] do
      ids[i]:=ids[i]-e*ids[i]-ids[i]*e+e*ids[i]*e;
      while not ids[i]^2-ids[i]=zero do
         ids[i]:=3*ids[i]^2-2*ids[i]^3;
      od;
      e:=e+ids[i];
   od;
   return AsSSortedList(ids);
end);
@

\paragraph
The next function computes the primitive idempotents of an algebra using the algorithm 
described above.

<<Lifting Idempotents>>=
InstallMethod(IdempotentsForDecomposition,
   "for an algebra",
   true,
   [IsAlgebra],
   0,
   function(a)

   local map,semi, simp, cents, prims,i;

   map:=NaturalHomomorphismByIdeal(a,RadicalOfAlgebra(a));
   semi:=Range(map);
   cents:=CentralIdempotentsOfAlgebra(semi);
   prims:=[];
   for i in cents do
      simp:=semi*i;
      prims:=Concatenation(prims,PrimitiveIdempotents(simp));
   od;
   
   return LiftIdempotentsForDecomposition(map,prims);
end);
@

\section{Complements of Row Spaces}

To compute the quotient of a matrix module over a path algebra, it was necessary to 
implement a function to compute the complement of a subspace in the full space.  Since
all of the vector spaces in the module are row spaces, and since row spaces are much easier
to work with the following function was written.  It is a very useful function on its own in 
addition to being vital to the module implementation.

<<Complement Of Row Space>>=
InstallMethod(ComplementInFullRowSpace, 
   "Compute the complement vector space of a row space", 
   true, 
   [IsRowSpace], 0,
   function(V)

local M, gens, zero, n, i, needed, dims, t, K;
K:=LeftActingDomain(V);
if Dimension(V)=0 then
   Error("Cannot find complement of trivial space");
fi;
M:=ShallowCopy(BasisVectors(Basis(V)));
TriangulizeMat(M);
dims:=DimensionsMat(M);
n:=dims[2];
needed:=[1 .. n];
zero:=List([1 .. n], x->Zero(K));
if dims[1]=n then
   return TrivialSubspace(V);
fi;
gens:=[];
for i in [1 .. dims[1]] do
   t:=Position(M[i], One(K));
   RemoveSet(needed, t);
od;
for i in [1 .. Length(needed)] do
   zero[needed[i]]:=One(K);
   gens[i]:=ShallowCopy(zero);
   zero[needed[i]]:=Zero(K);
od;
return VectorSpace(K, gens);
end);
@

\section{Decomposing Modules}

Finally, we implement a function which takes in a module over a path algebra and decomposes it 
into indecomposable submodules.  This function works for both matrix modules and presentations.

<<DecomposeModule Declaration>>=
DeclareOperation("DecomposeModule", [IsAlgebraModule]);
@

<<Decomposing Path Algebra Modules>>=
<<Decomposing Matrix Modules>>
<<Decomposing Vertex Projective Modules>>
@

<<Decomposing Matrix Modules>>=
InstallMethod(DecomposeModule, 
   "for a path algebra matrix module", 
   true, 
   [IsPathAlgebraMatModule], 0, 
   function(M)

local genmats, genmaps, basis, endo, idemmats, idemmaps, x;

basis:=CanonicalBasis(M);
endo:=End(ActingAlgebra(M), M);
genmaps:=BasisVectors(Basis(endo));
genmats:=List(genmaps, x->TransposedMat(x!.matrix));
idemmats:=IdempotentsForDecomposition(AlgebraWithOne(LeftActingDomain(M), genmats));
idemmaps:=List(idemmats, x->LeftModuleHomomorphismByMatrix(basis, TransposedMat(x), basis));
for x in idemmaps do
  SetFilterObj(x, IsAlgebraModuleHomomorphism);
od;
return List(idemmaps, x->Image(x,M));
end);
@

<<Decomposing Vertex Projective Modules>>=
InstallMethod(DecomposeModule, 
  "for f. p. path algebra modules",
  true, 
  [IsFpPathAlgebraModule], 0,
  function(V)
local endo, idemmats, idemmaps, dbasis, rbasis, x, genmats, genmaps;
endo:=End(ActingAlgebra(V), V);
genmaps:=BasisVectors(Basis(endo));
genmats:=List(genmaps, x->TransposedMat(x!.matrix));
dbasis:=genmaps[1]!.basissource;
rbasis:=genmaps[1]!.basisrange;
idemmats:=IdempotentsForDecomposition(AlgebraWithOne(LeftActingDomain(V),genmats));
idemmaps:=List(idemmats, x->LeftModuleHomomorphismByMatrix(dbasis, TransposedMat(x), rbasis));
for x in idemmaps do
  SetFilterObj(x, IsAlgebraModuleHomomorphism);
od;
return List(idemmaps, x->Image(x,V));
end);
@

