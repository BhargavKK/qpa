% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This file contains specifications, tests, and
%              implementations for path algebras.
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: algpath.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@

\chapter{Path Algebra Domain}

\section{Overview}\label{section:PathAlgebraOverview}

Path algebras\index{path algebra} are algebras that use a quiver (a
directed multigraph with loops) to define their structure. Let $Q$ be
a quiver and $F$ be a field. The path algebra $FQ$ contains linear
combinations of paths from $Q$ with coefficients from
$F$. Multiplication is defined by multiplication of paths distributed
over addition.

Fortunately, GAP4 supports the elementwise operations by defining
\textit{magma rings}. See the files \texttt{mgmring.gd} and
\texttt{mgmring.gi} for details on magma rings. We build on top of
magma rings to provide the additional functionality and specialized
versions of some algebraic computations not provided in GAP4.

\section{Source Files}\label{section:PathAlgebraSourceFiles}

<<[[algpath.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: algpath.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Path Algebra Declarations>>  
@ 

<<[[algpath.gi]]>>=
# GAP Implementation
# This file was generated from
# $Id: algpath.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Path Algebra Implementation>>
@ 

\section{Path Algebras}\label{section:PathAlgebras}

\subsection{Categories}\label{subsection:PathAlgebraCategories}

\paragraph{Property} The [[IsPathRing]] property exists for completeness. A
path ring is a magma ring whose underlying magma is a quiver.
\begin{verbatim}
IsPathRing(R)
\end{verbatim}

The [[IsPathRing]] property is a property of magma rings.

<<IsPathRing Declaration>>=
DeclareProperty( "IsPathRing", IsMagmaRingModuloSpanOfZero );
DeclareProperty( "IsPathRing", IsAlgebra );
@ %def IsPathRing

The method for [[IsPathRing]] checks that the underlying magma is a
quiver. The idea for this implementation comes from GAP4
[[mgmring.gi]].

<<IsPathRing Implementation>>=
InstallMethod( IsPathRing,
    "for magma ring modulo the span of zero",
    true,
    [ IsMagmaRingModuloSpanOfZero ], 0,
    RM -> IsQuiver( UnderlyingMagma( RM )));
InstallMethod( IsPathRing,
    "for algebras that are not path rings",
    true,
    [ IsAlgebra ], 0,
    false);
@ 

\paragraph{Property Synonym} The [[IsPathAlgebra]] property is a synonym for
being a path ring and an algebra.
\begin{verbatim}
IsPathAlgebra(A)
\end{verbatim}

<<IsPathAlgebra Declaration>>=
DeclareSynonym( "IsPathAlgebra", IsAlgebra and IsPathRing );
@ %def IsPathAlgebra

\paragraph{Filter}
The [[IsFamilyElementOfPathRing]] filter allows us to create methods only
for elements of path rings. It does not inherit from other filters.

<<IsFamilyElementOfPathRing Declaration>>=
DeclareFilter("IsFamilyElementOfPathRing");
@ %def IsFamilyElementOfPathRing

\subsection{Creation Of Path Algebras}\label{subsection:PathAlgebraCreation}

\paragraph{Global Function}
The [[PathRing]] global function creates a magma ring modulo the span
of the zero path using a quiver $Q$ as the underlying magma and sets
the left acting domain to the ring $R$.
\begin{verbatim}
PathRing(R, Q)
\end{verbatim}

Declare [[PathRing]] as a global function.
<<PathRing Declaration>>=
DeclareGlobalFunction( "PathRing" );
@ %def PathRing

The global function checks the second parameter for being a quiver.

<<PathRing Implementation>>=
InstallGlobalFunction( PathRing, function(R, Q)
    local v, one, eFam;

    if not IsQuiver(Q) then
        Error( "<Q> must be a quiver." );
    fi;
    R := MagmaRingModuloSpanOfZero( R, Q, Zero(Q) );
    SetIsPathRing( R, true );
    eFam := ElementsFamily(FamilyObj(R));
    eFam!.pathRing := R;
    SetFilterObj(eFam,IsFamilyElementOfPathRing);

    one := Zero(R);

    for v in VerticesOfQuiver(Q) do
        one := one + ElementOfMagmaRing(eFam, eFam!.zeroRing, 
                                        [One(eFam!.zeroRing)], [v]);
    od;

    SetIsAssociative(R, true);
    SetOne(eFam, one);
    SetGeneratorsOfLeftOperatorRingWithOne(R, GeneratorsOfLeftOperatorRing(R));
    SetFilterObj(R, IsRingWithOne);

    return R;
end );
@ 


\paragraph{Global Function}
The [[PathAlgebra]] global function is a
convienence function for creating a magma ring modulo the span of the
zero path using a quiver $Q$ as the underlying magma and a field $F$
as the left acting domain. Note that all path algebras have a unit,
being the sum of all of the vertices in $Q$.
\begin{verbatim}
PathAlgebra(F, Q)
\end{verbatim}

Declare [[PathAlgebra]] as a global function.

<<PathAlgebra Declaration>>=
DeclareGlobalFunction( "PathAlgebra" );
@ %def PathAlgebra

The global function checks the first parameter for being a division
ring then calls the [[PathRing]] function to construct the algebra. 

<<PathAlgebra Implementation>>=
InstallGlobalFunction( PathAlgebra, function(F, Q)

    if not IsDivisionRing(F) then
        Error( "<F> must be a division ring or field." );
    fi;
    F := PathRing( F, Q );
    SetOrderingOfAlgebra(F, OrderingOfQuiver(Q));
    return F;
end );
@ 

\paragraph{Inclusion in Sources}
The path ring and path algebra declarations and implementations in
this section are included in the source files.

<<Path Algebra Declarations>>=
<<IsPathRing Declaration>>
<<IsPathAlgebra Declaration>>
<<IsFamilyElementOfPathRing Declaration>>
<<PathRing Declaration>>
<<PathAlgebra Declaration>>
@ 

<<Path Algebra Implementation>>=
<<IsPathRing Implementation>>
<<PathRing Implementation>>
<<PathAlgebra Implementation>>
@ 

\subsection{Path Algebra Attributes}\label{subsection:PathAlgebraAttributes}

\paragraph{Attribute}
The [[QuiverOfPathRing]] attribute returns the quiver object used to
define the path ring.
\begin{verbatim}
QuiverOfPathRing(A)
\end{verbatim}

<<QuiverOfPathRing Declaration>>=
DeclareAttribute( "QuiverOfPathRing", IsPathRing );
@ %def QuiverOfPathRing

[[QuiverOfPathRing]] simply returns the underlying magma of the magma
ring used to define the path ring.
<<QuiverOfPathRing Implementation>>=
InstallMethod( QuiverOfPathRing,
    "for a path ring",
    true,
    [ IsPathRing ], 0,
    RQ -> UnderlyingMagma(RQ) );
@ 

\paragraph{Attribute} 
The [[QuiverOfPathAlgebra]] attribute is a synonym for the
[[QuiverOfPathRing]] attribute.
\begin{verbatim}
QuiverOfPathAlgebra(A)
\end{verbatim}

Declare [[QuiverOfPathAlgebra]] as a synonym attribute.
<<QuiverOfPathAlgebra Declaration>>=
DeclareSynonymAttr( "QuiverOfPathAlgebra", QuiverOfPathRing );
@ %def QuiverOfPathAlgebra

\paragraph{Inclusion in Sources}
We include the attributes into the sources here.

<<Path Algebra Declarations>>=
<<QuiverOfPathRing Declaration>>
<<QuiverOfPathAlgebra Declaration>>
@ 

<<Path Algebra Implementation>>=
<<QuiverOfPathRing Implementation>>
<<Canonical bases for path algebras>>
@ 

\subsection{Canonical Bases for Path Algebras}

This function creates a canonical basis
for path algebras.

<<Canonical bases for path algebras>>=
InstallMethod( CanonicalBasis,
    "for path algebras",
    true,
    [ IsPathAlgebra ], NICE_FLAGS+1,
    function( A )
        local q, bv, i;

        q := QuiverOfPathAlgebra(A);
        if IsFinite(q) then
            bv := [];
            for i in Iterator(q) do
                Add(bv, i * One(A));
            od;
            return Basis(A, bv);
        else
           return fail;
        fi;
    end );
@

\subsection{Path Algebra Speed Hacks}

These are some hacks to try and improve speed of path algebra
operations.

\paragraph{Operation}

The [[NormalizedElementOfMagmaRingModuloRelations]] operation creates
normalized elements in magma rings. For path algebras, this means
removing the zero path from things. The default implementation does
not assume where the zero path might occur, but we can assume it will
always be first because that is the only location where it can appear, 
since it will always be smallest in our ordering.

<<Faster NormalizedElementOfMagmaRingModuloRelations>>=
InstallMethod( NormalizedElementOfMagmaRingModuloRelations,
    "for elements of path algebras",
    true,
    [ IsElementOfMagmaRingModuloSpanOfZeroFamily 
      and IsFamilyElementOfPathRing, IsList ], 0,
    function( Fam, descr )
        local zeromagma, len;

        zeromagma:= Fam!.zeroOfMagma;
        len := Length( descr[2] );
        if len > 0 and descr[2][1] = zeromagma then
            descr := [descr[1], descr[2]{[3..len]}];
            MakeImmutable(descr);
        fi;
        return descr;
    end );
@ 

\paragraph{Operation}

We try to speed up the multiplication operation by noting that a
multiplication by zero always returns zero. 

<<Faster Multiplication for path algebra elements>>=
InstallMethod( \*,
    "for path algebra elements (faster)",
    IsIdenticalObj,
    [ IsZero and IsElementOfMagmaRingModuloRelations,
      IsElementOfMagmaRingModuloRelations ], 0,
    function( x, y )
        return x;
    end );
@ 

<<Faster Multiplication for path algebra elements>>=
InstallMethod( \*,
    "for path algebra elements (faster)",
    IsIdenticalObj,
    [ IsElementOfMagmaRingModuloRelations,
      IsZero and IsElementOfMagmaRingModuloRelations ], 0,
    function( x, y )
        return y;
    end );
@ 

\paragraph{Operation}

We can do a similar thing for addition by zero.

<<Faster Addition for path algebra elements>>=
InstallMethod( \+,
    "for path algebra elements (faster)",
    IsIdenticalObj,
    [ IsZero and IsElementOfMagmaRingModuloRelations,
      IsElementOfMagmaRingModuloRelations ], 0,
    function( x, y )
        return y;
    end );
@ 

<<Faster Addition for path algebra elements>>=
InstallMethod( \+,
    "for path algebra elements (faster)",
    IsIdenticalObj,
    [ IsElementOfMagmaRingModuloRelations,
      IsZero and IsElementOfMagmaRingModuloRelations ], 0,
    function( x, y )
        return x;
    end );
@ 


\paragraph{Include in source}

<<Path Algebra Implementation>>=
<<Faster NormalizedElementOfMagmaRingModuloRelations>>
<<Faster Multiplication for path algebra elements>>
<<Faster Addition for path algebra elements>>
@ 

\subsection{Path Algebra Operations}\label{subsection:PathAlgebraOperations}

The [[LeadingTerm]] operation returns the leading term of $e$ with
respect to the ordering for $A$.
\begin{NOTE}
There should be info messages
showing the amount of time require to compute the leading term of an
element.
\end{NOTE}

<<LeadingTerm Declaration>>=
DeclareOperation( "LeadingTerm", [IsRingElement] );
@ %def LeadingTerm


The implementation for path algebras assumes the implementation of
magma rings, which stores elements of the magma in sorted order. We
find the last term in a given element [[e]] in a list encoding and
construct a new element containing just the leading term of [[e]].

<<LeadingTerm Implementation>>=
InstallOtherMethod( LeadingTerm,
    "for a path algebra element",
    IsFamilyElementOfPathRing,
    [IsElementOfMagmaRingModuloRelations], 0,
    function(e)
      local termlist, n, tip, fam, P, embedding;

      termlist := CoefficientsAndMagmaElements(e);
      n := Length(termlist) - 1;
      if n < 1 then
         return Zero(e);
      else
         fam := FamilyObj(e);
         tip :=  ElementOfMagmaRing(fam,
                                    fam!.zeroRing,
                                    [termlist[n+1]], 
                                    [termlist[n]]);
         return tip;
      fi;
    end );
@ 

The leading term of an element is also known is the tip of an
element. We declare a synonym here.

<<Tip Declaration>>=
DeclareSynonym("Tip", LeadingTerm);
@ %def Tip

\paragraph{Operation}
The [[LeadingCoefficient]] returns the leading coefficient for an
element $e$ with respect to the ordering used for $A$ containing $e$.
This operation is declared for rational functions already, so we
install another method for elements of path algebras.

<<LeadingCoefficient Implementation>>=
InstallOtherMethod( LeadingCoefficient, 
    "for elements of path algebras",
    IsFamilyElementOfPathRing,
    [IsElementOfMagmaRingModuloRelations], 0,
    function(e)
      local termlist, n, fam;

      termlist := CoefficientsAndMagmaElements(e);
      n := Length(termlist);
      if n < 1 then
          fam := FamilyObj(e);
          return fam!.zeroRing;
      else
          return termlist[n];
      fi;
    end );
@ 

The leading coefficient is also known as the tip coefficient, so we
add a synonym [[TipCoefficient]] for [[LeadingCoefficient]].

<<TipCoefficient Declaration>>=
DeclareSynonym( "TipCoefficient", LeadingCoefficient );
@ %def TipCoefficient

\paragraph{Operation}

The [[LeadingMonomial]] operation returns the monomial for the leading
term of an element $e$ with respect to the order for $A$ containing
$e$. The monomial is an element of the quiver underlying the path
algebra. [[LeadingMonomial]] is already declared for rational
functions, so we just install another method for elements of path
algebras.

<<LeadingMonomial Implementation>>=
InstallOtherMethod( LeadingMonomial,
    "for elements of path algebras",
    IsFamilyElementOfPathRing,
    [ IsElementOfMagmaRingModuloRelations ], 0,
    function(e)
      local termlist, n, fam;

      termlist := CoefficientsAndMagmaElements(e);
      n := Length(termlist);
      if n < 1 then
          fam := FamilyObj(e);
          return fam!.zeroOfMagma;
      else
          return termlist[n-1];
      fi;
    end );
@     

The leading monomial is also know as the tip monomial;
add the synonym [[TipMonomial]].

<<TipMonomial Declaration>>=
DeclareSynonym( "TipMonomial", LeadingMonomial );
@ %def TipMonomial

\paragraph{Operation}
The [[<]] operation compares elements with respect to the ordering of
the underlying quiver for $A$. We use a somewhat ugly hack to use our
version of [[<]] as opposed to the standard one in the GAP library
which compares the smallest terms first. We install a method for [[<]] 
at a higher rank, then check to see that the family of the elements
being compared is a [[IsFamilyElementOfPathRing]] family. Otherwise,
we pass the method up to the standard one.

<<LessThan Implementation for Path Algebra elements>>=
InstallMethod( \<,
    "for path algebra elements",
    IsIdenticalObj,
    [IsElementOfMagmaRingModuloRelations, 
     IsElementOfMagmaRingModuloRelations], 10, # must be higher rank
    function( e, f )
        local i, swap;

        if not IsFamilyElementOfPathRing(FamilyObj(e)) then
            TryNextMethod();
        fi;
        
        e := Reversed(CoefficientsAndMagmaElements(e));
        f := Reversed(CoefficientsAndMagmaElements(f));

        # The reversal causes coefficients to come before
        # monomials. We need to swap these in order to
        # compare elements properly.
        for i in [ 1,3  .. Length( e )-1 ] do
            swap := e[i];
            e[i] := e[i+1];
            e[i+1] := swap;
        od;

        for i in [ 1,3  .. Length( f )-1 ] do
            swap := f[i];
            f[i] := f[i+1];
            f[i+1] := swap;
        od;

        for i in [ 1 .. Minimum(Length( e ), Length( f )) ] do
          if   e[i] < f[i] then
            return true;
          elif e[i] > f[i] then
            return false;
          fi;
        od;
        return Length( e ) < Length( f );
    end );
@ 

\paragraph{Operation}
The [[IsLeftUniform]] operation checks a path algebra element to see
if each term starts with the same vertex. The result is [[true]] if
each term does start with the same vertex, and [[false]]
otherwise. The zero path is always considered left uniform.

<<Declaration of IsLeftUniform>>=
DeclareOperation( "IsLeftUniform", [IsRingElement]);
@ %def IsLeftUniform

<<Implementation of IsLeftUniform>>=
InstallMethod( IsLeftUniform,
    "for path ring elements",
    IsFamilyElementOfPathRing,
    [ IsElementOfMagmaRingModuloRelations ], 0,
    function( e )
        local terms, v;

        if IsZero(e) then
            return true;
        fi;

        terms := CoefficientsAndMagmaElements(e);
        v := SourceOfPath(terms[1]);
        return ForAll(terms{[1,3..Length(terms)-1]},
                      x -> SourceOfPath(x) = v);
    end );
@ 

\paragraph{Operation}
The [[IsRightUniform]] operation checks a path algebra element to see
if each term ends with the same vertex. The result is [[true]] if
each term does end with the same vertex, and [[false]]
otherwise. The zero path is always considered right uniform.

<<Declaration of IsRightUniform>>=
DeclareOperation( "IsRightUniform", [IsRingElement]);
@ %def IsRightUniform

<<Implementation of IsRightUniform>>=
InstallMethod( IsRightUniform,
    "for path ring elements",
    IsFamilyElementOfPathRing,
    [ IsElementOfMagmaRingModuloRelations ], 0,
    function( e )
        local terms, v;

        if IsZero(e) then
            return true;
        fi;

        terms := CoefficientsAndMagmaElements(e);
        v := TargetOfPath(terms[1]);
        return ForAll(terms{[1,3..Length(terms)-1]},
                      x -> TargetOfPath(x) = v);
    end );
@ 

\paragraph{Operation} The [[IsUniform]] operation checks a path
algebra element to see if each term starts with the same vertex and
ends with the same vertex (the common starting and ending vertices do not have
to be the same). The result is [[true]] if each term does
have a common starting and common ending vertex, and [[false]]
otherwise. The zero path is always considered uniform.

<<Declaration of IsUniform>>=
DeclareOperation( "IsUniform", [IsRingElement]);
@ %def IsUniform

<<Implementation of IsUniform>>=
InstallMethod( IsUniform,
    "for path ring elements",
    IsFamilyElementOfPathRing,
    [ IsElementOfMagmaRingModuloRelations ], 0,
    function( e )

        if IsZero(e) then
            return true;
        fi;

        return IsRightUniform(e) and IsLeftUniform(e);
    end );
@ 

\paragraph{Operation}
The [[MappedExpression]] takes an arithmetic expression encoded by a
path algebra element and evaluates it based on a mapping of generators
to values. This is also implemented for finitely presented algebras in
the GAP library, see \texttt{algfp.gi} for details. It is assumed that
the coefficient ring of the path algebra is compatible with the values
of the generators. In order for an expression to make sense, the sum
of the values of the vertices must be a multiplicative identity for
the range of the result. This, however, is not checked as it would be
difficult to do in all circumstances. Duplicates are not checked 
either.

<<Implementation of MappedExpression for path algebras>>=
InstallOtherMethod( MappedExpression,
    "for a path algebra and two homogeneous lists",
    function( x, y, z)
        return IsFamilyElementOfPathRing(x)
               and IsElmsCollsX( x, y, z);
    end,
    [ IsElementOfMagmaRingModuloRelations, IsHomogeneousList,
      IsHomogeneousList ], 0,
    function( expr, gens1, gens2 )
        local MappedWord, genTable, i, mapped, one, coeff, mon;

        if IsZero(expr) then
            return Zero(gens2[1]);
        fi;

        expr := ExtRepOfObj( expr )[2];

        genTable := [];
        for i in [1..Length(gens1)] do
            coeff := LeadingCoefficient(gens1[i]);
            mon := LeadingMonomial(gens1[i]);
            if IsOne(coeff) and (IsVertex(mon) or IsArrow(mon)) then
                genTable[ExtRepOfObj(mon)[1]] := gens2[i];
            else
                Error( "gens1 must be a list of generators" );
            fi;
        od;

        one := One(expr[2]);

        MappedWord := function( word )
            local mapped, i, exponent;

            i := 2;
            exponent := 1;
            while i <= Length(word) and word[i] = word[i-1] do
                exponent := exponent + 1;
                i := i + 1;
            od;
            mapped := genTable[word[i-1]]^exponent;
            exponent := 1;

            while i <= Length(word) do
                i := i + 1;
                while i <= Length(word) and word[i] = word[i-1] do
                    exponent := exponent + 1;
                    i := i + 1;
                od;
                if exponent > 1 then
                    mapped := mapped * genTable[word[i-1]]^exponent;
                    exponent := 1;
                else
                    mapped := mapped * genTable[word[i-1]];
                fi;
            od;

            return mapped;
        end;

        if expr[2] <> one then
            mapped := expr[2] * MappedWord(expr[1]);
        else
            mapped := MappedWord(expr[1]);
        fi;

        for i in [4,6 .. Length(expr)] do
            if expr[i] = one then
                mapped := mapped + MappedWord( expr[i-1] );
            else
                mapped := mapped + expr[i] * MappedWord( expr[ i-1 ] );
            fi;
        od;

        return mapped;
    end );
@ 

\paragraph{Method}
Ideals in GAP are created with the [[/]] operation. This operation is
defined in [[algebra.gd]] and implemented in [[algebra.gi]]. The
operation assumes the method [[NaturalHomomorphismByIdeal]] has been
defined for the numerator and denominator. 

First, we create a function similar to the
[[FactorFreeAlgebraByRelators]] function in GAP4's [[algfp.gi]]
library file. This does most of the work for creating the
quotient.

\begin{NOTE}
Ask Thomas about generalizing the implementation of
finitely presented algebras for quotients of path algebras. We can
reuse almost everything if we use the [[PackedAlgebraElmDefaultRep]]
in GAP4's library.
\end{NOTE}

<<FactorPathAlgebraByRelators Declaration>>=
DeclareGlobalFunction("FactorPathAlgebraByRelators");
@ %def FactorPathAlgebraByRelators

<<FactorPathAlgebraByRelators Implementation>>=
InstallGlobalFunction( FactorPathAlgebraByRelators, function( P, I, O )
    local A, fam, R, elementFam, relators, gb;
   
    relators := GeneratorsOfIdeal( I );

    if not IsIdenticalObj(OrderingOfQuiver(QuiverOfPathAlgebra(P)), O) then
        # Create a path algebra with a newly ordered quiver
        R := PathAlgebra(LeftActingDomain(P),
                     OrderedBy(QuiverOfPathAlgebra(P), O));
    
        <<Convert relators to proper family>>
    else
        R := P;
    fi;
    
    # Create a new family
    fam := NewFamily( "FamilyElementsFpPathAlgebra",
                      IsElementOfFpPathAlgebra );


    # Create the default type of elements
    fam!.defaultType := NewType( fam, IsElementOfFpPathAlgebra 
                                      and IsPackedElementDefaultRep );

    # If the ideal has a Groebner basis, create a function for
    # finding normal forms of the elements
    if HasGroebnerBasisOfIdeal( I ) 
       and IsCompleteGroebnerBasis( GroebnerBasisOfIdeal( I ) )
    then
       fam!.normalizedType := NewType( fam, IsElementOfFpPathAlgebra
                                            and IsNormalForm
                                            and IsPackedElementDefaultRep );
       gb := GroebnerBasisOfIdeal( I );
       # Make sure the groebner basis is tip reduced now.
       TipReduceGroebnerBasis(gb);
       SetNormalFormFunction( fam, function(fam, x)
           local y;
           y := CompletelyReduce(gb, x);
           return Objectify( fam!.normalizedType, [y] );
       end );
    fi;

    fam!.pathAlgebra := R;
    fam!.ideal := I;
    fam!.familyRing := FamilyObj(LeftActingDomain(R));

    # Set the characteristic.
    if HasCharacteristic( R ) or HasCharacteristic( FamilyObj( R ) ) then
      SetCharacteristic( fam, Characteristic( R ) );
    fi;

    # Path algebras are always algebras with one
    A := Objectify(
        NewType( CollectionsFamily( fam ),
                IsSubalgebraFpPathAlgebra
            and IsAlgebraWithOne
            and IsWholeFamily
            and IsAttributeStoringRep ),
        rec() );

    SetLeftActingDomain( A, LeftActingDomain( R ) );
    SetGeneratorsOfAlgebraWithOne( A, 
        List( GeneratorsOfAlgebra( R ), 
            a -> ElementOfFpPathAlgebra( fam, a, false ) ) );

    SetZero( fam, ElementOfFpPathAlgebra( fam, Zero( R ), true ) );
    SetOne( fam, ElementOfFpPathAlgebra( fam, One( R ), true ) );
    UseFactorRelation( R, relators, A );

    SetOrderingOfAlgebra( A, O );
    SetQuiverOfPathAlgebra(A, QuiverOfPathAlgebra(R));
    SetIsFullFpPathAlgebra(A, true);

    fam!.wholeAlgebra := A;


    return A;
    end );
@ 

The relators need to be converted to be in the proper family; i.e., in
the family of the path algebra with the new ordering. To keep the
proper term ordering of the converted relators. This conversion takes
place term by term, adding each term together in turn. This isn't
extremely efficient, but it is only a one time cost and shouldn't
cause problems since the number of relators is typically low.

The external representation of a relator is assumed to be a list of
two elements. The first is the zero coefficient, the second is a
zipped list of coefficients and external representations of
terms. Basically, to convert the element, we'll create external
representations of each term, convert it to a term in the new family,
then add the term to the relator. The addition implementation for
magma rings keeps things in proper order, so the resulting relator
will have terms in ascending order, according to the new ordering
being used.

<<Convert relators to proper family>>=
# Create relators in $R$
elementFam := ElementsFamily(FamilyObj(R));
relators := List(relators, function(rel)
   local newRelator, extRep, zero, terms, i;

   newRelator := Zero(R);
   extRep := ExtRepOfObj(rel);
   zero := extRep[1];
   terms := extRep[2];

   for i in [1,3..Length(terms) - 1] do
        newRelator := newRelator + 
                      ObjByExtRep(elementFam, [zero, [terms[i], terms[i+1]]]);
   od;
   return newRelator;
end);
@ 


The [[NaturalHomomorphismByIdeal]] method is implemented similarly to
the one in [[algfp.gi]]. We call the [[FactorPathAlgebraByRelators]]
function to construct the quotient. The homomorphism is then
constructed by mapping the generators of the algebra to the generators
of the quotient. These are assumed to be in corresponding order. One
difference between the implementation here and the one in [[algfp.gi]]
is that we pass the ideal to [[FactorPathAlgebraByRelators]] so that
we can check to see if the ideal has a \groebner basis.

<<NaturalHomomorphismByIdeal for Path Algebras>>=
InstallMethod( NaturalHomomorphismByIdeal,
    "for a path algebra and ideal",
    IsIdenticalObj,
    [ IsPathRing, IsFLMLOR ], 0,
    function( A, I )
        local image, hom;

        image := FactorPathAlgebraByRelators( A, I, OrderingOfAlgebra(A) );

        if IsMagmaWithOne( A ) then
            hom := AlgebraWithOneHomomorphismByImagesNC( A, image,
                       GeneratorsOfAlgebraWithOne( A ),
                       GeneratorsOfAlgebraWithOne( image ) );
        else
            hom := AlgebraHomomorphismByImagesNC( A, image,
                       GeneratorsOfAlgebra( A ),
                       GeneratorsOfAlgebra( image ) );
        fi;

        SetIsSurjective( hom, true );

        return hom;
    end );
@

\paragraph{Record Access}
We overload the [[.]] operator on path algebras to access the quiver
generators embedded into the path algebra. This will give an error if
no such generator exists in the quiver.

<<Path Algebra Record Access>>=
InstallMethod( \.,
    "for path algebras",
    true,
    [IsPathAlgebra, IsPosInt], 0,
    function(A, name)
        local quiver, family;

        family := ElementsFamily(FamilyObj(A));
        quiver := QuiverOfPathAlgebra(A);
        return ElementOfMagmaRing(family, Zero(LeftActingDomain(A)),
            [One(LeftActingDomain(A))], [quiver.(NameRNam(name))] );
    end );
@ 


\paragraph{Inclusion in Sources}
We include the operations into the sources here.

<<Path Algebra Declarations>>=
<<FactorPathAlgebraByRelators Declaration>>
<<LeadingTerm Declaration>>
<<Tip Declaration>>
<<TipCoefficient Declaration>>
<<TipMonomial Declaration>>
<<Declaration of IsLeftUniform>>
<<Declaration of IsRightUniform>>
<<Declaration of IsUniform>>
@ 

<<Path Algebra Implementation>>=
<<FactorPathAlgebraByRelators Implementation>>
<<NaturalHomomorphismByIdeal for Path Algebras>>
<<Path Algebra Record Access>>
<<LessThan Implementation for Path Algebra elements>>
<<LeadingTerm Implementation>>
<<LeadingCoefficient Implementation>>
<<LeadingMonomial Implementation>>
<<Implementation of IsLeftUniform>>
<<Implementation of IsRightUniform>>
<<Implementation of IsUniform>>
<<Implementation of MappedExpression for path algebras>>
@ 

\subsection{Homomorphisms of Path Algebras}

\paragraph{Images}

To construct the images
of an algebra homomorphism 
where the source algebra is a path algebra,
we simply call [[MappedExpression]]
to create the image.

<<Implementation of ImagesRepresentative for Path Algebras>>=
InstallMethod( ImagesRepresentative,
    "for an alg. hom. from f. p. algebra, and an element",
    true,
    [ IsAlgebraHomomorphism
      and IsAlgebraGeneralMappingByImagesDefaultRep,
      IsRingElement ], 0,
    function( alghom, elem )

        local A;

        A := Source(alghom);
        if not (IsPathAlgebra(A) or IsSubalgebraFpPathAlgebra(A)) then
            TryNextMethod();
        fi;
        return MappedExpression( elem, alghom!.generators, alghom!.genimages );
    end );
@


\paragraph{Inclusion in Sources}
We include homomorphism related implementations into the sources here.

<<Path Algebra Implementation>>=
<<Implementation of ImagesRepresentative for Path Algebras>>
@

\section{Quotients of Path Algebras}\label{section:QuotientsOfPathAlgebras}
The declarations and implementations draw heavily upon the finitely
presented algebra implementation that exists in [[algfp.gd]] and
[[algfp.gi]] in the GAP4 library.

\subsection{Categories}
\label{subsection:QuotientPathAlgebraCategories}

\paragraph{Category} 
The [[IsSubalgebraFpPathAlgebra]] category contains all of the quotient of
path algebras.

<<IsSubalgebraFpPathAlgebra Declaration>>=
DeclareCategory( "IsSubalgebraFpPathAlgebra", IsAlgebra );
@ %def IsSubalgebraFpPathAlgebra

\paragraph{Property}
The [[IsFullFpPathAlgebra]] implies that the quotient of a path
algebra contains the full set of generators used to create the path
algebra.

<<Declaration of IsFullFpPathAlgebra>>=
DeclareProperty("IsFullFpPathAlgebra", 
    IsFLMLOR and IsElementOfFpPathAlgebraCollection );
@ %def IsFullFpPathAlgebra

\paragraph{Inclusion in Source}
We include the categories for quotient of path algebras here.

<<Path Algebra Declarations>>=
<<IsSubalgebraFpPathAlgebra Declaration>>
@ 

\subsection{Creation of Quotients of Path Algebras}
\label{subsection:QuotientPathAlgebraCreation}

The creation of quotients of path algebras is accomplished with the
[[/]] operation between a path algebra $A$ and an ideal $I$ of $A$
(given as an ideal object or a collection of relations). See
Section~\ref{subsection:PathAlgebraOperations} for more details.

\subsection{Orders for Quotients of Path Algebras}
\label{subsection:PathAlgebraOrders}

A quotient of a path algebra may have an \defitem{admissible order}
which is used to order the monomials in the quotient algebra. The orders
supported by \hopf\ are a subset of those supported by the Opal
non-commutative \groebner\ basis package.

\paragraph{Attribute} 
Every quotient of a path algebra has a [[OrderingOfAlgebra]] attribute
which returns the ordering for elements in the algebra. This attribute
is immutable and is initially set to length lexicographical ordering.
\begin{verbatim}
OrderingOfAlgebra(A)
\end{verbatim}

<<OrderingOfAlgebra Declaration>>=
DeclareAttribute( "OrderingOfAlgebra", IsAlgebra );
@ %def OrderingOfAlgebra

\paragraph{Method}
The [[OrderedBy]] method takes a quotient of a path algebra $A$ and an
order $O$ and returns a copy of $A$ whose elements are ordered by
$O$. This method changes the [[OrderingOfAlgebra]] attribute, has no
initial \groebner\ basis, and the elements have no initial normal form.
\begin{verbatim}
OrderedBy(A, O)
\end{verbatim}

The [[OrderedBy]] function is declared for quivers 
in Section~\ref{subsection:QuiverCreation}, so we have no
need to redclare it here. Instead, we use [[InstallOtherMethod]] to
install an alternate version of the method.

The method copies the algebra $A$ and sets its ordering to the
ordering $O$.

<<OrderedBy Implementation>>=
InstallOtherMethod( OrderedBy,
    "for a quotient of a path algebra",
    true,
    [IsSubalgebraFpPathAlgebra, IsQuiverOrdering], 0,
    function(A, O)
        local fam;
        fam := ElementsFamily(FamilyObj(A));
        return FactorPathAlgebraByRelators( fam!.pathAlgebra,
                                            fam!.relators,
                                            O);
    end );
@ 

\paragraph{Record Access}
We overload the [[.]] operator on path algebras to access the path
algebra generators embedded into the quotient of the path
algebra. This will give an error if no such generator exists in the
quiver.

<<Quotient Path Algebra Record Access>>=
InstallMethod( \.,
    "for quotients of path algebras",
    true,
    [IsSubalgebraFpPathAlgebra, IsPosInt], 0,
    function(A, name)
        local parent, family;

        family := ElementsFamily(FamilyObj(A));
        parent := family!.pathAlgebra;
        return ElementOfFpPathAlgebra(family, parent.(NameRNam(name)), false );
    end );
@ 

\paragraph{Attribute}
The [[RelatorsOfFpPathAlgebra]] returns the relators used to define
the quotient of a path algebra.

<<Declaration of RelatorsOfFpPathAlgebra>>=
DeclareAttribute( "RelatorsOfFpPathAlgebra",
    IsSubalgebraFpPathAlgebra and IsFullFpPathAlgebra);
@ %def RelatorsOfFpPathAlgebra

The implementation returns the generators of the ideal used to define
the quotient of a path algebra.

<<Implementation of RelatorsOfFpPathAlgebra>>=
InstallMethod( RelatorsOfFpPathAlgebra,
    "for a quotient of a path algebra",
    true,
    [IsSubalgebraFpPathAlgebra and IsFullFpPathAlgebra], 0,
    A -> GeneratorsOfIdeal(ElementsFamily(FamilyObj(A))!.ideal)
    );
@

\paragraph{Inclusion in Source}
We include the ordering code here into the source.

<<Path Algebra Declarations>>=
<<OrderingOfAlgebra Declaration>>
@ 

<<Path Algebra Implementation>>=
<<OrderedBy Implementation>>
<<Quotient Path Algebra Record Access>>
<<Implementation of RelatorsOfFpPathAlgebra>>
@ 

\subsection{\groebner\ Bases}
\label{subsection:PathAlgebraGroebnerBases}

\groebner bases are a special set of relations, which provides a means for
determining if an element is contained in an ideal. \groebner bases also are
used to find normal forms for quotients of path algebras. 

\paragraph{Attribute}
The [[GroebnerBasisOfIdeal]] attribute returns a \groebner\ basis for
a two sided ideal $I$ with respect to the ordering of elements already
existing for the ring. 

<<GroebnerBasisOfIdeal Declaration>>=
DeclareAttribute( "GroebnerBasisOfIdeal", IsRing );
@ %def GroebnerBasisOfIdeal

The [[GroebnerBasisOfLeftIdeal]] attribute returns a left \groebner\
basis for a left ideal.

<<GroebnerBasisOfLeftIdeal Declaration>>=
DeclareAttribute( "GroebnerBasisOfLeftIdeal", IsRing );
@ %def GroebnerBasisOfLeftIdeal

The [[GroebnerBasisOfRightIdeal]] attribute returns a right \groebner\
basis for a right ideal.

<<GroebnerBasisOfRightIdeal Declaration>>=
DeclareAttribute( "GroebnerBasisOfRightIdeal", IsRing );
@ %def GroebnerBasisOfRightIdeal

\paragraph{Inclusion in Source}
We include the \groebner\ basis related attributes and code here.

<<Path Algebra Declarations>>=
<<GroebnerBasisOfIdeal Declaration>>
<<GroebnerBasisOfLeftIdeal Declaration>>
<<GroebnerBasisOfRightIdeal Declaration>>
@ 

\subsection{Attributes of Quotients of Path Algebras}
\label{subsection:QuotientPathAlgebraAttributes}

\paragraph{Attribute}
The [[IsFiniteDimensional]] attribute returns [[true]] if the quotient
of a path algebra is finite dimensional over its field or [[false]]
otherwise.  This can only be answered with certainty in two cases: if
the path algebra used to create the quotient is finite dimensional, or
if a finite \groebner\ basis has been computed for the quotient
algebra. If the path algebra is finite dimensional, this attribute is
true.

<<Implementation of IsFiniteDimensional for Quotients of Path Algebras>>=
InstallMethod( IsFiniteDimensional,
    "for quotients of path algebras",
    true,
    [IsSubalgebraFpPathAlgebra and IsFullFpPathAlgebra], 0,
    function( A )
        local gb, fam;

        fam := ElementsFamily(FamilyObj(A));
        gb := GroebnerBasisOfIdeal(fam!.ideal);
        if IsCompleteGroebnerBasis(gb) then
            return AdmitsFinitelyManyNontips(gb);
        elif IsFiniteDimensional(fam!.pathRing) then
            return true;
        else
            TryNextMethod();
        fi;
    end );
@ 

\paragraph{Attribute}
The [[Dimension]] attribute returns the dimension over the defining
field of a quotient of a path algebra. This can only be determined in
two cases: if the path algebra used to create the quotient is finite
dimensional, or if a finite \groebner\ basis has been computed for the 
quotient algebra.

<<Implementation of Dimension for Quotients Of Path Algebras>>=
InstallMethod( Dimension,
    "for quotients of path algebras",
    true,
    [IsSubalgebraFpPathAlgebra and IsFullFpPathAlgebra], 0,
    function( A )
        local gb, fam;

        fam := ElementsFamily(FamilyObj(A));
        gb := GroebnerBasisOfIdeal(fam!.ideal);
        if IsCompleteGroebnerBasis(gb) then
            return NontipSize(gb);
        else
            TryNextMethod();
        fi;
    end );
@ 

\paragraph{Include In Source}

<<Path Algebra Implementation>>=
<<Implementation of IsFiniteDimensional for Quotients of Path Algebras>>
<<Implementation of Dimension for Quotients Of Path Algebras>>
@ 

\subsection{Bases of Quotients of Path Algebras}

\begin{SLOPPY}
\paragraph{Attribute}

The [[CanonicalBasis]] attribute is defined for all free left
modules. For quotients of path algebras, the canonical basis is made
up of the nontips of complete, tip reduced, \groebner\ basis embedded
in the quotient. The implementation is taken from that in
\texttt{mgmring.gi} in the GAP library. We use the (misnamed)
[[IsCanonicalBasisFreeMagmaRingRep]] representation to encode our
canonical basis.
\end{SLOPPY}

<<Implementation of CanonicalBasis for quotients of path algebras>>=
InstallMethod( CanonicalBasis,
    "for quotients of path algebras",
    true,
    [IsSubalgebraFpPathAlgebra], 0,
    function( A )
        local B, fam, zero, nontips, parent, parentFam, parentOne;

        fam := ElementsFamily( FamilyObj( A ) );
        zero := Zero(LeftActingDomain(A));
        parent := fam!.pathAlgebra;
        parentFam := ElementsFamily( FamilyObj( parent ) );
        parentOne := One(parentFam!.zeroRing);

        B := Objectify( NewType( FamilyObj( A ),
                            IsBasis and IsCanonicalBasisFreeMagmaRingRep ),
                        rec() );
        SetUnderlyingLeftModule( B, A );
        if HasGroebnerBasisOfIdeal( fam!.ideal )
           and IsCompleteGroebnerBasis( GroebnerBasisOfIdeal( fam!.ideal ) )
           and IsFiniteDimensional( A )
        then
            nontips := Nontips(GroebnerBasisOfIdeal( fam!.ideal ));
            nontips := List( nontips, 
                             x -> ElementOfMagmaRing( parentFam,
                                                      parentFam!.zeroRing,
                                                      [parentOne],
                                                      [x] ) );
            SetBasisVectors( B,
                List( EnumeratorSorted( nontips ), 
                      x -> ElementOfFpPathAlgebra( fam, x, true ) ) );
            B!.zerovector := List( BasisVectors( B ), x -> zero );
        fi;
        SetIsCanonicalBasis( B, true );
        return B;
     end );
@ 

\paragraph{Attribute}
The [[BasisOfDomain]] function returns an arbitrary basis of a
quotient of a path algebra. We return the canonical basis.

<<Implementation of BasisOfDomain for quotients of path algebras>>=
InstallMethod( BasisOfDomain,
    "for quotients of path algebras (CanonicalBasis)",
    true,
    [IsSubalgebraFpPathAlgebra], 10,
    CanonicalBasis );
@ 

\paragraph{Operation}
The [[Coefficients]] operation returns the coefficients of basis
elements for an element of a quotient of a path algebra. We currently
only implement this for canonical bases.

<<Implementation of Coefficients for quotients of path algebras>>=
InstallMethod( Coefficients,
    "for canonical bases of quotients of path algebras",
    IsCollsElms,
    [IsCanonicalBasisFreeMagmaRingRep, 
     IsElementOfFpPathAlgebra and IsNormalForm], 0,
    function( B, e )
        local coeffs, data, elms, i, fam;

        data := CoefficientsAndMagmaElements( e![1] );
        coeffs := ShallowCopy( B!.zerovector );
        fam := ElementsFamily(FamilyObj( UnderlyingLeftModule( B ) ));
        elms := EnumeratorSorted( Nontips( GroebnerBasisOfIdeal(fam!.ideal)));
        for i in [1, 3 .. Length( data )-1 ] do
            coeffs[ PositionSet( elms, data[i] ) ] := data[i+1];
        od;
        return coeffs;
    end );
@ 

\paragraph{Inclusion in Source}

<<Path Algebra Implementation>>=
<<Implementation of CanonicalBasis for quotients of path algebras>>
<<Implementation of BasisOfDomain for quotients of path algebras>>
<<Implementation of Coefficients for quotients of path algebras>>
@ 

\section{Elements of Quotients of Path Algebras}
\label{section:QuotientPathAlgebraElements}
The declarations and implementation in this section draw heavily on
the finitely presented algebra implementation existing in [[algfp.gd]]
and [[algfp.gi]] for the GAP4 library. See those files for additional
details on this implementation.

\subsection{Categories}
\label{subsection:QuotientPathAlgebraElementCategories}

\paragraph{Category}
The [[IsElementOfFpPathAlgebra]] category contains all elements of
quotient path algebras.
\begin{verbatim}
IsElementOfFpPathAlgebra(e)
\end{verbatim}

[[IsElementOfFpPathAlgebra]] category is a specialized version
of [[IsRingElement]] in that every element of a quotient of a path
algebra is also a ring element.

<<IsElementOfFpPathAlgebra Declaration>>=
DeclareCategory( "IsElementOfFpPathAlgebra", IsRingElement );
@ %def IsElementOfFpPathAlgebra

Additionally, we declare collection categories and family categories
for elements of quotients of path algebras.

<<IsElementOfFpPathAlgebra Collection Declaration>>=
DeclareCategoryCollections( "IsElementOfFpPathAlgebra" );
@ %def IsElementOfFpPathAlgebraCollection

<<IsElementOfFpPathAlgebra Family Declaration>>=
DeclareCategoryFamily( "IsElementOfFpPathAlgebra" );
@ %def IsElementOfFpPathAlgebraFamily

\paragraph{Info Class}
The [[InfoElementOfFpPathAlgebra]] information class is used to
show progress of some of the computations for elements of quotients of
path algebras. See the section on debugging facilities in the GAP4
reference manual for more details.
\begin{verbatim}
InfoElementOfFpPathAlgebra
\end{verbatim}

<<InfoElementOfFpPathAlgebra Declaration>>=
DeclareInfoClass( "InfoElementOfFpPathAlgebra" );
@ %def InfoElementOfFpPathAlgebra

\paragraph{Attribute}
The [[NormalFormFunction]] attribute is to store a function for
computing normal forms of elements. It is associated with families of
quotient path algebra elements.

<<NormalFormFunction Declaration>>=
DeclareAttribute( "NormalFormFunction", IsFamily );
@ %def NormalFormFunction

\paragraph{Inclusion in Source}
We include the categories for elements of quotients of path algebras here.

<<Path Algebra Declarations>>=
<<IsElementOfFpPathAlgebra Declaration>>
<<IsElementOfFpPathAlgebra Collection Declaration>>
<<IsElementOfFpPathAlgebra Family Declaration>>
<<InfoElementOfFpPathAlgebra Declaration>>
<<Declaration of IsFullFpPathAlgebra>>
<<Declaration of RelatorsOfFpPathAlgebra>>
<<NormalFormFunction Declaration>>
@ 

\subsection{Element Creation}
\label{subsection:QuotientPathAlgebraElementCreation}

\paragraph{Operation}
The [[ElementOfFpPathAlgebra]] operation creates an element in a
quotient of a path algebra from an element in the path algebra.

<<ElementOfFpPathAlgebra Declaration>>=
DeclareOperation( "ElementOfFpPathAlgebra", 
    [ IsElementOfFpPathAlgebraFamily, IsRingElement, IsBool ] );
@ %def ElementOfFpPathAlgebra

<<ElementOfFpPathAlgebra Implementation>>=
InstallMethod( ElementOfFpPathAlgebra, 
    "for family of quotient path algebra elements and a ring element",
    true,
    [ IsElementOfFpPathAlgebraFamily, IsRingElement, IsBool ], 0,
    function( fam, elm, normal )
        return Objectify( fam!.defaultType, [ Immutable(elm) ]);
    end );
@ 

\begin{SLOPPY}
If the family can compute normal forms, this implementation of
[[ElementOfFpPathAlgebra]] automatically puts an element into normal
form.
\end{SLOPPY}

<<ElementOfFpPathAlgebra Implementation>>=
InstallMethod( ElementOfFpPathAlgebra,
    "for family of quotient path algebra elements and a ring element (n.f.)",
    true,
    [ IsElementOfFpPathAlgebraFamily and HasNormalFormFunction,
      IsRingElement, IsBool ], 0,
    function( fam, elm, normal )
        if normal then
            return Objectify( fam!.normalizedType, [ Immutable(elm) ] );
        else
            return NormalFormFunction(fam)(fam, elm);
        fi;
    end );
@ 

\paragraph{Inclusion in Source}
We include the methods for constructing elements of quotients of path
algebras here.

<<Path Algebra Declarations>>=
<<ElementOfFpPathAlgebra Declaration>>
@ 

<<Path Algebra Implementation>>=
<<ElementOfFpPathAlgebra Implementation>>
@ 

\subsection{Attributes}
\label{subsection:QuotientPathAlgebraElementAttributes}
Let $A$ be a quotient of a path algebra and let $e$ be an element in
$A$.

\paragraph{Attribute}
Elements that do not know they are in normal form are automatically
assumed to not be in normal form. The default implementation of
[[IsNormalForm]] just returns false.

<<Implementation of IsNormalForm for f.p. path algebra elements>>=
InstallMethod( IsNormalForm,
    "for f.p. algebra elements",
    true,
    [IsElementOfFpPathAlgebra], 0,
    ReturnFalse );
@ 

\paragraph{Attribute}
The [[ExtRepOfObj]] attribute is used to return the external
representation of an object. The external representation of an element
of a quotient of a path algebra is a list of length 2, the first entry
being the zero coefficient and the second entry being a zipped list of
coefficients and external representations of monomials.

\begin{NOTE}This should be removed
if the GAP4 library version for f.p. algebra
elements is generalized.
\end{NOTE}

\begin{verbatim}
ExtRepOfObj(e)
\end{verbatim}

<<ExtRepOfObj Implementation>>=
InstallMethod( ExtRepOfObj,
    "for element of a quotient of a path algebra",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep ], 0,
    elm -> ExtRepOfObj( elm![1] ) );
@ 

\paragraph{Inclusion in Source}
We include the properties and attributes for elements of quotients of
path algebras here.

<<Path Algebra Implementation>>=
<<ExtRepOfObj Implementation>>
<<Implementation of IsNormalForm for f.p. path algebra elements>>
@ 

\subsection{Operations}
\label{subsection:QuotientPathAlgebraElementOperations}

\paragraph{Operation}
The [[LeadingTerm]] operation returns the leading term of $e$ with
respect to the ordering for $A$. This implementation for elements in
quotients of path algebras delegates to the path algebra implementation.

<<LeadingTerm Implementation>>=
InstallMethod( LeadingTerm,
    "for a quotient of path algebra element",
    true,
    [IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function(e)
      local lt, fam;

      fam := FamilyObj(e);
      lt :=  LeadingTerm(e![1]);
      return ElementOfFpPathAlgebra(fam, lt, IsNormalForm(e));
    end );
@ 

\paragraph{Operation}
The [[LeadingCoefficient]] operation returns the leading coefficient
of an element $e$ with respect to the ordering for $A$ containing
$e$. This implementation for elements in quotients of path algebras
delegates to the path algebra implementation.

<<LeadingCoefficient Implementation>>=
InstallOtherMethod( LeadingCoefficient, 
    "for elements of quotients of path algebras",
    true,
    [IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function(e)
        return LeadingCoefficient(e![1]);
    end );
@ 

\paragraph{Operation}
The [[LeadingMonomial]] operation returns the leading monomial of an
element $e$ with respect to the ordering for $A$ containing $e$. This
implementation for elements in quotients of path algebras delegates to 
the path algebra implementation. The value returned is an element of
the underlying quiver.

<<LeadingMonomial Implementation>>=
InstallOtherMethod( LeadingMonomial, 
    "for elements of quotients of path algebras",
    true,
    [IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function(e)
        return LeadingMonomial(e![1]);
    end );
@ 

\paragraph{Operation}
The [[IsLeftUniform]] operation checks a path algebra element to see
if each term starts with the same vertex. The result is [[true]] if
each term does start with the same vertex, and [[false]]
otherwise. The zero path is always considered left uniform.

<<Implementation of IsLeftUniform>>=
InstallMethod( IsLeftUniform,
    "for quotient of path algebra elements",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function( e )
        return IsLeftUniform(e![1]);
    end );
@ 

\paragraph{Operation}
The [[IsRightUniform]] operation checks a path algebra element to see
if each term ends with the same vertex. The result is [[true]] if
each term does end with the same vertex, and [[false]]
otherwise. The zero path is always considered right uniform.

<<Implementation of IsRightUniform>>=
InstallMethod( IsRightUniform,
    "for quotient of path algebra elements",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function( e )
        return IsRightUniform(e![1]);
    end );
@ 

\paragraph{Operation} The [[IsUniform]] operation checks a path
algebra element to see if each term starts with the same vertex and
ends with the same vertex (the common starting and ending vertices do not have
to be the same). The result is [[true]] if each term does
have a common starting and common ending vertex, and [[false]]
otherwise. The zero path is always considered uniform.

<<Implementation of IsUniform>>=
InstallMethod( IsUniform,
    "for quotient of path algebra elements",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep], 0,
    function( e )
        return IsUniform(e![1]);
    end );
@ 


\paragraph{Operation}
The [[=]] operation compares two elements to see if their normal forms
are equal. This comparision should \textbf{NOT} cause a \groebner\
basis of the algebra to be computed.
\begin{verbatim}
e = f
\end{verbatim}

We can only test equality for elements in normal form.

<<Quotient Path Algebra Element Equality Implementation>>=
InstallMethod( \=,
     "for normal forms of elements of quotients of path algebras",
    IsIdenticalObj,
    [IsElementOfFpPathAlgebra and IsPackedElementDefaultRep and IsNormalForm,
     IsElementOfFpPathAlgebra and IsPackedElementDefaultRep and IsNormalForm],
    0,
    function(e, f)
        return ExtRepOfObj(e![1]) = ExtRepOfObj(f![1]);
    end );
@ 
                                                  
\paragraph{Operation}
The [[<]] operation compares two elements $e$ and $f$ and returns
[[true]] if $e < f$ or [[false]] otherwise. For monomials, the
comparision is done directly with the ordering of the quotient
algebra. For polynomials, the tips are compared. If they are equal,
the next maximal terms are considered. This process repeats until
unequal terms are encountered. The empty term is considered smaller
than all other terms.
\begin{verbatim}
e < f
\end{verbatim}

<<Quotient Path Algebra Element Comparison Implementation>>=
InstallMethod( \<, "for elements of quotients of path algebras",
    IsIdenticalObj,
    [IsElementOfFpPathAlgebra and IsNormalForm and IsPackedElementDefaultRep,
     IsElementOfFpPathAlgebra and IsNormalForm and IsPackedElementDefaultRep],
    0,
    function(e, f)
        return e![1] < f![1];
    end );
@ 

\paragraph{Operation}
The [[+]] operation adds two elements of quotients of path
algebras. This can delegate to the addition operation for the path
algebra making sure the result is in the proper family. See
[[algfp.gi]] for an example of how this is done in finitely presented
algebras, delegating to free algebras. The [[+]] operation should not
invoke the function for computing normal forms.

\begin{NOTE}
This may not need to be implemented,
depending on the generalization of fp algebra
implementation.
\end{NOTE}

\begin{verbatim}
e + f
\end{verbatim}

<<Addition for Elements of Quotient Path Algebras>>=
InstallMethod(\+,"quotient path algebra elements", IsIdenticalObj,
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra,
     IsPackedElementDefaultRep and IsElementOfFpPathAlgebra], 0,
    function(e, f)
        return ElementOfFpPathAlgebra(FamilyObj(e),e![1]+f![1], 
                                      IsNormalForm(e) and IsNormalForm(f));
    end );
@ 

\paragraph{Operation}
The [[-]] operation subtracts an element $f$ from $e$. This can
delegate to the subtraction operation for the path algebra making sure
the result is in the proper family. See [[algfp.gi]] for an example of
how this is done in finitely presented algebras, delegating to free
algebras. The [[-]] operation should not invoke the function for
computing normal forms.

\begin{NOTE}
This may not need to be implemented,
depending on the generalization of fp algebra implementation.
\end{NOTE}

\begin{verbatim}
e - f
\end{verbatim}

<<Subtraction for Elements of Quotient Path Algebras>>=
InstallMethod(\-,"quotient path algebra elements", IsIdenticalObj,
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra,
     IsPackedElementDefaultRep and IsElementOfFpPathAlgebra], 0,
    function(e, f)
        return ElementOfFpPathAlgebra(FamilyObj(e),e![1]-f![1], 
                                      IsNormalForm(e) and IsNormalForm(f));
    end );
@ 

\paragraph{Operation}
The [[*]] operation multiplies two elements of quotients of path
algebras. This can delegate to the addition operation for the path
algebra making sure the result is in the proper family. See
[[algfp.gi]] for an example of how this is done in finitely presented
algebras, delegating to free algebras. The [[*]] operation should not
invoke the function for computing normal forms.

\begin{NOTE}This may not need to be implemented,
depending on the generalization of fp algebra
implementation.
\end{NOTE}

\begin{verbatim}
e * f
\end{verbatim}

First, we define multiplication for two elements in quotient path
algebra.

<<Multiplication for Elements of Quotient Path Algebras>>=
InstallMethod(\*,"quotient path algebra elements", IsIdenticalObj,
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra,
     IsPackedElementDefaultRep and IsElementOfFpPathAlgebra], 0,
    function(e, f)
        return ElementOfFpPathAlgebra(FamilyObj(e),e![1]*f![1], false);
    end);
@ 

Now, define multiplication between ring elements and elements in
quotient path algebra.

<<Multiplication for Elements of Quotient Path Algebras>>=
InstallMethod(\*,"ring el * quot path algebra el",IsRingsMagmaRings,
    [IsRingElement,
     IsPackedElementDefaultRep and IsElementOfFpPathAlgebra],0,
    function(e,f)
        return ElementOfFpPathAlgebra(FamilyObj(f),e*f![1], IsNormalForm(f));
    end);
@ 

<<Multiplication for Elements of Quotient Path Algebras>>=
InstallMethod(\*,"quot path algebra el*ring el",IsMagmaRingsRings,
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra,
     IsRingElement],0,
    function(e,f)
        return ElementOfFpPathAlgebra(FamilyObj(e),e![1]*f, IsNormalForm(e));
    end);
@ 

The next two methods are convienence methods so that we can multiply
quiver elements by quotient of path algebra elements.

<<Multiplication for Elements of Quotient Path Algebras>>=
InstallMethod(\*,
    "quiver element and quotient of path algebra element",
    true, # should check to see that p is in correct quiver
    [IsPath, 
     IsPackedElementDefaultRep and IsElementOfFpPathAlgebra], 0,
    function( p, e )
        return ElementOfFpPathAlgebra(FamilyObj(e), p*e![1], false);
    end);
@ 

<<Multiplication for Elements of Quotient Path Algebras>>=
InstallMethod(\*,
    "quotient of path algebra element and quiver element",
    true, # should check to see that p is in correct quiver
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra,
     IsPath], 0,
    function( e, p )
        return ElementOfFpPathAlgebra(FamilyObj(e), e![1] * p, false);
    end);
@ 

\paragraph{Method}
The [[AdditiveInverse]] method returns the additive inverse of an
element. It can delegate back to the additive inverse implementation
for path algebras.  See [[algfp.gi]] for an example of how this is
done in finitely presented algebras, delegating to free algebras. The
[[AdditiveInverse]] method should not invoke the function for
computing normal forms.
\begin{verbatim}
AdditiveInverse(e)
\end{verbatim}

<<Additive Inverse for Elements of Quotient Path Algebras>>=
InstallMethod(AdditiveInverseOp,
    "quotient path algebra elements", true,
    [IsPackedElementDefaultRep and IsElementOfFpPathAlgebra], 0,
    function(e)
        return
            ElementOfFpPathAlgebra(FamilyObj(e),AdditiveInverse(e![1]),
                                   IsNormalForm(e));
    end);
@ 

\paragraph{Method}
The [[One]] method returns the unit of an element. It can delegate
back to the additive inverse implementation for path algebras.  See
[[algfp.gi]] for an example of how this is done in finitely presented
algebras, delegating to free algebras. The [[One]] method should not
invoke the function for computing normal forms.
\begin{verbatim}
One(e)
\end{verbatim}

<<One for Elements of Quotient Path Algebras>>=
InstallOtherMethod( OneOp,
    "for quotient path algebra algebra element",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep ], 0,
    function( e )
    local one;
    one:= One( e![1] );
    if one <> fail then
      one:= ElementOfFpPathAlgebra( FamilyObj( e ), one, true );
    fi;
    return one;
    end );
@ 

\paragraph{Method}
The [[Zero]] method returns the zero of an element. It can delegate
back to the additive inverse implementation for path algebras.  See
[[algfp.gi]] for an example of how this is done in finitely presented
algebras, delegating to free algebras. The [[Zero]] method should not
invoke the function for computing normal forms.
\begin{verbatim}
Zero(e)
\end{verbatim}

<<Zero for Elements of Quotient Path Algebras>>=
InstallMethod( ZeroOp,
    "for a quotient path algebra element",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep ], 0,
    e -> ElementOfFpPathAlgebra( FamilyObj( e ), Zero( e![1] ), true ) );
@ 

\paragraph{Operation}

We include the implementation of [[MappedExpression]] for
[[FpPathAlgebra]] elements. This delegates to the [[MappedExpression]]
for path algebras.

<<Implementation of MappedExpression for f.p. path algebras>>=
InstallOtherMethod( MappedExpression,
    "for f.p. path algebra, and two lists of generators",
    IsElmsCollsX,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep,
      IsHomogeneousList, IsHomogeneousList ], 0,
    function( expr, gens1, gens2 )
        return MappedExpression( expr![1], List(gens1, x -> x![1]), gens2 );
    end );
@ 

\paragraph{Inclusion in Source}
We include the operations for elements of quotients of path algebras here.

<<Path Algebra Implementation>>=
<<Quotient Path Algebra Element Equality Implementation>>
<<Quotient Path Algebra Element Comparison Implementation>>
<<Addition for Elements of Quotient Path Algebras>>
<<Subtraction for Elements of Quotient Path Algebras>>
<<Multiplication for Elements of Quotient Path Algebras>>
<<Additive Inverse for Elements of Quotient Path Algebras>>
<<One for Elements of Quotient Path Algebras>>
<<Zero for Elements of Quotient Path Algebras>>
<<Implementation of MappedExpression for f.p. path algebras>>
@ 

\section{Output}\label{section:QuotientOfPathAlgebraOutput}

We implement the [[PrintObj]] function for elements of quotients of
path algebras.

<<PrintObj Implementation for Elements of Quotients of Path Algebras>>=
InstallMethod( PrintObj,
    "quotient of path algebra elements",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep ], 0,
    function( e )
    Print( "[", e![1], "]" );
    end );
@

\paragraph{Inclusion in Source}
<<Path Algebra Implementation>>=
<<PrintObj Implementation for Elements of Quotients of Path Algebras>>
@

\section{Representaion Conversion}
\label{section:QuotientOfPathAlgebraRepresentationConversions}

The methods in this section implement conversion to and from external
representations of elements in the quotient of path algebras.

\paragraph{Operation}

The [[ExtRepOfObj]] method returns the external representation of an element
of a quotient of a path algebra.

<<ExtRepOfObj for elements of quotients of path algebras>>=
InstallMethod( ExtRepOfObj,
    "for quotient of path algebra elements",
    true,
    [ IsElementOfFpPathAlgebra and IsPackedElementDefaultRep ], 0,
    elm -> ExtRepOfObj( elm![1] ) );
@

\paragraph{Operation}

The [[ObjByExtRep]] method returns the object associated with the given
external representation.

<<ObjByExtRep for elements of quotients of path algebras>>=
InstallMethod( ObjByExtRep,
    "for family of f.p. algebra elements with normal form",
    true,
    [ IsElementOfFpPathAlgebraFamily,
      IsList ], 0,
    function( Fam, descr )
        local pathAlgFam;

        pathAlgFam := ElementsFamily(FamilyObj(Fam!.pathAlgebra));

        return ElementOfFpPathAlgebra(Fam, 
               ObjByExtRep( pathAlgFam, descr ), false);
    end );
@

\paragraph{Inclusion In Source}

<<Path Algebra Implementation>>=
<<ObjByExtRep for elements of quotients of path algebras>>
<<ExtRepOfObj for elements of quotients of path algebras>>
@

\section{Subalgebras and Ideals of Quotients of Path Algebras}
\label{section:QuotientPathAlgebrasSubalgebrasIdeals}

This section implements the methods needed to support subalgebras and
ideals of quotients of path algebras. Most of this is based on
implementations in \texttt{mgmring.gi}. The idea is to handle free
left modules of quotient of path algebra elements. GAP has support for 
creating ``Nice'' versions of free left modules, so all that needs to
be implemented is a way to convert a free left module of a quotient of 
a path algebra to a ``Nice'' one and back again.

\subsection{Conversion Between Nice Encoding}

The implementations in this section are almost exactly the same as
those in \texttt{mgmring.gi} in the GAP library.

\paragraph{Nice Basis Handler}
This code installs the necessary information for working with
nice bases for path algebras.

<<Declaration of nice basis handling for f.p. path algebras>>=
DeclareHandlingByNiceBasis( "IsFpPathAlgebraElementsSpace",
    "for spaces of f.p. path algebras" );
@

<<Installation of Nice Bases for Fp Path Algebras>>=
InstallHandlingByNiceBasis( "IsFpPathAlgebraElementsSpace", rec(
    <<Nice basis detection for f.p. path algebras>>,
    <<Nice basis information for f.p. path algebras>>,
    <<Nice vector conversion for f.p. path algebras>>,
    <<Ugly vector conversion for f.p. path algebras>>
    ));
@

Any collection of f.p. path algebra elements is handled by a nice
basis.

<<Nice basis detection for f.p. path algebras>>=
detect := function( F, gens, V, zero )
    return IsElementOfFpPathAlgebraCollection( V );
end
@

This information describes how to convert a space over f.p.
path algebra elements to a nice encoding.

<<Nice basis information for f.p. path algebras>>=
NiceFreeLeftModuleInfo := function( V )
    local gens, monomials, gen, list, i, zero, info;

    gens := GeneratorsOfLeftModule( V );
    monomials := [];

    for gen in gens do
        list := CoefficientsAndMagmaElements( gen![1] );
        for i in [1, 3 .. Length(list) - 1] do
            AddSet( monomials, list[i] );
        od;
    od;

    V!.monomials := monomials;

    zero := Zero( V )![1]![1];

    info := rec(monomials := monomials,
                zerocoeff := zero,
                family := ElementsFamily( FamilyObj( V ) ) );

    if IsEmpty( monomials ) then
        info.zerovector := [ Zero( LeftActingDomain( V ) ) ];
    else
        info.zerovector := ListWithIdenticalEntries( Length( monomials ),
                                                         zero );
    fi;
    return info;
end
@

The [[NiceVector]] operation converts an element of $V$ to a ``nice''
encoding. 

<<Nice vector conversion for f.p. path algebras>>=
NiceVector := function(V, v)
    local info, c, monomials, i, pos;

    info := NiceFreeLeftModuleInfo( V );
    c := ShallowCopy( info.zerovector );
    v := CoefficientsAndMagmaElements( v![1] );
    monomials := info.monomials;

    for i in [2, 4 .. Length(v)] do
        pos := PositionSet( monomials, v[ i-1 ] );
        if pos = fail then
            return fail;
        fi;
        c[ pos ] := v[i];
    od;
    return c;
end
@

The [[UglyVector]] converts a vector in ``nice'' encoding to an
element in $V$. The [[UglyVector]] operation is declared in the GAP
library.

<<Ugly vector conversion for f.p. path algebras>>=
UglyVector := function( V, r )
    local elem, info, parentFam;
    info := NiceFreeLeftModuleInfo( V );
    if Length( r ) <> Length( info.zerovector ) then
        return fail;
    elif IsEmpty( info.monomials ) then
        if IsZero( r ) then
            return Zero( V );
        else
            return fail;
        fi;
    fi;
    parentFam := ElementsFamily( FamilyObj( info.family!.pathAlgebra ) );
    elem := ElementOfMagmaRing( parentFam, parentFam!.zeroRing,
                                r, info.monomials );
    return ElementOfFpPathAlgebra( info.family, elem, true );
end
@ 

\paragraph{Inclusion in Source}

<<Path Algebra Declarations>>=
<<Declaration of nice basis handling for f.p. path algebras>>
@

<<Path Algebra Implementation>>=
<<Installation of Nice Bases for Fp Path Algebras>>
@ 
