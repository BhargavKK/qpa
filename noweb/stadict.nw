% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This is an implementation of a static dictionary for use
%              with the Aho-Corasick pattern matching algorithm.
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: stadict.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Static Dictionaries}
\label{chapter:StaticDictionaries}

\section{Overview}
\label{section:StaticDictionariesOverview}

Static dictionaries are used to store a fixed set of patterns $P$ to
search for in a text $T$. In \hopf, the patterns may be any dense list
of GAP objects that can be compared with the $<$ operation and tested
for equality with the $=$ operation.

\section{Source Files}
\label{section:StaticDictionariesSourceFiles}

<<[[stadict.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: stadict.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Declarations for Static Dictionaries>>
@

<<[[stadict.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: stadict.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Implementations for Static Dictionaries>>
@

\section{Filters}
\label{section:StaticDictionaryFilters}

\paragraph{Information Class}
The [[InfoStaticDictionary]] information class is used to print out
informative messages for static dictionary computations.

<<Declaration of InfoStaticDictionary information class>>=
DeclareInfoClass( "InfoStaticDictionary" );
@ %def InfoStaticDictionary

\paragraph{Category} 
The category [[IsStaticDictionary]] contains all static pattern
matching dictionaries. 

<<Declaration for Static Dictionary Category>>=
DeclareCategory("IsStaticDictionary", IsObject);
@ %def IsStaticDictionary

\paragraph{Representation}
The [[IsStaticDictionaryDefaultRep]] is a component object
representation with one slot: [[tree]] containing the Aho-Corasick
search tree.

<<Declaration of Static Dictionary Representation>>=
DeclareRepresentation("IsStaticDictionaryDefaultRep", 
                      IsAttributeStoringRep, ["tree"]);
@ %def IsStaticDictionaryDefaultRep

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of InfoStaticDictionary information class>>
<<Declaration for Static Dictionary Category>>
<<Declaration of Static Dictionary Representation>>
@

\section{Attributes}
\label{section:StaticDictionaryAttributes}

\paragraph{Attribute}
The [[Patterns]] attribute returns the list of patterns stored in the
static dictionary.

<<Declaration of the Static Dictionary Patterns Attribute>>=
DeclareAttribute( "Patterns", IsStaticDictionary );
@ %def Patterns

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of the Static Dictionary Patterns Attribute>>
@

\section{Creation}
\label{section:StaticDictionaryCreation}

\paragraph{Global Function}
The [[StaticDictionary]] global function creates a static dictionary
from a list of patterns (a dense list of GAP objects). An Aho-Corasick 
search tree is created by the [[StaticDictionary]] constructor.

<<Declaration of Static Dictionary Constructor>>=
DeclareGlobalFunction("StaticDictionary");
@ %def StaticDictionary

<<Implementation of Static Dictionary Constructor>>=
InstallGlobalFunction( StaticDictionary, function(patterns)
    local pattern, tree, dict, i, l, newNode, char, v, w, q, fam,
          parent, currentNode;

    if not IsDenseList(patterns) then
        Error("<patterns> must be a dense list");
    fi;

    <<Create the keyword tree>>
    <<Process the failure links>>
    <<Create the static dictionary object>>

    return dict;
end );
@

Creating the keyword tree is straightforward. A description of its
creation is given in Gusfield~\cite[3.4]{Gusfield}, and this
implementation follows that description.

<<Create the keyword tree>>=
tree := rec( labels := [],
            children := [],
            patterns := [] );

tree.failureNode := tree;

for i in [1..Length(patterns)] do
    pattern := patterns[i];
    currentNode := tree;
    for char in pattern do
        l := Position(currentNode.labels, char);
        if l = fail then
            Add(currentNode.labels, char);
            newNode := rec( label := char,
                            labels := [],
                            children := [],
                            parent := currentNode,
                            patterns := [] );
            Add(currentNode.children, newNode);
            currentNode := newNode;
        else
            currentNode := currentNode.children[l];
        fi;
    od;
    Add(currentNode.patterns, i);
od;
@

We now process the failure links in the keyword tree. We perform a
breadth first search of the keyword tree, computing the node to move
to when a failure occurs in the search. This algorithm for computing
the node is given in Gusfield. The variable [[q]] is used as the queue 
for the breadth first search. The queue is implemented using a GAP
list and list functions.

<<Process the failure links>>=
q := [];
List(tree.children, function(x)
    x.failureNode := tree;
    Append(q, x.children);
    return x;
end );

while not IsEmpty(q) do
    v := q[1];
    q := q{[2..Length(q)]};
    parent := v.parent;
    char := v.label;
    w := parent.failureNode;
    while w <> tree 
          and Position(w.labels, char) = fail
    do
        w := w.failureNode;
    od;
    l := Position(w.labels, char);
    if l = fail then
        v.failureNode := tree;
    else
        v.failureNode := w.children[l];
    fi;
    if not IsEmpty(v.failureNode.patterns) then
        v.outputNode := v.failureNode;
    elif IsBound(v.failureNode.outputNode) then
        v.outputNode := v.failureNode.outputNode;
    fi;
    Append(q, v.children);
od;
@

Now we create the GAP object for the static dictionary. The keyword
tree and patterns are stored in the object when it is created.

<<Create the static dictionary object>>=
    fam := NewFamily( "StaticDictionaryFamily", IsStaticDictionary );
    dict := Objectify( 
                NewType( fam, IsStaticDictionary
                              and IsStaticDictionaryDefaultRep ),
                rec( tree := tree ) ); 
    SetPatterns( dict, Immutable(patterns) );
@

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of Static Dictionary Constructor>>
@

<<Implementations for Static Dictionaries>>=
<<Implementation of Static Dictionary Constructor>>
@

\section{Operations}

\paragraph{Operation} 
The [[Search]] operation takes a dense list of GAP objects as the text
and searches for patterns in the static dictionary in the text. The
operation returns a list of tuples. Each tuple contain the ending
location where a pattern was found and a list of the patterns ending
at that location within the text.

<<Declaration for Static Dictionary Search Operation>>=
DeclareOperation( "Search", [IsStaticDictionary, IsDenseList] );
@ %def Search

The implementation is based on the \textit{full AC search} algorithm
given in Gusfield. Readers are referred there for details.

<<Implementation of the Static Dictionary Search Operation>>=
InstallMethod( Search,
    "for static dictionaries in their default rep.",
    true,
    [IsStaticDictionary and IsStaticDictionaryDefaultRep,
     IsDenseList], 10,
    function(dict, text)
        local c, w, m, j, k, currentNode, matches, retval;

        c := 1;
        w := dict!.tree;
        m := Length(text);
        retval := [];

        repeat
            j := Position(w.labels, text[c]);
            while j <> fail do
                currentNode := w.children[j];
                matches := [];
                Append(matches,currentNode.patterns);
                while IsBound(currentNode.outputNode) do
                    currentNode := currentNode.outputNode;
                    Append(matches,currentNode.patterns);
                od;
                if not IsEmpty(matches) then
                    Add(retval, [c, matches]);
                fi;
                w := w.children[j];
                c := c + 1;
                if c <= m then
                    j := Position(w.labels, text[c]);
                else
                    j := fail;
                fi;
            od;
            if w = dict!.tree then
                c := c + 1;
            fi;
            w := w.failureNode;
         until c > m;

         return retval;
    end );
@

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration for Static Dictionary Search Operation>>
@

<<Implementations for Static Dictionaries>>=
<<Implementation of the Static Dictionary Search Operation>>
@

\section{Output}
\paragraph{Method}

The [[ViewObj]] method prints out that the object is a static
dictionary and how many patterns it holds.

<<Implementation of ViewObj for Static Dictionaries>>=
InstallMethod( ViewObj,
    "for static dictionaries",
    true,
    [IsStaticDictionary], 0,
    function(dict)
        local l;
        Print("<static dictionary containing ");
        l := Length(Patterns(dict));
        Print(l);
        Print(" pattern");
        if l > 1 then
            Print("s");
        fi;
        Print(">");
    end );
@

\paragraph{Inclusion In Source}

<<Implementations for Static Dictionaries>>=
<<Implementation of ViewObj for Static Dictionaries>>
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Static dictionaries for quivers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Static Dictionaries for Quivers}
\label{section:StaticDictionariesForQuivers}

In this section we provide a special implementation of static
dictionaries for quivers. The implementation is similar to that of the 
standard Aho-Corasick algorithm. The major difference is that whenever 
a transition is made from the root of the keyword tree, the starting
vertex is used to perform the initial transition, then any remaining
transitions are performed.

Static dictionaries for quivers provide the additional functionalities 
of checking to see if the difference between the language generated by 
the quiver and the words containing any word in the dictionary is
finite, counting the number of words in the difference, and
efficiently enumerating the words in the difference.

\subsection{Filters}
\label{section:StaticDictionaryQuiverFilters}

\paragraph{Category} 
The category [[IsQuiverStaticDictionary]] contains all static pattern
matching dictionaries. 

<<Declaration for Static Dictionary for Quivers Category>>=
DeclareCategory("IsQuiverStaticDictionary", IsStaticDictionary);
@ %def IsQuiverStaticDictionary

\paragraph{Representation}
The [[IsStaticDictionaryDefaultRep]] is a component object
representation with one slot: [[tree]] containing the Aho-Corasick
search tree.

<<Declaration of Static Dictionary for Quivers Representation>>=
DeclareRepresentation("IsQuiverStaticDictionaryDefaultRep", 
                      IsStaticDictionaryDefaultRep, ["tsorted"]);
@ %def IsQuiverStaticDictionaryDefaultRep

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration for Static Dictionary for Quivers Category>>
<<Declaration of Static Dictionary for Quivers Representation>>
@

\subsection{Attributes and Properties}
\label{section:StaticDictionaryQuiverAttributes}

All of these attributes are implemented under the assumption that no
pattern is a subword of any other pattern.

\paragraph{Property}
The [[IsFiniteDifference]] property returns [[true]] if the difference 
of the language generated by the quiver and the set of words
containing the patterns in the static dictionary is finite. The
property returns false otherwise.

<<Declaration of IsFiniteDifference property>>=
DeclareProperty( "IsFiniteDifference", IsQuiverStaticDictionary );
@ %def IsFiniteDifference

The implementation of the [[IsFiniteDifference]] property extends the
Aho-Corasick keyword tree with failure links to a deterministic finite
automata. The DFA is then checked for the existence of a cycle. If one
exists, the difference of languages is infinite, and [[false]] is
returned. Otherwise, the difference is finited, so [[true]] is
returned. 

<<Implementation of IsFiniteDifference property>>=
InstallMethod( IsFiniteDifference,
    "for static dictionaries for quivers",
    true,
    [IsQuiverStaticDictionary and IsQuiverStaticDictionaryDefaultRep], 0,
    function( dict )
        local tree, q, cycleExists, target, arrow, parent, outgoing,
              l, fNode, vertex, gray, black, visit, tsorted, i, currentNode;

        tree := dict!.tree;
        Info( InfoStaticDictionary, 1, "Creating finite automata...");
        <<Create the finite automata>>
        Info( InfoStaticDictionary, 1, "Checking for cycle...");
        <<Check for a cycle in the finite automata>>

        return not cycleExists;
    end );
@ 

The nodes in the keyword tree are processed in breadth first search
order. The variable [[q]] acts as our queue for the breadth first
search. The root of the tree is completely determined, so we start
processing with the depth 1 nodes.

<<Create the finite automata>>=
q := [];

<<Process the first level of the keyword tree>>
<<Process the remainder of the keyword tree>>
@ 

The first level of the keyword tree represents the transition on a
vertex. This level needs to be handled specially because in the case
of a failure, we need to go to the root then transition on the target
vertex of the arrow that failed to match to correctly set up the
automata.

<<Process the first level of the keyword tree>>=
for i in [1..Length(tree.children)] do
    currentNode := tree.children[i];
    vertex := tree.labels[i];
    Append(q, Filtered(currentNode.children, x -> not IsEmpty(x.children)));

    for outgoing in OutgoingArrowsOfVertex(vertex) do
        l := Position(currentNode.labels, outgoing);
        if l = fail then
            Add(currentNode.labels, outgoing);
            l := Position(tree.labels, TargetOfPath(outgoing));
            Add(currentNode.children, tree.children[l]);
        fi;
    od;
od;
@ 

For each node in the keyword tree, get the arrow $a$ used to reach the
node. List the outgoing arrows of the target of $a$. For those arrows
that cannot be matched, follow the failure link and match. Note, at
most one failure link needs to be processed since the automaton has
been filled in for all previous levels. The leaves of the keyword tree
that accept some pattern should not be extended.

<<Process the remainder of the keyword tree>>=
while not IsEmpty(q) do
    currentNode := q[1];
    q := q{[2..Length(q)]};
    Append(q, Filtered(currentNode.children, x -> IsEmpty(x.patterns)));
    parent := currentNode.parent;

    arrow := currentNode.label;
    target := TargetOfPath(arrow);
    for outgoing in OutgoingArrowsOfVertex(target) do
        l := Position(currentNode.labels, outgoing);
        if l = fail then
            fNode := currentNode.failureNode;
            l := Position(fNode.labels, outgoing);
            Assert(1, l <> fail, "Outgoing arrow wasn't found!");
            Add(currentNode.labels, outgoing);
            Add(currentNode.children, fNode.children[l]);
        fi;
    od;
od;
@ 

We base the check for a cycle on the depth-first search algorithm
description given in Cormen, Leiserson, and
Rivest~\cite[Ch. 23]{CormenEtAl}. Since we can reach every node from
the root stored in variable [[tree]], we simplify the implementation
slightly. As stated in Cormen, Leiserson, and Rivest, if one of the
children of a visited vertex is already colored gray, that means the
edge between the vertices is gray, implying it is a back edge. If
there exists a back edge, there must exist a cycle. We store the
vertices in topologically sorted order in the variable [[tsorted]].

<<Check for a cycle in the finite automata>>=
gray := 1;
black := 2;
cycleExists := false;
tsorted := [];

visit := function(u)
    local v;

    u.color := gray;
    for v in u.children do
        if not IsBound(v.color) then
            visit(v);
        elif v.color = gray then
            cycleExists := true;
        fi;
    od;
    Add(tsorted, u);
    u.color := black;
end;

visit(tree);
if not cycleExists then
    tsorted := Reversed(tsorted);
    dict!.tsorted := tsorted;
fi;
@ 

\paragraph{Attribute}
The [[DifferenceSize]] attribute returns the size of the difference of
the language generated by the quiver and the set of words containing
the patterns in the static dictionary. If the difference is infinite,
the [[infinity]] value is returned.

<<Declaration of DifferenceSize attribute>>=
DeclareAttribute( "DifferenceSize", IsQuiverStaticDictionary );
@ %def DifferenceSize

\begin{SLOPPY}
To calculate the size, we walk through the finite automata created in
[[IsFiniteDifference]] in topological order. A topological ordering
exists when the difference of languages is finite. 
\end{SLOPPY}

<<Implementation of DifferenceSize>>=
InstallMethod( DifferenceSize,
    "for static dictionaries for quivers",
    true,
    [IsQuiverStaticDictionary and IsQuiverStaticDictionaryDefaultRep], 0,
    function(dict)
        local tree, tsorted, total, node, child;

        if IsFiniteDifference(dict) then
            tree := dict!.tree;
            tsorted := dict!.tsorted;
            total := -1;                # don't count the root node

            for node in tsorted do
                 node.pathCount := 0;
            od;

            tree.pathCount := 1;

            for node in tsorted do
                for child in node.children do
                    child.pathCount := child.pathCount + node.pathCount;
                od;
                # Leaves accepting patterns are tips, so don't count them.
                if IsEmpty(node.patterns) 
                then
                    total := total + node.pathCount;
                fi;
                # Free memory (later)
                #Unbind(node.pathCount);
            od;
            return total;
        else
            return infinity;
        fi;
    end );
@ 

\paragraph{Attribute}
The [[DifferenceWords]] attribute returns an enumeration of words in the
difference of the language generated by the quiver and the set of
words containing the patterns in the static dictionary. If the
difference is infinite, [[fail]] is returned. 

<<Declaration of DifferenceWords attribute>>=
DeclareAttribute( "DifferenceWords", IsQuiverStaticDictionary );
@ 

<<Implementation of DifferenceWords>>=
InstallMethod( DifferenceWords,
    "for static dictionaries for quivers",
    true,
    [IsQuiverStaticDictionary and IsQuiverStaticDictionaryDefaultRep], 0,
    function( dict )
        local tree, tsorted, paths, node, arrow, path, i, newPaths;

        if IsFiniteDifference(dict) then
            tree := dict!.tree;
            tsorted := dict!.tsorted;
            paths := [];

            for node in tsorted do
                 node.paths := [];
            od;

            for i in [1..Length(tree.children)] do
                tree.children[i].paths := [tree.labels[i]];
            od;

            for node in tsorted do
                for i in [1..Length(node.children)] do
                    newPaths := List(node.paths, x -> x*node.labels[i]);
                    Append(node.children[i].paths, newPaths);
                od;

                # Leaves accepting patterns are tips, so don't count them.
                if IsEmpty(node.patterns)
                then
                    Append(paths, node.paths);
                fi;
                # Free memory
                # Unbind(node.paths);
            od;
            Sort(paths);
            return paths;
        else
            return fail;
        fi;
    end );
@ 
    
\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of IsFiniteDifference property>>
<<Declaration of DifferenceSize attribute>>
<<Declaration of DifferenceWords attribute>>
@

<<Implementations for Static Dictionaries>>=
<<Implementation of IsFiniteDifference property>>
<<Implementation of DifferenceSize>>
<<Implementation of DifferenceWords>>
@ 

\section{Creation}
\label{section:QuiverStaticDictionaryCreation}

\paragraph{Global Function}
The [[QuiverStaticDictionary]] global function creates a static dictionary
from a list of patterns (a dense list of GAP objects). An Aho-Corasick 
search tree is created by the [[QuiverStaticDictionary]] constructor.

<<Declaration of Static Dictionary for Quivers Constructor>>=
DeclareGlobalFunction("QuiverStaticDictionary");
@

<<Implementation of Static Dictionary for Quivers Constructor>>=
InstallGlobalFunction( QuiverStaticDictionary, function(quiver, patterns)
    local pattern, tree, dict, i, l, newNode, char, v, w, q, fam,
          parent, currentNode, elemFam;

    if not IsQuiver(quiver) then
        Error("<quiver> must be a quiver");
    fi;

    elemFam := ElementsFamily(FamilyObj(quiver));

    if not IsDenseList(patterns) 
       or not ForAll(patterns, x -> IsIdenticalObj(FamilyObj(x), elemFam))
    then
        Error("<patterns> must be a dense list of elements in <quiver>");
    fi;

    <<Create the keyword tree for quivers>>
    <<Process the failure links for quivers>>
    <<Create the static dictionary object for quivers>>

    return dict;
end );
@

Creating the keyword tree is straightforward. A description of its
creation is given in Gusfield~\cite[3.4]{Gusfield}, and this
implementation follows that description.

<<Create the keyword tree for quivers>>=
tree := rec( labels := [],
            children := [],
            patterns := [] );

tree.failureNode := tree;

# Initialize for the vertices
for v in VerticesOfQuiver(quiver) do
    Add(tree.labels, v);
    newNode := rec( label := v,
                    labels := [],
                    children := [],
                    parent := tree,
                    patterns := [] );
    Add(tree.children, newNode);
od;

for i in [1..Length(patterns)] do
    pattern := WalkOfPath(patterns[i]);

    # starting node is a transition on the starting vertex.
    v := SourceOfPath(patterns[i]);
    currentNode := tree.children[Position(tree.labels, v)];

    for char in pattern do
        l := Position(currentNode.labels, char);
        if l = fail then
            Add(currentNode.labels, char);
            newNode := rec( label := char,
                            labels := [],
                            children := [],
                            parent := currentNode,
                            patterns := [] );
            Add(currentNode.children, newNode);
            currentNode := newNode;
        else
            currentNode := currentNode.children[l];
        fi;
    od;
    Add(currentNode.patterns, i);
od;
@

We now process the failure links in the keyword tree. We perform a
breadth first search of the keyword tree, computing the node to move
to when a failure occurs in the search. This algorithm for computing
the node is given in Gusfield. The variable [[q]] is used as the queue 
for the breadth first search. The queue is implemented using a GAP
list and list functions.

<<Process the failure links for quivers>>=
q := [];
List(tree.children, function(x)
    x.failureNode := tree;
    Append(q, x.children);
    return x;
end );

while not IsEmpty(q) do
    v := q[1];
    q := q{[2..Length(q)]};
    parent := v.parent;
    char := parent.labels[Position(parent.children, v)];
    w := parent.failureNode;
    while w <> tree 
          and Position(w.labels, char) = fail
    do
        w := w.failureNode;
    od;
    l := Position(w.labels, char);
    if l = fail then
        v.failureNode := tree.children[Position(tree.labels, TargetOfPath(char))];
    else
        v.failureNode := w.children[l];
    fi;
    if not IsEmpty(v.failureNode.patterns) then
        v.outputNode := v.failureNode;
    elif IsBound(v.failureNode.outputNode) then
        v.outputNode := v.failureNode.outputNode;
    fi;
    Append(q, v.children);
od;
@

Now we create the GAP object for the static dictionary. The keyword
tree and patterns are stored in the object when it is created.

<<Create the static dictionary object for quivers>>=
    fam := NewFamily( "QuiverStaticDictionaryFamily",
                      IsQuiverStaticDictionary );
    dict := Objectify( 
                NewType( fam, IsQuiverStaticDictionary
                              and IsQuiverStaticDictionaryDefaultRep ),
                rec( tree := tree ) ); 
    SetPatterns( dict, ShallowCopy(patterns) );
@

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of Static Dictionary for Quivers Constructor>>
@

<<Implementations for Static Dictionaries>>=
<<Implementation of Static Dictionary for Quivers Constructor>>
@

\section{Operations}

\paragraph{Operation} 
The [[Search]] operation takes a path in a quiver as the text and
searches for patterns in the static dictionary in the text. The
operation returns a list of tuples. Each tuple contain the ending
location where a pattern was found and a list of the patterns ending
at that location within the text.  The implementation is based on the
\textit{full AC search} algorithm given in Gusfield. Readers are
referred there for details.

<<Implementation of the Static Dictionary for Quivers Search Operation>>=
InstallOtherMethod( Search,
    "for static dictionaries for quivers in their default rep.",
    true,
    [IsQuiverStaticDictionary and IsStaticDictionaryDefaultRep,
     IsPath], 10,
    function(dict, text)
        local c, w, m, j, k, currentNode, matches, retval, tree, l;

        tree := dict!.tree;
        w := tree.children[Position(tree.labels, SourceOfPath(text))];
        text := WalkOfPath(text);
        c := 1;
        m := Length(text);
        retval := [];

        while c <= m do
            j := Position(w.labels, text[c]);
            while j <> fail do
                currentNode := w.children[j];
                matches := [];
                Append(matches,currentNode.patterns);
                while IsBound(currentNode.outputNode) do
                    currentNode := currentNode.outputNode;
                    Append(matches,currentNode.patterns);
                od;
                if not IsEmpty(matches) then
                    Add(retval, [c, matches]);
                fi;
                w := w.children[j];
                c := c + 1;
                if c <= m then
                    j := Position(w.labels, text[c]);
                else
                    j := fail;
                fi;
            od;
            if w = tree then
                c := c + 1;
                if c <= m then
                    l := Position(tree.labels, SourceOfPath(text[c]));
                    w := tree.children[l];
                fi;
            else
                w := w.failureNode;
            fi;
         od;

         return retval;
    end );
@

\paragraph{Operation}
The [[PrefixSearch]] operation is a specialized version of [[Search]]
that looks for words contained in the dictionary that are prefixes of
the text. It does not follow failure links, since traversing a failure 
link would imply that a match could not be a prefix.

<<Declaration of PrefixSearch for Quiver static dictionaries>>=
DeclareOperation( "PrefixSearch", [IsQuiverStaticDictionary, IsObject] );
@ %def PrefixSearch

<<Implementation of PrefixSearch for Quiver static dictionaries>>=
InstallMethod( PrefixSearch,
    "for quiver static dictionaries and paths",
    true,
    [ IsQuiverStaticDictionary and IsStaticDictionaryDefaultRep, IsPath ], 0,
    function( dict, text )
        local w, c, m, retval, j, matches, currentNode;

        w := dict!.tree;
        j := Position(w.labels, SourceOfPath(text));
        text := WalkOfPath(text);
        c := 0;
        m := Length(text);
        retval := [];

        while j <> fail do
            currentNode := w.children[j];
            matches := [];
            Append(matches,currentNode.patterns);
            if not IsEmpty(matches) then
                Add(retval, [c, matches]);
            fi;
            w := w.children[j];
            c := c + 1;
            if c <= m then
                j := Position(w.labels, text[c]);
            else
                j := fail;
            fi;
        od;
        return retval;
     end );
@ 

\paragraph{Inclusion In Source}

<<Declarations for Static Dictionaries>>=
<<Declaration of PrefixSearch for Quiver static dictionaries>>
@ 

<<Implementations for Static Dictionaries>>=
<<Implementation of the Static Dictionary for Quivers Search Operation>>
<<Implementation of PrefixSearch for Quiver static dictionaries>>
@

\section{Output}
\paragraph{Method}

The [[ViewObj]] method prints out that the object is a static
dictionary and how many patterns it holds.

<<Implementation of ViewObj for Static Dictionaries>>=
InstallMethod( ViewObj,
    "for static dictionaries",
    true,
    [IsQuiverStaticDictionary], 0,
    function(dict)
        local l;
        Print("<static dictionary for quivers containing ");
        l := Length(Patterns(dict));
        Print(l);
        Print(" path");
        if l > 1 then
            Print("s");
        fi;
        Print(">");
    end );
@

\paragraph{Inclusion In Source}

<<Implementations for Static Dictionaries>>=
<<Implementation of ViewObj for Static Dictionaries>>
@
