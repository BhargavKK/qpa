% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: Implementation of Sleator and Tarjan's dynamic tree
%              data structure using naive partitioning.
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: dyntree.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dynamic Trees}
\label{chapter:DynamicTrees}

\section{Overview}
\label{section:DynamicTreesOverview}
In this chapter we implement a dynamic tree data structure as
described by Sleator and Tarjan~\cite{SleatorTarjan1983b}. 
The amortized running time for operations is
$O(\log n)$ where $n$ is the number of vertices in the tree.

\section{Source Files}
<<[[dyntree.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: dyntree.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Dynamic Tree Declarations>>
@

<<[[dyntree.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: dyntree.nw,v 1.1 2010/05/07 13:30:13 sunnyquiver Exp $
<<Dynamic Tree Implementations>>
@

\section{Categories}
\label{section:DynamicTreeCategories}

In this section, we define categories for dynamic tree data
structures. In particular, we need dynamic tree nodes that keep track
of their parents via dashed lines as described in Sleator and
Tarjan. All other information is provided by the dynamic path
implementation used to implement the dynamic trees.

\paragraph{Category}
The [[IsDynamicTree]] category contains all dynamic trees. This
category is a subcategory of [[IsObject]] since it needs no other
functions.

<<IsDynamicTree Declaration>>=
DeclareCategory( "IsDynamicTree", IsObject);
@ %def IsDynamicTree

\paragraph{Representation}
The [[IsDefaultDynamicTreeRep]] is the default internal representation
of dynamic trees. It contains an [[item]] field to store data and a
[[parent]] field to store the parent of the dynamic tree node. The
[[left]] and [[right]] fields are for the solid binary tree links.
All other information is obtained from dynamic path operations.

<<IsDefaultDynamicTreeRep Declaration>>=
DeclareRepresentation( "IsDefaultDynamicTreeRep",
    IsComponentObjectRep,
    [ "item", "parent", "left", "right" ] );
@ %def IsDefaultDynamicTreeRep

\paragraph{Family}
The [[DynamicTreeFamily]] contains all nodes for dynamic trees since
they can interact with each other to construct dynamic trees.

<<DynamicTreeFamily Declaration>>=
BindGlobal( "DynamicTreeFamily", 
    NewFamily("DynamicTreeFamily", IsDynamicTree) );
@ %def DynamicTreeFamily

\paragraph{Inclusion in Source}

<<Dynamic Tree Declarations>>=
<<IsDynamicTree Declaration>>
<<IsDefaultDynamicTreeRep Declaration>>
<<DynamicTreeFamily Declaration>>
@ 

\section{Operations}
\label{section:DynamicTreeOperations}

This section implements operations a dynamic tree data structure.


\paragraph{Operation}
The equality operation for dynamic trees is just a call to
[[IsIdenticalObj]].

<<Equality for Dynamic Trees Implementation>>=
InstallMethod( \=,
    "for splay trees",
    IsIdenticalObj,
    [IsDynamicTree, IsDynamicTree], 0,
    IS_IDENTICAL_OBJ );
@ 

\paragraph{Global Function}
The [[CreateDynamicTree]] function creates a dynamic tree node and its 
associated dynamic path node. The newly created node is returned by
this function.

<<CreateDynamicTree Declaration>>=
DeclareGlobalFunction( "CreateDynamicTree" );
@ %def CreateDynamicTree

<<CreateDynamicTree Implementation>>=
InstallGlobalFunction( CreateDynamicTree, function(arg)
    local dynTree;

    if Length(arg) = 0 or Length(arg) = 1 then
        dynTree := Objectify(NewType(DynamicTreeFamily, 
                IsDynamicTree and IsDefaultDynamicTreeRep),
            rec( parent := 0, left := 0, right := 0 ) );
        if Length(arg) = 1 then
            dynTree!.item := arg[1];
        fi;
        return dynTree;
    else
        Error("must have 0 or 1 arguments");
    fi;
    end );
@ 

\paragraph{Operations}
The [[LeftRotateDynamicTree]] and [[RightRotateDynamicTree]] are the
first primitive operations for manipulating dynamic trees. This
operation rearranges the left and right children of a solid subtree.

<<LeftRotateDynamicTree Declaration>>=
DeclareOperation("LeftRotateDynamicTree", [IsDynamicTree]);
@ %def LeftRotateDynamicTree

<<RightRotateDynamicTree Declaration>>=
DeclareOperation("RightRotateDynamicTree", [IsDynamicTree]);
@ %def RightRotateDynamicTree

<<LeftRotateDynamicTree Implementation>>=
InstallMethod( LeftRotateDynamicTree,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(y)
        local x, z;

        if y <> 0 then        
            x := y!.right;
            z := y!.parent;
            if z <> 0 then
                if z!.left = y then
                    z!.left := x;
                elif z!.right = y then
                    z!.right := x;
                fi;
            fi;
            y!.right := x!.left;
            x!.left := y;
            x!.parent := z;
            y!.parent := x;
            if y!.right <> 0 then
                y!.right!.parent := y;
            fi;
        fi;
    end );
@     

<<RightRotateDynamicTree Implementation>>=
InstallMethod( RightRotateDynamicTree,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(y)
        local x, z;

        if y <> 0 then        
            x := y!.left;
            z := y!.parent;
            if z <> 0 then
                if z!.left = y then
                    z!.left := x;
                elif z!.right = y then
                    z!.right := x;
                fi;
            fi;
            y!.left := x!.right;
            x!.right := y;
            x!.parent := z;
            y!.parent := x;
            if y!.left <> 0 then
                y!.left!.parent := y;
            fi;
        fi;
    end );
@     

\paragraph{Operation}
The [[SpliceDynamicTree]] operation takes a middle child [[v]] of a
dynamic tree node [[w]] and swaps it with the left child of [[w]].

<<SpliceDynamicTree Declaration>>=
DeclareOperation("SpliceDynamicTree", [IsDynamicTree]);
@ %def SpliceDynamicTree

<<SpliceDynamicTree Implementation>>=
InstallMethod( SpliceDynamicTree,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(v)
        local u, w;

        w := v!.parent;
        if w <> 0 then
            Assert(1, v <> w!.left and v <> w!.right, 
                   "The node is not a middle child");
            w!.left := v;
        fi;
    end );
@ 

\paragraph{Operation}
The [[SplayDynamicTree]] operation performs the splaying operation as
described in Sleator and Tarjan for link/cut trees.

<<SplayDynamicTree Declaration>>=
DeclareOperation("SplayDynamicTree", [IsDynamicTree]);
@ %def SplayDynamicTree

<<SplayDynamicTree Implementation>>=
InstallMethod( SplayDynamicTree,
    "for dynamic trees in default representation",
    true,
    [ IsDynamicTree and IsDefaultDynamicTreeRep ], 0,
    function( x )
        local Left, Right, Splay, Parent, Grandparent, 
              p, w;

        <<Local Left function>>
        <<Local Right function>>
        <<Local Parent function>>
        <<Local Grandparent function>>
        <<Local Splay function>>

        w := x;
        while Parent(w) <> 0 do
            Splay(w);
            w := Parent(w);
        od;
        w := x;
        while Parent(w) <> 0 do
            SpliceDynamicTree(w);
            w := Parent(w);
        od;
        Splay(x);
    end );
@ 

<<Local Left function>>=
Left := function(t)
    if t = 0 then
        return 0;
    else
        return t!.left;
    fi;
end;
@ 

<<Local Right function>>=
Right := function(t)
    if t = 0 then
        return 0;
    else
        return t!.right;
    fi;
end;
@ 

<<Local Parent function>>=
Parent := function(t)
    if t = 0 then
        return 0;
    else
        return t!.parent;
    fi;
end;
@ 

<<Local Grandparent function>>=
Grandparent := t -> Parent(Parent(t));
@ 

<<Local Splay function>>=
Splay := function(t)
    local p, g;

    p := Parent(t);
    while t = Left(p) or t = Right(p) do
        g := Grandparent(t);
        if t = Left(p) then
            if p = Left(g) then 
                RightRotateDynamicTree(g);
            fi;
            RightRotateDynamicTree(Parent(t));
        elif t = Right(p) then
            if p = Right(g) then
                LeftRotateDynamicTree(g);
            fi;
            LeftRotateDynamicTree(Parent(t));
        fi;
        p := Parent(t);
    od;
end;
@ 

\paragraph{Operation}
The [[RootOfDynamicTree]] operation returns the root node of the
dynamic tree in which [[v]] is contained.

<<RootOfDynamicTree Declaration>>=
DeclareOperation( "RootOfDynamicTree", [IsDynamicTree] );
@ %def RootOfDynamicTree

<<RootOfDynamicTree Implementation>>=
InstallMethod( RootOfDynamicTree,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(v)
        local w;

        SplayDynamicTree(v);
        w := v;
        while w!.right <> 0 do
            w := w!.right;
        od;
        SplayDynamicTree(w);
        return w;
    end );
@ 

\paragraph{Operation}
The [[LinkDynamicTrees]] operation combines two nodes [[v]] and [[w]]
in dynamic trees together.

<<LinkDynamicTrees Declaration>>=
DeclareOperation( "LinkDynamicTrees", [IsDynamicTree, IsDynamicTree] );
@ %def LinkDynamicTrees

<<LinkDynamicTrees Implementation>>=
InstallMethod( LinkDynamicTrees,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep,
     IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(v, w)
        SplayDynamicTree(v);
        SplayDynamicTree(w);
        v!.parent := w;
    end );
@ 

\paragraph{Operation}
The [[CutDynamicTree]] divides the dynamic tree in two by deleting
the edge from [[v]] to its parent. This assumes [[v]] is not a root.

<<CutDynamicTree Declaration>>=
DeclareOperation( "CutDynamicTree", [IsDynamicTree] );
@ %def CutDynamicTree

<<CutDynamicTree Implementation>>=
InstallMethod( CutDynamicTree,
    "for dynamic trees in default representation",
    true,
    [IsDynamicTree and IsDefaultDynamicTreeRep], 0,
    function(v)
        SplayDynamicTree(v);
        if v!.right <> 0 then
            v!.right!.parent := 0;
            v!.right := 0;
        fi;
    end );
@ 

\paragraph{Inclusion in Source}

<<Dynamic Tree Declarations>>=
<<CreateDynamicTree Declaration>>
<<RightRotateDynamicTree Declaration>>
<<LeftRotateDynamicTree Declaration>>
<<SpliceDynamicTree Declaration>>
<<SplayDynamicTree Declaration>>
<<RootOfDynamicTree Declaration>>
<<LinkDynamicTrees Declaration>>
<<CutDynamicTree Declaration>>
@ 

<<Dynamic Tree Implementations>>=
<<Equality for Dynamic Trees Implementation>>
<<CreateDynamicTree Implementation>>
<<RightRotateDynamicTree Implementation>>
<<LeftRotateDynamicTree Implementation>>
<<SpliceDynamicTree Implementation>>
<<SplayDynamicTree Implementation>>
<<RootOfDynamicTree Implementation>>
<<LinkDynamicTrees Implementation>>
<<CutDynamicTree Implementation>>
@ 
