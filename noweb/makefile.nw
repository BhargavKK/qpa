% -*- mode: Noweb; noweb-code-mode: makefile-mode -*-%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This file contains the Makefiles used by the Hopf project.
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: makefile.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Makefiles}

\section{Overview}
Makefiles are used to control the build process for \hopf. The
makefile for \hopf\ has the following structure.

<<[[Makefile]]>>=
###############################################################################
# HOPF Project Makefile
# DESCRIPTION: This makefile controls the building process of the Hopf project
#
<<Makefile Copyright Notice>>
#
# This file is generated from makefiles.nw. DO NOT EDIT.
###############################################################################
<<Suffixes>>
<<Noweb Sources>>
<<LaTeX Sources>>
<<Definitions Sources>>
<<EPS Sources>>
<<All Target>>
<<Documentation Targets>>
<<Definitions Target>>
<<Template Targets>>
<<GAP Source Targets>>
<<Test Targets>>
<<Makefile Target>>
<<Clean Target>>
<<Release Target>>
<<Tag Target>>
@ 

\section{Noweb Sources}
The variable [[NOWEBSRCS]] contains a list of the noweb files that
make up \hopf. The files must be ordered as they are to appear in the
\hopf\ project document. The file [[hopf.nw]] should always appear
first on this line and [[end.nw]] should always appear last.

<<Noweb Sources>>=
NOWEBSRCS=hopf.nw legal.nw docstds.nw codestds.nw package.nw \
        dyntree.nw dyndict.nw stadict.nw \
        algebra.nw quiver.nw ordering.nw \
        alggrp.nw algpath.nw groebner.nw opal.nw \
        modright.nw pamodule.nw gaptens.nw algtens.nw hopfalg.nw decomp.nw \
        present.nw idempotent.nw makefile.nw end.nw
@ 
\section{LaTeX Sources}
The variable [[LATEXSRCS]] contains a list of the \LaTeX srouce files
that must be generated from the noweb source files to get
the documentation for \hopf.
The \LaTeX\ files must be ordered exactly as the noweb files
are ordered in [[NOWEBSRCS]].

<<LaTeX Sources>>=
LATEXSRCS=hopf.latex legal.latex docstds.latex codestds.latex package.latex \
         dyntree.latex dyndict.latex stadict.latex \
        algebra.latex quiver.latex ordering.latex \
        alggrp.latex algpath.latex groebner.latex opal.latex \
        modright.latex pamodule.latex gaptens.latex algtens.latex \
        hopfalg.latex present.latex idempotent.latex decomp.latex\
        makefile.latex end.latex
@ 
\section{Definitions Sources}
The variable [[DEFINITIONS]] contains a list of the definitions files
that must be generated from the noweb source files to get
the indexes for \hopf.
The definitions files must be the same as the [[NOWEBSRCS]] files.

<<Definitions Sources>>=
DEFINITIONS=hopf.defs legal.defs docstds.defs codestds.defs package.defs \
        dyntree.defs dyndict.defs stadict.defs \
        algebra.defs quiver.defs ordering.defs \
        alggrp.defs algpath.defs groebner.defs opal.defs \
        modright.defs pamodule.defs gaptens.defs algtens.defs \
        decomp.defs hopfalg.defs \
        makefile.defs present.defs idempotent.defs \
        end.defs

@ 
\section{EPS Sources}
The variable [[EPSSOURCES]] contains a list of the eps files
that the \hopf\ documentation requires.

<<EPS Sources>>=
EPSSOURCES=docstruct.eps

@ 
\section{All Target}
The [[all]] target builds the entire \hopf\ system. The target depends
on creating documentation and all of the sources.

<<All Target>>=
all: doc source

@ 

\section{Suffixes}

Suffixes produce automatic rules for common makefile targets. The list
of additional suffixes include fig files and encapsulated postscript
files.
They also include suffixes for doing indexing using \texttt{nodefs}
and \texttt{noindex}.

<<Suffixes>>=
.SUFFIXES: .eps .fig .latex .defs .nw

@ 
To create an eps file from a fig file, we use the \texttt{fig2dev}.

<<Suffixes>>=
.fig.eps:
        fig2dev -L ps $< > $@

@ 
To create a file of noweb definitions for each noweb source file
requires \texttt{nodefs}.

<<Suffixes>>=
.nw.defs:
        nodefs $*.nw > $*.defs

@
To create a \LaTeX\ source file for each noweb source file
requires \texttt{noweave}.

<<Suffixes>>=
.defs.latex:
        noweave -delay -indexfrom alldefs -filter ./extendID $*.nw > $*.latex

@

\section{Documentation Targets}

This target generates the \LaTeX\ project documentation for \hopf.
The main documentation target depends on the postscript version of the
documentation being created.

<<Documentation Targets>>=
HOPF=hopf_project
doc: $(HOPF).ps

@ The postscript version of the documentation depends on the last
generation time of the DVI file. The [[dvips]] command is used to
generate the resulting postscript file.

<<Documentation Targets>>=
$(HOPF).ps: $(HOPF).dvi
        dvips -t letter -o $(HOPF).ps $(HOPF).dvi

@
The DVI file depends on the \LaTeX\ file and external figures that
exist for the document. The target begins by executing \LaTeX\ twice
to guarantee that the table of contents is constructed
properly. \LaTeX\ is then executed until the cross-references are
correct. to generate the final DVI file. This idea came from the noweb
distribution.

<<Documentation Targets>>=
$(HOPF).dvi: $(HOPF).tex $(EPSSOURCES)
        @echo "THIS MAY TAKE A WHILE.  RELAX!"
        extra_mem_top=700000 extra_mem_bot=70000 \
        latex '\batchmode\input $(HOPF)' 
        bibtex $(HOPF)
        noindex $(HOPF)
        extra_mem_top=700000 extra_mem_bot=70000 \
        latex '\scrollmode\input $(HOPF)' 
        @while grep -s 'Rerun to get cross-references right' $(HOPF).log; do\
                noindex $(HOPF); \
                extra_mem_top=700000 extra_mem_bot=70000 \
                latex '\scrollmode\input $(HOPF)'; done

@
The \verb,hopf_project.tex, file depends on changes to the \LaTeX\ sources.

<<Documentation Targets>>=
$(HOPF).tex: alldefs $(LATEXSRCS)
        cat $(LATEXSRCS) | cpif $(HOPF).tex

@ 
\section{Definitions Target}

This target contains a sorted list of all the definitions
in all the noweb files.

<<Definitions Target>>=

alldefs: $(DEFINITIONS)
        sort -u $(DEFINITIONS) | cpif alldefs
@
\section{Template Targets}
The [[templates]] target generates all template files used by
\hopf. This target depends on [[template.nw]] and [[template.tex]],
the two template files for \hopf\ documentation.

<<Template Targets>>=
templates: template.nw template.tex

@ 
The [[template.nw]] target generates the template file for \hopf\
literate program documentation. It depends on [[docstds.nw]] and
[[legal.nw]].

<<Template Targets>>=
template.nw: legal.nw docstds.nw
        notangle -R"[[$@]]" legal.nw docstds.nw > $@

@ 
The [[template.tex]] target generates the template file for \hopf\
user documentation. It depents on [[docstand.nw]] and [[legal.nw]].

<<Template Targets>>=
template.tex: legal.nw docstds.nw
        notangle -R"[[$@]]" legal.nw docstds.nw > $@

@ 
\section{GAP Source Targets}
The following targets are for generating GAP source files in the
[[gap]] directory. The [[gap]] directory is a sibling of the [[noweb]]
directory, so we declare a variable to denote that here.

<<GAP Directory>>=
GAPDIR=../gap
@

The [[source]] target generates all of the GAP source. It depends on
all of the GAP source files and the initialization file.

<<GAP Source Target>>=
source: $(GAPSRCS) $(GAPINIT) ../bin/$(GAPOPAL)

@ 

We also need to know which files contain GAP sources. The [[GAPNAMES]]
variable stores just the basename of each \noweb\ file containing GAP
source. The [[GAPSRCS]] variable creates all of the appropriate source
file names from the [[GAPNAMES]] variable. The [[GAPINIT]] variable
contains the name of the initialization file for the \hopf\
package. The [[GAPOPAL]] variable contains the name of the GAP to Opal
interface script.

<<GAP Source Files>>=
GAPNAMES=dyntree dyndict stadict quiver algpath \
         ordering groebner opal pamodule algebra alggrp modright\
         gaptens algtens hopfalg decomp idempotent present

GAPSRCS=$(GAPNAMES:%=$(GAPDIR)/%.gd) $(GAPNAMES:%=$(GAPDIR)/%.gi)
GAPINIT=../init.g ../read.g ../gap/banner.g
GAPOPAL=gapopal
@ 

The next two rules actually use [[notangle]] to generate the source
files from the appropriate \noweb\ file.

<<GAP Source Creation Rules>>=
$(GAPDIR)/%.gd: %.nw
        notangle -R"[[$*.gd]]" $< > $@

$(GAPDIR)/%.gi: %.nw
        notangle -R"[[$*.gi]]" $< > $@

../%.g: package.nw
        notangle -R"[[$*.g]]" $< > $@

../bin/$(GAPOPAL): opal.nw
        notangle -R"[[$(GAPOPAL)]]" $< > $@
        chmod 755 $@
@ 

The GAP targets all put together follow.

<<GAP Source Targets>>=
<<GAP Directory>>
<<GAP Source Files>>
<<GAP Source Target>>
<<GAP Source Creation Rules>>
@ 

\section{GAP Test Targets}
The following targets are for generating test files and running tests
automatically. The [[TESTDIR]] variable is the location for storing
all of the test files. The test directory is [[tests]] which is a
sibling of the [[noweb]] directory.

<<Test Directory>>=
TESTDIR=../tests
@ 

The [[test]] target depends on all of the test files being created.

<<Test Target>>=
test: $(TESTSRCS)
@ 

We also need to know which files contain GAP sources. The [[GAPNAMES]]
variable stores just the basename of each \noweb\ file containing GAP
source. The [[GAPSRCS]] variable creates all of the appropriate source
file names from the [[GAPNAMES]] variable.

<<Test Source Files>>=
TESTNAMES=testquiv
TESTSRCS=$(TESTNAMES:%=$(TESTDIR)/%.g) $(TESTNAMES:%=$(TESTDIR)/%.out)
@ 

The next two rules actually use [[notangle]] to generate the source
files from the appropriate \noweb\ file.

<<Test Source Creation Rules>>=
$(TESTDIR)/%.g: $(NOWEBSRCS)
        notangle -R"[[$*.g]]" $(NOWEBSRCS) > $@

$(TESTDIR)/%.out: $(NOWEBSRCS)
        notangle -R"[[$*.out]]" $(NOWEBSRCS) > $@
@ 

The GAP targets all put together follow.

<<Test Targets>>=
<<Test Directory>>
<<Test Source Files>>
<<Test Target>>
<<Test Source Creation Rules>>
@ 

\section{Makefile Target}

The [[Makefile]] target regenerates the Makefile that builds
\hopf. The target depends on the [[makefile.nw]] source file for the main
definition of the makefile, and [[legal.nw]] for the copyright
notice. Notangle is used to generate the makefile.

<<Makefile Target>>=
Makefile: makefile.nw legal.nw
        -mv -f Makefile Makefile.old
        notangle -t8 -R"[[Makefile]]" $(NOWEBSRCS) > Makefile.tmp
        unexpand Makefile.tmp > Makefile
        rm -f Makefile.tmp

@ 

\section{Clean Target}

The [[clean]] target cleans out the generated sources from the
\texttt{noweb} and \texttt{gap} directories, and removes the
\texttt{init.g} package creation file. It also removes some emacs
cruft such as the \~ backup files.

<<Clean Target>>=
clean:
        -rm -f $(HOPF).ps $(HOPF).dvi $(HOPF).tex $(HOPF).aux \
                $(HOPF).toc $(HOPF).log $(HOPF).nwi \
                $(HOPF).bbl $(HOPF).blg
        -rm -f $(LATEXSRCS) $(DEFINITIONS) alldefs
        -rm -f *.eps
        -rm -f *~
        -rm -f ../gap/*.gi ../gap/*.gd
        -rm -f ../init.g

@

\section{Release Target}

The [[release]] target generates a gzipped tar file containing the
files necessary for running \hopf. The sources, user documentation,
and literate program documentation are all preformatted as a part of
the release process.

<<Release Target>>=
<<RELEASEDIR variable>>
<<version variable>>

release:
        -rm -rf $(RELEASEDIR)
        mkdir $(RELEASEDIR)
        <<Checkout the selected version from the repository>>
        <<Create the initial makefile>>
        <<Build the sources>>
        <<Build the literate program documentation>>
        <<Build the user documentation>>
        <<Construct the tar file>>
        -rm -rf $(RELEASEDIR)
        @echo The release of Hopf version $(version) is in ../hopf.tar.gz
@ 

The [[RELEASEDIR]] variable contains a temporary directory where the
release files will be stored. It defaults to \texttt{../release}.

<<RELEASEDIR variable>>=
RELEASEDIR ?= ../release
@ 

The [[version]] variable contains the tag of the cvs files to use to
make the release. This defaults to \texttt{HEAD}, the most current
version of the files in the repository.

<<version variable>>=
version ?= HEAD
@ 

<<Checkout the selected version from the repository>>=
        cd $(RELEASEDIR) ; \
        cvs export -r $(version) hopf/pkg/hopf
@ 

<<Create the initial makefile>>=
        cd $(RELEASEDIR)/hopf/pkg/hopf/noweb ; \
        $(MAKE) -f Makefile.boot Makefile
@ 

<<Build the sources>>=
        cd $(RELEASEDIR)/hopf/pkg/hopf/noweb ; \
        $(MAKE) source
@ 

<<Build the literate program documentation>>=
        cd $(RELEASEDIR)/hopf/pkg/hopf/noweb ; \
        $(MAKE) doc
@ 

<<Build the user documentation>>=
        cd $(RELEASEDIR)/hopf/pkg/hopf/doc ; \
        $(MAKE) all
@ 

<<Construct the tar file>>=
        cd $(RELEASEDIR)/hopf/pkg ; \
        tar cf hopf.tar hopf ; \
        gzip hopf.tar
        mv $(RELEASEDIR)/hopf/pkg/hopf.tar.gz ..
@ 

\section{Tag Target}

The [[tag]] target tags the files composing \hopf\ with a symbolic
name to be used later with patches and releases. Primarily, this is
just an interface to the CVS \texttt{tag} command.

Because we are using the CVS \texttt{tag} command, this target will
apply the symbolic tag to files in the repository 
\textbf{based on the ones in your development directory.} 
It is important to know which files exist in your development directory
before tagging. For example, you do not want to tag the files in
your directory with \texttt{HOPF\_2\_0\_RELEASE} if you have the
files for the \texttt{HOPF\_1\_0\_RELENG} branch checked out.

The [[label]] variable is the symbolic label to use for the new
tag. This variable must be set on the \texttt{make} command line when
tagging the repository.

<<Tag Target>>=
<<TOPLEVEL Variable>>

tag:
ifneq ($(origin version), command line)
        @echo Usage: $(MAKE) tag version=SYMBOL
        @echo
        @echo Variables:
        @echo "    version is used to tag the repository files"
else
        cd $(TOPLEVEL) ; cvs tag -c $(version)
endif
@ 

The [[TOPLEVEL]] variable points to the top level directory of \hopf.

<<TOPLEVEL Variable>>=
TOPLEVEL=../../..
@ 

\section{Patch Target}

This is the initial pieces of a target to create patches for \hopf.
This work is not yet completed, as we have decided not to have a
complex patch system for the time being.
The work in progress remains here in case we change our minds later.

<<Patch Target>>=

patch:
ifneq ($(origin oversion), undefined)
    ifneq ($(origin nversion), undefined)
        <<Patch clean up>>
        <<Build the old version>>
        <<Build the new version>>
        <<Extract both versions>>
        <<Find different files>>
        <<Patch clean up>>
    else
        <<Print out patch usage message>>
    endif
else
        <<Print out patch usage message>>
endif
@ 

<<Build the old version>>=
make release version=$(oversion)
mv ../hopf.tar.gz ../oldhopf.tar.gz
@ 

<<Build the new version>>=
make release version=$(nversion)
mv ../hopf.tar.gz ../newhopf.tar.gz
@ 

<<Extract both versions>>=
mkdir ../orelease ; \
gzip -d -c ../oldhopf.tar.gz | (cd ../orelease ; tar xf -)
mkdir ../nrelease ; \
gzip -d -c ../newhopf.tar.gz | (cd ../nrelease ; tar xf -)
@ 

<<Find different files>>=
diff -q -r -N ../orelease/hopf ../nrelease/hopf
@ 

<<Patch clean up>>=
-rm -rf ../orelease ../nrelease oldhopf.tar.gz newhopf.tar.gz
@ 

<<Print out patch usage message>>=
@echo Usage: $(MAKE) patch oversion=SYMBOL nversion=SYMBOL
@echo 
@echo Variables:
@echo "    oversion is the symbol of the older version of Hopf"
@echo "    nversion is the symbol of the newer version of Hopf"
@ 
