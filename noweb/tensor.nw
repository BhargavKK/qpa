% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This file contains the declarations and implementations
%              for tensors in Hopf.
%
% Copyright, 1998 Virginia Polytechnic Institute and State University.
% Copyright, 1998 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: tensor.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tensors}
\label{chapter:Tensors}

\section{Overview}
\label{section:TensorOverview}

Tensors are commonly used in the study of non-commutative algebra and
Hopf algebras in particular. The tensor operation $\tensor$ applies to
a variety of different objects. The most common use of tensor combines
two or more elements of a module into a tensored vector space
element. Suppose \fld{R} is a ring and $V, W$ are left
\fld{R}-modules. Let $u, v \in V$ and $w,x \in W$ be module elements. Then
the following relations hold for tensor elements
\begin{eqnarray*}
    u \tensor_\fld{R} w + u \tensor_\fld{R} x & = &
u \tensor_\fld{R} (w + x)\\
 u \tensor_\fld{R} w + v \tensor_\fld{R} w & = &
(u + v) \tensor_\fld{R} w \\
    r (v \tensor_\fld{R} w) & = & (rv) \tensor_\fld{R} w \\
	& = & v \tensor_\fld{R} (rw)
\end{eqnarray*} 
for every $r \in \fld{R}$.
Furthermore, the tensor $V \tensor_\fld{R} W$ is
generated by the set of all tensored elements in $V$ and $W$ and
it is a left $\fld{R}$-module.
If $V$ and $W$ are algebras, then $V \tensor_\fld{R} W$ is also
an algebra where elements are multiplied by
\begin{displaymath}
    (u \tensor_\fld{R} w)(v \tensor_\fld{R} x) = (uv) \tensor_\fld{R} (wx).
\end{displaymath} 

These definitions are extended to more than two modules (algebra) in
the natural way. Every module (algebras) must be defined over the same
ring $\fld{R}$ for the extensions to make sense. For the remainder of this
discussion, assume $\tensor = \tensor_\fld{R}$.

Another use of the tensor operation is to tensor two or more maps together.
When two or more maps are tensored, then the maps are applied to
tensor elements piecewise. For example,
suppose $f : V \to V$ and $g : W \to W$ are maps,
then
\begin{displaymath}
    (f \tensor g)(v \tensor w) = f(v) \tensor g(w).
\end{displaymath}

If a map takes tensors as a parameter, it uses the pieces in the
positions that are next to be used. For example, suppose $h : V
\tensor W \to V \tensor W$ then \begin{displaymath}
    (f \tensor h \tensor g)(u \tensor v \tensor w \tensor x) = f(u) \tensor h(v\tensor w) \tensor x.
\end{displaymath}

In \hopf, we separate out the following three tensor cases:
\begin{itemize}
    \item an element-tensor,
such as $u \tensor_\fld{R} w + v \tensor_\fld{R} x$,
which is formed by tensoring and summing elements;
    \item a domain-tensor,
such as $(U \tensor_\fld{R} V) \tensor_\fld{R} W
=U \tensor_\fld{R} (V \tensor_\fld{R} W)$,
which is formed by tensoring two or more domains
over the same ring $\fld{R}$;
    \item a map-tensor,
such as $f \tensor_\fld{R} g$,
which is formed by tensoring two or more maps
over the same ring $\fld{R}$.
\end{itemize}

In \cite{Bach}, it is shown that finding normal forms of tensors is
undecidable in general. However, in certain important situations it is
possible to find normal forms, and thus perform computations of tensor
elements, such as the tensor of finite dimensional vector spaces over
a field.
So, in \hopf, we provide a framework for computing with
tensor elements.
Users of \hopf can extend the framework to support
computations with tensor elements that we do not provide, when such
computations are possible.


\section{Source Files}
\label{section:TensorSourceFiles}

<<[[tensor.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: tensor.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Tensor Declarations>>
@

<<[[tensor.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: tensor.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Tensor Implementations>>
@

\section{Element-Tensors}
\label{section:TensorsElementTensors}

We begin our discussion with the specification and implementation of
element-tensors in \hopf.

\subsection{Categories}

\paragraph{Category}
The [[IsElementTensor]] category contains the set of objects 
in GAP that are the tensor product of elements. This is used to
distinguish between tensor products of elements and tensor products of 
domains.

<<Declaration of IsElementTensor>>=
DeclareCategory("IsElementTensor",IsRingElement);
DeclareCategoryCollections("IsElementTensor");
@ %def IsElementTensor

\paragraph
Now we need to declare the representations for tensor elements.

<<Declaration of IsElementTensorRep>>=
DeclareRepresentation("IsElementTensorRep",IsComponentObjectRep,["elems","coeffs"]);
@ %def IsElementTensorRep

\paragraph
Now we can create tensor elements.  The function to do this is [[ElementTensor]].  It takes a domain tensor and a list of elements that will be used to create the tensor element at put it in the correct family.  

<<Declaration of ElementTensor>>=
DeclareGlobalFunction("ElementTensor");
@ %def ElementTensor

<<Implementation of ElementTensor>>=
InstallGlobalFunction(ElementTensor,function(tensor,elems)
    local domains,i,j,k,l,nelem,felems,fcoeffs,selems,scoeffs,O,t;

    domains:=ElementsFamily(tensor)!.domains;
    felems:=[[]];
    fcoeffs:=[One(ElementsFamily(tensor)!.domain)];
    for i in elems do
        if IsElementTensor(i) then
            if Length(tensor!.elems)=1 then
                for j in i!.elems[1]!.elems do
                    for k in [1..Length(felems)] do
                        Add(felems[k],j);
                        fcoeffs[k]:=fcoeffs[k]*i!.coeffs[1];
                    od;
                od;
            else
                selems:=[];
                scoeffs:=[];
                for j in [1..Length(felems)] do
                    for k in [1..Length(i!.elems)] do
                        nelem:=ShallowCopy(felems[j]);
                        for l in [1..Length(i!.elems[k]!.elems)] do
                            Add(nelem,i!.elems[k]!.elems[l]);
                        od;
                        Add(selems,nelem);
                        Add(scoeffs,i!.coeffs[k]);
                    od;
                od;
                felems:=selems;
                fcoeffs:=scoeffs;
            fi;
        else
            for k in felems do
                Add(k,i);
            od;
        fi;
    od;
    t:=Objectify(NewType(ElementsFamily(tensor),IsElementTensor and IsElementTensorRep),rec());
    t!.elems:=[];
    t!.coeffs:=[];
    for i in [1..Length(felems)] do
        if fcoeffs[i]<>0 then
            O:=Objectify(NewType(ElementsFamily(tensor),IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
            O!.elems:=felems[i];
            Add(t!.elems,O);
            Add(t!.coeffs,fcoeffs[i]);
        fi;
    od;
    if Length(t!.elems)=0 then
        return Zero(ElementsFamily(tensor)!.tensor);
    fi;
    SortParallel(t!.elems,t!.coeffs);
    return t;
end);
@

\subsection{Operations} 

\paragraph
The [[PrintObj]] operation is used to print out a representation of the tensored element.

<<Implementation of Element Tensor PrintObj>>=
InstallMethod(PrintObj,
    "for element tensors",
    true,
    [IsElementTensor],
    0,
    function(elem)
        local i;

        if Length(elem!.coeffs)>1 then
            for i in [1..Length(elem!.coeffs)-1] do
                Print(elem!.coeffs[i],"*",elem!.elems[i],"+");
            od;
        fi;
        Print(elem!.coeffs[Length(elem!.coeffs)],"*",elem!.elems[Length(elem!.coeffs)]);
    end);
@

\begin{SLOPPY}
The [[=]] operation checks to see if two tensor elements are
identical. This only works in nontrivial situations when the family
of the two elements has a canonical form function.
\end{SLOPPY}

<<Implementation of Element Tensor Equality>>=
InstallMethod(\=,
    "for element tensors",
    IsIdenticalObj,
    [IsElementTensor,IsElementTensor],
    0,
    function(elem1,elem2)
        local i;

        if Length(elem1!.elems)<>Length(elem2!.elems) then
            return false;
        fi;
        for i in [1..Length(elem1!.elems)] do
            if elem1!.elems[i]<>elem2!.elems[i] then
                return false;
            fi;
        od;
        return true;
    end);
@

It is necessary for some operations to also include the [[<]] function for tensored elements.

<<Implementation of Element Tensor <>>=
InstallMethod(\<,
    "for element tensors",
    IsIdenticalObj,
    [IsElementTensor,IsElementTensor],
    0,
    function(elem1,elem2)
        local i;

        if Length(elem1!.elems)<>Length(elem2!.elems) then
            return Length(elem1!.elems)<Length(elem2!.elems);
        fi;
        for i in [1..Length(elem1!.elems)] do
            if elem1!.elems[i]<>elem2!.elems[i] then
                return elem1!.elems[i]<elem2!.elems[i];
            fi;
        od;
        return false;
    end);
@


The [[+]] operation adds two tensor elements together. It combines
terms in the following ways.First, $u \tensor w + u \tensor x = u
\tensor (w + x)$, so the result has only one term in the tensor
element. Second, $u \tensor w + v \tensor w = (u + v) \tensor w$,
again resulting in only one term. Third, $u \tensor w + v \tensor x$
is not reduced in any way, so the result is two terms for the tensor
element.

<<Implementation of Element Tensor Methods>>=
InstallMethod(\+,
    "for two element tensors",
    IsIdenticalObj,
    [IsElementTensor,IsElementTensor],
    0,
    function(elem1,elem2)
        local O,lenx,leny,posx,posy,coeff,elem,elems,coeffs,zero;

        lenx:=Length(elem1!.coeffs);
        leny:=Length(elem2!.coeffs);
        posx:=1;
        posy:=1;
        elems:=[];
        coeffs:=[];
        while posx<=lenx or posy<=leny do
            if posx>lenx then
                coeff:=elem2!.coeffs[posy];
                elem:=elem2!.elems[posy];
                posy:=posy+1;
            elif posy>leny then
                coeff:=elem1!.coeffs[posx];
                elem:=elem1!.elems[posx];
                posx:=posx+1;
            elif elem1!.elems[posx]<=elem2!.elems[posy] then
                coeff:=elem1!.coeffs[posx];
                elem:=elem1!.elems[posx];
                if elem1!.elems[posx]=elem2!.elems[posy] then
                    coeff:=coeff+elem2!.coeffs[posy];
                    posy:=posy+1;
                fi;
                posx:=posx+1;
            else
                coeff:=elem2!.coeffs[posy];
                elem:=elem2!.elems[posy];
                posy:=posy+1;
            fi;
            if not coeff=Zero(FamilyObj(elem1)!.domain) then
                Add(coeffs,coeff);
                Add(elems,elem);
            fi;
        od;
        if Length(elems)=0 then
            return FamilyObj(elem1)!.zero;
        fi;
        O:=Objectify(NewType(FamilyObj(elem1),IsElementTensor and IsElementTensorRep),rec());
        O!.elems:=elems;
        O!.coeffs:=coeffs;
        return O;
    end);
@

The [[*]] operation between ring elements and tensor elements makes
the ring element a coefficient of the tensor element. This may only be
supported on the left or the right depending on whether or not the
operation on the constituent elements is supported on the left or
right respectively.

<<Implementation of Element Tensor Methods>>=
InstallMethod(\*,
    "for a ring element and element tensor",
    true,
    [IsRingElement,IsElementTensor],
    0,
    function(elem1,elem2)
        local i,O;

        if not elem1 in FamilyObj(elem2)!.domain then
            Error("Incompatible scalar multiplication!");
        fi;
        O:=Objectify(NewType(FamilyObj(elem2),IsElementTensor and IsElementTensorRep),rec());
        O!.elems:=ShallowCopy(elem2!.elems);
        O!.coeffs:=ShallowCopy(elem2!.coeffs);
        for i in [1..Length(O!.coeffs)] do
            O!.coeffs[i]:=elem1*O!.coeffs[i];
        od;
        return O;
    end);
@
The [[*]] operation multiplies two tensor elements when the elements
that are tensored together support the multiplication operation. The
multiplication is performed piecewise: $(u \tensor w) * (v \tensor x)
= (uv \tensor wx)$.

<<Implementation of Element Tensor Methods>>=
InstallMethod(\*,
    "for two element tensors",
    IsIdenticalObj,
    [IsElementTensor,IsElementTensor],
    0,
    function(elem1,elem2)
        local i,j,elem,coeff,elems,coeffs,pos,O;

        if not FamilyObj(elem1)!.canMultiply then
            Error("Operation is undefined");
        fi;
        elems:=[];
        coeffs:=[];
        for i in [1..Length(elem1!.elems)] do
            for j in [1..Length(elem2!.elems)] do
                elem:=elem1!.elems[i]*elem2!.elems[j];
                coeff:=elem1!.coeffs[i]*elem2!.coeffs[j];
                if coeff<>0 then
                    pos:=Position(elems,elem);
                    if pos=fail then
                        Add(elems,elem);
                        Add(coeffs,coeff);
                    else
                        coeffs[pos]:=coeff+coeffs[pos];
                    fi;
                fi;
            od;
        od;
        SortParallel(elems,coeffs);
        O:=Objectify(NewType(FamilyObj(elem2),IsElementTensor and IsElementTensorRep),rec());
        O!.elems:=[];
        O!.coeffs:=[];
        for i in [1..Length(coeffs)] do
            if coeffs[i]<>0 then 
                Add(O!.elems,elems[i]);
                Add(O!.coeffs,coeffs[i]);
            fi;
        od;
        if Length(O!.elems)=0 then
            return FamilyObj(elem1)!.zero;
        fi;
        return O;
    end);
@

The final operation needed is the [[-]] operation.

<<Implementation of Element Tensor Methods>>=
InstallMethod(\-,
    "for two element tensors",
    IsIdenticalObj,
    [IsElementTensor,IsElementTensor],
    0,
    function(elem1,elem2)
        return elem1+(-One(FamilyObj(elem2)!.domain))*elem2;
    end);
@

\section{TensorGeneratorElements}
We wish to distinguish between regular tensor elements and the
generators of the tensor products of domains.  This will help
when it comes to canonical form functions. First we declare the 
[[IsTensorGeneratorElement]] category and its representation.

<<Declaration of IsTensorGeneratorElement>>=
DeclareCategory("IsTensorGeneratorElement",IsRingElement);
DeclareCategoryCollections("IsTensorGeneratorElement");
@ %def IsTensorGeneratorElement

<<Declaration of IsTensorGeneratorElementRep>>=
DeclareRepresentation("IsTensorGeneratorElementRep",IsComponentObjectRep,["elems"]);
@ %def IsTensorGeneratorElementRep

Now we will construct these generator elements.  This function is called when
domain tensors are constructed and help to create a kind of basis for the 
domain tensors. 

<<Declaration of ConstructDomainTensorGenerators>>=
DeclareGlobalFunction("ConstructDomainTensorGenerators");
@ %def ConstructDomainTensorGenerators

<<Implementation of ConstructDomainTensorGenerators>>=
InstallGlobalFunction(ConstructDomainTensorGenerators,function(fam,gens)
    local i,j,k,gens1,gens2,elems,newgens,O;

    if Length(gens)<2 and not ForAll(gens,g -> IsList(g)) then
        Error("Cannot construct domain tensor generators!");
    fi;
    gens1:=gens[1];
    for i in [2..Length(gens)] do
        newgens:=[];
        gens2:=gens[2];
        for j in gens1 do
            for k in gens2 do
                if IsTensorGeneratorElement(j) then
                    elems:=ShallowCopy(j!.elems);
                    Add(elems,k);
                else
                    elems:=[j,k];
                fi;
                O:=Objectify(NewType(fam,IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
                O!.elems:=elems;
                Add(newgens,O);
            od;
        od;
        gens1:=newgens;
    od;
    gens2:=[];
    for i in gens1 do
        O:=Objectify(NewType(fam,IsElementTensor and IsElementTensorRep),rec());
        O!.elems:=[i];
        O!.coeffs:=[One(fam!.domain)];
        Add(gens2,O);
    od;
    return gens2;
end);
@

Finally we implement the element operations on the TensorGeneratorElements.  These include addition, multiplication, and others.

<<Implementation of TensorGeneratorElement PrintObj>>=
InstallMethod(PrintObj,
    "for tensor generator elements",
    true,
    [IsTensorGeneratorElement],
    0,
    function(elem)
        local i;

        if Length(elem!.elems)>1 then
            for i in [1..Length(elem!.elems)-1] do
                Print(elem!.elems[i],"<*>");
            od;
        fi;
        Print(elem!.elems[Length(elem!.elems)]);
    end);
@

<<Implementation of TensorGeneratorElement = and <>>=
InstallMethod(\=,
    "for two tensor generator elements",
    IsIdenticalObj,
    [IsTensorGeneratorElement,IsTensorGeneratorElement],
    0,
    function(elem1,elem2)
        local i;

        for i in [1..Length(elem1!.elems)] do
            if elem1!.elems[i]<>elem2!.elems[i] then
                return false;
            fi;
        od;
        return true;
    end);

InstallMethod(\<,
    "for two tensor generator elements",
    IsIdenticalObj,
    [IsTensorGeneratorElement,IsTensorGeneratorElement],
    0,
    function(elem1,elem2)
        local i;

        for i in [1..Length(elem1!.elems)] do
            if elem1!.elems[i]<>elem2!.elems[i] then
                return elem1!.elems[i]<elem2!.elems[i];
            fi;
        od;
        return false;
    end);
@

<<Implementation of TensorGeneratorElement *>>=
InstallMethod(\*,
    "for two tensor generators elements",
    IsIdenticalObj,
    [IsTensorGeneratorElement,IsTensorGeneratorElement],
    0,
    function(elem1,elem2)
        local i,O;

        if not FamilyObj(elem1)!.canMultiply then
            Error("Operation is undefined");
        fi;
        O:=Objectify(NewType(FamilyObj(elem1),IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
        O!.elems:=[];
        for i in [1..Length(elem1!.elems)] do
            Add(O!.elems,elem1!.elems[i]*elem2!.elems[i]);
        od;
        return O;
    end);
@

\section{Domain-Tensor}
\label{section:TensorsDomainTensor}

Tensoring domains constructs a domain generated by the appropriate
tensored elements that generate the domain. The resulting domain has
as much structure as we can infer from the domains being tensored. In
many important cases, when two or more domains are tensored, a nice
tensor monomorphism is assigned to the family of the tensor elements
to compute normal forms.

\begin{NOTE}
Create a table of what structure the resulting domains
have when two (or more) domains are tensored.
\end{NOTE}

\subsection{Categories}
The Domain tensors will be treated as [[FreeMagmaRings]] over some left acting
domain and generated be the tensored generators, or if possible the basis 
elements of the domain tensored togather.  First we declare the category.

<<Declaration of IsDomainTensor>>=
DeclareCategory("IsDomainTensor",IsFreeMagmaRing);
@ %def IsDomainTensor



\subsection{Attributes}


The [[Basis]] attribute returns a basis of the domain when it is possible
to compute.

The [[BasisVectors]] attribute returns the basis vectors of the domain
when they are possible to compute.

The [[Dimension]] attribute returns the dimension of the resulting
domain, when it can be computed.

\subsection{Properties}

One of the domains we want to tensor is algebras, so the domain tensor has the 
property [[IsAlgebraTensor]].

<<Declaration of IsAlgebraTensor>>=
DeclareProperty("IsAlgebraTensor",IsDomainTensor);
@ %def IsAlgebraTensor

Another of the domains we want to tensor is vector spaces, so the domain tensor has the 
property [[IsVectorSpaceTensor]].

<<Declaration of IsVectorSpaceTensor>>=
DeclareProperty("IsVectorSpaceTensor",IsDomainTensor);
@ %def IsVectorSpaceTensor

Another attribute of a domain tensor is its dimension.  Particularly we want to 
know if a tensor is finite dimensional or not.  If it is then we can implement a 
canonical form function.

<<Declaration of IsFiniteDimensional>>=
DeclareProperty("IsFiniteDimensional",IsDomainTensor);
@ %def IsFiniteDimensional

\subsection{Creation of Domain Tensors}
The function to tensor domains is [[DomainTensor]].  Right now only algebras 
can be tensored but eventually we hope to add more tensoring abilities.  The
function takes as arguments a list of domains to be tensored.  It will also 
flatten out any domains which are tensored in to the different parts.  So if
you tensor say $T = A \tensor B$ and then do $H = T \tensor C$, the resulting
tensor $H$ is flattened to look like $A \tensor B \tensor C$.

<<Declaration of DomainTensor>>=
DeclareGlobalFunction("DomainTensor");
@ %def DomainTensor

<<Implementation of DomainTensor>>=
InstallGlobalFunction(DomainTensor,function(domains)
    local domain,O,fam,i,flat;

    if Length(domains)=1 and IsList(domains[1]) then
        domains:=domains[1];
    fi;
    if Length(domains)<2 then
        Error("Must have at least two things to tensor.");
    fi;
    domain:=LeftActingDomain(domains[1]);
    if not ForAll(domains,d -> LeftActingDomain(d)=domain) then
        Error("Must have the same left-acting domain to tensor.");
    fi;
    if not IsRingWithOne(domain) or One(domain)=fail then
        Error("Left-acting domain must be a ring-with-one with known one.");
    fi;
    flat:=[];
    for i in domains do
        if IsDomainTensor(i) then
            Append(flat,DomainsOfDomainTensor(i));
        else
            Add(flat,i);
        fi;
    od;
    domains:=flat;
    fam:=NewFamily("TensorGeneratorElementsFamily",IsRingElement);
    fam!.domain:=domain;
    fam!.domains:=domains;
    fam!.canMultiply:=false;
    fam!.hasBasis:=false;
    if ForAll(domains,d -> IsAlgebra(d)) then
        O:=AlgebraTensor(fam);
    elif ForAll(domains,d -> IsVectorSpace(d)) then
        O:=VectorSpaceTensor(fam);
    else
        Error("Currently only algebra and vector space tensors supported.");
    fi;
    SetElementsFamily(O,fam);
    SetIsWholeFamily(O,true);
    SetFilterObj(O,IsDomainTensor);
    SetIsFiniteDimensional(O,ForAll(domains,d -> IsFiniteDimensional(d)));
    fam!.tensor:=O;
    return O;
end);
@

So now we must implement a method for tensor togather algebras.  The function
to do this is [[AlgebraTensor]].

<<Declaration of AlgebraTensor>>=
DeclareGlobalFunction("AlgebraTensor");
@
<<Implementation of AlgebraTensor>>=
InstallGlobalFunction(AlgebraTensor,function(fam)
    local hasbasis,genlist,hasone,algebras,gens,i,agens,aone,azero,O,one,zero,tone,magma;

    algebras:=fam!.domains;
    if Length(algebras)<2 or not ForAll(algebras,a -> IsAlgebra(a)) then
        Error("Algebra tensor requires two or more algebras to tensor.");
    fi;
    gens:=[];
    one:=Objectify(NewType(fam,IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
    zero:=Objectify(NewType(fam,IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
    one!.elems:=[];
    zero!.elems:=[];
    hasone:=true;
    hasbasis:=true;
    for i in algebras do
        genlist:=fail;
        if IsFiniteDimensional(i) then
            genlist:=Basis(i);
        fi;
        if genlist=fail then
            genlist:=GeneratorsOfAlgebra(i);
            hasbasis:=false;
        else
            genlist:=BasisVectors(genlist);
        fi;
        agens:=ShallowCopy(genlist);
        if hasone then
            aone:=One(i);
            if aone=fail then
                Print("At least one algebra-with-one returned fail for One.  Algebra tensor will not be an algebra-with-one.");
                hasone:=false;
            else
                Add(one!.elems,aone);
            fi;
        fi;
        azero:=Zero(i);
        if azero=fail then
            Error("Algebra returned fail for Zero.");
        fi;
        Add(zero!.elems,azero);
        Add(gens,agens);
    od;
    fam!.gens:=ConstructDomainTensorGenerators(fam,gens);
    fam!.hasBasis:=hasbasis;
    if hasone then
        magma:=MagmaWithOne(fam!.gens);
        tone:=Objectify(NewType(fam,IsElementTensor and IsElementTensorRep),rec());
        tone!.elems:=[one];
        tone!.coeffs:=[One(fam!.domain)];
        SetOne(magma,tone);
    else
        magma:=Magma(fam!.gens);
    fi;
    SetFilterObj(magma,IsAdditiveMagmaWithZero);
    azero:=Objectify(NewType(fam,IsElementTensor and IsElementTensorRep),rec());
    azero!.elems:=[zero];
    azero!.coeffs:=[Zero(fam!.domain)];
    SetZero(magma,azero);
    fam!.zero:=azero;
    O:=FreeMagmaRing(fam!.domain,magma);
    if hasone then
        SetFilterObj(O,IsAlgebraWithOne);
        SetOne(O,tone);
    fi;
    SetZero(O,azero);
    SetIsAlgebraTensor(O,true);
    fam!.canMultiply:=true;
    return O;
end);
@

Similarly, the function to create vector space tensors is [[VectorSpaceTensor]].

<<Declaration of VectorSpaceTensor>>=
DeclareGlobalFunction("VectorSpaceTensor");
@
<<Implementation of VectorSpaceTensor>>=
InstallGlobalFunction(VectorSpaceTensor,function(fam)
    local hasbasis,genlist,spaces,gens,i,vgens,vzero,O,zero,magma;

    spaces:=fam!.domains;
    if Length(spaces)<2 or not ForAll(spaces,s -> IsVectorSpace(s)) then
        Error("Vector space tensor requires two or more vector spaces to tensor.");
    fi;
    gens:=[];
    zero:=Objectify(NewType(fam,IsTensorGeneratorElement and IsTensorGeneratorElementRep),rec());
    zero!.elems:=[];
    hasbasis:=true;
    for i in spaces do
        genlist:=fail;
        if IsFiniteDimensional(i) then
            genlist:=Basis(i);
        fi;
        if genlist=fail then
            genlist:=GeneratorsOfVectorSpace(i);
            hasbasis:=false;
        else
            genlist:=BasisVectors(genlist);
        fi;
        vgens:=ShallowCopy(genlist);
        vzero:=Zero(i);
        if vzero=fail then
            Error("Vector space returned fail for Zero.");
        fi;
        Add(zero!.elems,vzero);
        Add(gens,vgens);
    od;
    fam!.gens:=ConstructDomainTensorGenerators(fam,gens);
    fam!.hasBasis:=hasbasis;
    vzero:=Objectify(NewType(fam,IsElementTensor and IsElementTensorRep),rec());
    vzero!.elems:=[zero];
    vzero!.coeffs:=[Zero(fam!.domain)];
    fam!.zero:=vzero;
    if hasbasis then
        O:=VectorSpace(fam!.domain,fam!.gens,fam!.zero,"basis");
    else
        O:=VectorSpace(fam!.domain,fam!.gens,fam!.zero);
    fi;
    SetZero(O,vzero);
    SetIsVectorSpaceTensor(O,true);
    return O;
end);
@

\subsection{Operations of Domain Tensors}
There are four important operations on domain tensors.  First is 
[[DomainOfDomainTensor]] which returns the left acting domain of the 
tensor.

<<Declaration of DomainOfDomainTensor>>=
DeclareOperation("DomainOfDomainTensor",[IsDomainTensor]);
@ %def DomainOfDomainTensor

<<Implementation of DomainOfDomainTensor>>=
InstallMethod(DomainOfDomainTensor,
    "for domain tensors",
    true,
    [IsDomainTensor],
    0,
    function(tensor)
        return ElementsFamily(tensor)!.domain;
    end);
@

Next is the [[DomainsOfDomainTensor]] operation which returns the domains
that the domain tensor is the tensored composition of.

<<Declaration of DomainsOfDomainTensor>>=
DeclareOperation("DomainsOfDomainTensor",[IsDomainTensor]);
@ %def DomainsOfDomainTensor

<<Implementation of DomainsOfDomainTensor>>=
InstallMethod(DomainsOfDomainTensor,
    "for domain tensors",
    true,
    [IsDomainTensor],
    0,
    function(tensor)
        return ElementsFamily(tensor)!.domains;
    end);
@

Next is the [[GeneratorsOfDomainTensor]] operations which returns the 
generators of the domain tensor in list form.

<<Declaration of GeneratorsOfDomainTensor>>=
DeclareOperation("GeneratorsOfDomainTensor",[IsDomainTensor]);
@

<<Implementation of GeneratorsOfDomainTensor>>=
InstallMethod(GeneratorsOfDomainTensor,
    "for domain tensors",
    true,
    [IsDomainTensor],
    0,
    function(tensor)
        return ElementsFamily(tensor)!.gens;
    end);
@

<<Implementation of DomainTensor Basis>>=
InstallMethod(Basis,
    "for domain tensors",
    true,
    [IsDomainTensor],
    0,
    function(tensor)
        local fam;

        fam:=ElementsFamily(tensor);
        if not fam.hasBasis then
            return fail;
        fi;
        return BasisNC(tensor,fam!.gens);
    end);
@

<<Implementation of ElementTensor Ops>>=
InstallMethod(ZeroOp,
    "for element tensors",
    true,
    [IsElementTensor],
    0,
    function(elem)
        return FamilyObj(elem)!.zero;
    end);
InstallMethod(AdditiveInverseOp,
    "for element tensors",
    true,
    [IsElementTensor],
    0,
    function(elem)
        local i,O;

        O:=Objectify(NewType(FamilyObj(elem),IsElementTensor and IsElementTensorRep),rec());
        O!.elems:=ShallowCopy(elem!.elems);
        O!.coeffs:=[];
        for i in [1..Length(elem!.coeffs)] do
            O!.coeffs[i]:=-elem!.coeffs[i];
        od;
        return O;
    end);
@

\section{Map-Tensors} \label{section:TensorsMapTensors}

\section{Inclusion in Source}

<<Tensor Declarations>>=
<<Declaration of IsDomainTensor>>
<<Declaration of IsTensorGeneratorElement>>
<<Declaration of IsElementTensor>>
<<Declaration of IsAlgebraTensor>>
<<Declaration of IsVectorSpaceTensor>>
<<Declaration of DomainOfDomainTensor>>
<<Declaration of DomainsOfDomainTensor>>
<<Declaration of GeneratorsOfDomainTensor>>
<<Declaration of IsTensorGeneratorElementRep>>
<<Declaration of IsElementTensorRep>>
<<Declaration of AlgebraTensor>>
<<Declaration of VectorSpaceTensor>>
<<Declaration of ConstructDomainTensorGenerators>>
<<Declaration of DomainTensor>>
<<Declaration of ElementTensor>>
@

<<Tensor Implementations>>=
<<Implementation of DomainsOfDomainTensor>>
<<Implementation of ConstructDomainTensorGenerators>>
<<Implementation of ElementTensor>>
<<Implementation of AlgebraTensor>>
<<Implementation of VectorSpaceTensor>>
<<Implementation of DomainTensor>>
<<Implementation of DomainOfDomainTensor>>
<<Implementation of DomainTensor Basis>>
<<Implementation of GeneratorsOfDomainTensor>>
<<Implementation of TensorGeneratorElement PrintObj>>
<<Implementation of Element Tensor PrintObj>>
<<Implementation of TensorGeneratorElement = and <>>
<<Implementation of Element Tensor Equality>>
<<Implementation of Element Tensor <>>
<<Implementation of TensorGeneratorElement *>>
<<Implementation of Element Tensor Methods>>
<<Implementation of ElementTensor Ops>>
@
