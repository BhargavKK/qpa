% -*- mode: Noweb; noweb-code-mode: text-mode -*-%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% HOPF Project Source File
% DESCRIPTION: This file contains the code needed to create presentations
%              of path algebra modules. This is the second version of the
%              code. This time, the implementation takes advantage of the
%              algebra module code contained in the GAP library.
%
% Copyright, 2001 Virginia Polytechnic Institute and State University.
% Copyright, 2001 Virginia Tech Hopf Project. All rights reserved.
%
% This file may be distributed in accordance with the stipulations existing
% in the LICENSE file accompanying this software.
%
% $Id: present.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Presentations}
\label{chapter:Presentations}

\section{Overview}
\label{section:Presentation Overview}

In this chapter, 
we implement the construction of modules 
over path algebras
via presentations.
The implementation builds
on the algebra module support
in the GAP library, replacing
an earlier implementation
in \hopf.

Modules constructed via presentations
are created first by constructing a
vertex projective module over a path
algebra,
then constructing a submodule
of the path algebra,
and then factoring the vertex projective
module by the submodule.

\section{Source Files}
\label{section:Presentation SourceFiles}

<<[[present.gd]]>>=
# GAP Declarations
# This file was generated from
# $Id: present.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Declaration of InfoPathAlgebraModule>>
<<Path Algebra Module Properties>>
<<Path Algebra Vector Categories>>
<<Path Algebra Vector Representation>>
<<Declaration of Path Algebra Vector Constructor>>
<<Declaration of Vectorize>>
<<Declare vertex accessing operations>>
<<Declaration for accessing the leading component of a path algebra vector>>
<<Declaration of the leading position in a path algebra vector>>
<<Declaration of IsLeftDivisible>>
<<Declaration of Basis of Path Algebra Vector Space>>
<<Declaration of RightProjectiveModule>>
<<Declaration of UniformGeneratorsOfModule>>
<<Declaration of right groebner basis for path algebra modules>>
<<Declarations for path algebra module Groebner bases>>
<<Declaration of UnderlyingModule>>
<<Declaration of IsPathAlgebraModuleGroebnerBasisDefaultRep>>
<<Declaration of finitely presented path algebra modules>>
<<Declarations of finitely presented path algebra module vectors>>
<<Declare module lifting operation>>
<<Declaration of vertex projective presentation>>
<<Declaration of IsAlgebraModuleHomomorphism filter>>
@

<<[[present.gi]]>>=
# GAP Implementation
# This file was generated from 
# $Id: present.nw,v 1.1 2010/05/07 13:30:14 sunnyquiver Exp $
<<Implementation of IsNormalForm for Path Algebra Vectors>>
<<Implementation of Path Algebra Vector Constructor>>
<<Implementation of Vectorize>>
<<Implementation of Addition for path algebra vectors>>
<<Implementation of Subtraction for path algebra vectors>>
<<AdditiveInverseOp for path algebra vectors>>
<<ZeroOp for path algebra vectors>>
<<Scalar multiplication for path algebra vectors>>
<<PrintObj for path algebra vectors>>
<<Leading term for path algebra vectors>>
<<Leading coefficient of path algebra vectors>>
<<Implement vertex accessing operations>>
<<Implementation of access to the leading component of a path algebra vector>>
<<Implementation of the leading position in a path algebra vector>>
<<Less than for path algebra vectors>>
<<Equals for path algebra vectors>>
<<Implementation of IsLeftDivisible>>
<<Uniformity for path algebra vectors>>
<<Bases for spaces spanned by path algebra vectors>>
<<Element membership for spaces generated by path algebra vectors>>
<<Implementation of RightProjectiveModule>>
<<Submodules of path algebra modules>>
<<Implementation of vertex projective test>>
<<Right action of algebra elements on path algebra vectors>>
<<Bases for path algebra modules>>
<<Implementation of UniformGeneratorsOfModule>>
<<Implementation of ReduceRightModuleElement>>
<<Implementation of NormalizeRightModuleElement>>
<<Implementation of RightGroebnerBasisOfModule>>
<<Implementation of ViewObj for Groebner bases of path algebra modules>>
<<Implementation of CompletelyReduce for path algebra modules>>
<<PrintObj for f.p. path algebra vectors>>
<<Implementation of module lifting operation>>
<<Natural homomorphism for path algebra modules>>
<<Vertex projective presentation over path algebras>>
<<Implementation of Vectorize for f.p. path algebra modules>>
<<Implementation of the Hom computation for f.p. path algebra modules>>
<<Implementation of Hom for f.p. path algebra modules>>
<<Implementation of End for f.p. path algebra modules>>
<<Image source for algebra module homomorphisms>>
@

\section{Debugging}

The [[InfoPathAlgebraModule]] information class is used for printing
debugging and other useful information throughout this implementation.

<<Declaration of InfoPathAlgebraModule>>=
DeclareInfoClass( "InfoPathAlgebraModule" );
@ %def InfoPathAlgebraModule

\section{Path Algebra Vectors}
\label{section:Path Algebra Vectors}

We define an encoding of path algebra elements
to be treated as vectors in a vector space.

<<Path Algebra Vector Categories>>=
DeclareCategory( "IsPathAlgebraVector", IsVector );
DeclareCategoryCollections( "IsPathAlgebraVector" );
DeclareCategoryFamily( "IsPathAlgebraVector" );
@

Path algebra vectors are positional objects.
The first entry is the list of path algebra elements.
The second entry is the position
of the leading term in the vector.
If the position of the leading
term is one more than the number of components
comprising the vector, the vector is the zero vector.

<<Path Algebra Vector Representation>>=
DeclareRepresentation("IsPathAlgebraVectorDefaultRep", IsPositionalObjectRep,
                      []);
@ %def IsPathAlgebraVectorDefaultRep

\paragraph{Attribute}

All vectors that are not known to be in normal form are assumed to not
be in normal form. The [[IsNormalForm]] method for
[[IsPathAlgebraVector]] objects is equivalent to [[ReturnFalse]].

<<Implementation of IsNormalForm for Path Algebra Vectors>>=
InstallMethod( IsNormalForm,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector], 0,
    ReturnFalse );
@ 

\subsection{Vector Construction}

To construct path algebra vectors,
the [[PathAlgebraVector]] operation is used.

<<Declaration of Path Algebra Vector Constructor>>=
DeclareOperation( "PathAlgebraVector",
    [IsPathAlgebraVectorFamily, IsHomogeneousList] );
@

The first implementation assumes that we do not know how
to compute normal forms of elements.

<<Implementation of Path Algebra Vector Constructor>>=
InstallMethod( PathAlgebraVector,
    "for families of path algebra vectors and hom. list",
    true,
    [IsPathAlgebraVectorFamily, IsHomogeneousList], 0,
    function(fam, components)
        local i, c, pos;
        <<Validate components>>
        return Objectify(fam!.defaultType, [Immutable(components), pos]);
    end );
@

The second implementation calls the normal form function
if it is known.

<<Implementation of Path Algebra Vector Constructor>>=
InstallMethod( PathAlgebraVector,
    "for families of path algebra vectors and hom. list (normal form)",
    true,
    [IsPathAlgebraVectorFamily and HasNormalFormFunction, 
     IsHomogeneousList], 0,
    function(fam, components)
        local i, c, pos;
        <<Validate components>>
        return NormalFormFunction(fam)(fam, components, pos);
    end );
@

The components must be from the expected family and there must be the
proper number of components. Each component must reside in the
appropriate projective. \textit{Note: This needs to be fixed. Right now,
it assumes that path algebra vectors are in right modules, which is
not correct.}

<<Validate components>>=
if not ( IsIdenticalObj( fam!.componentFam, FamilyObj(components) )
         and fam!.vectorLen = Length(components) )
then
    Error("components are not in the proper family");
fi;
pos := fam!.vectorLen+1;
for i in [fam!.vectorLen,(fam!.vectorLen-1)..1] do
    c := components[i];
    if not IsLeftUniform(c) then
        Error("components must be left uniform");
    fi;
    if not IsZero(c) then
        if SourceOfPath(TipMonomial(c)) <> fam!.vertices[i] then
            Error("component ", i, " starts with an improper vertex.");
        else
            pos := i;
        fi;
    fi;
od;
@ 

We also provide non-checking versions of the constructors for an
improvement in speed. These are generally called by the arithmetic
operations.

<<Declaration of Path Algebra Vector Constructor>>=
DeclareOperation( "PathAlgebraVectorNC",
    [IsPathAlgebraVectorFamily, IsHomogeneousList, IsInt, IsBool] );
@ %def PathAlgebraVectorNC

<<Implementation of Path Algebra Vector Constructor>>=
InstallMethod( PathAlgebraVectorNC,
    "for path algebra vector family and hom. list (nonchecking)",
    true,
    [ IsPathAlgebraVectorFamily, IsHomogeneousList, IsInt, IsBool ], 0,
    function( fam, components, pos, normal )
        return Objectify( fam!.defaultType, [Immutable(components), pos] );
    end );
@ 

<<Implementation of Path Algebra Vector Constructor>>=
InstallMethod( PathAlgebraVectorNC,
    "for path algebra vector family and hom. list (nonchecking)",
    true,
    [ IsPathAlgebraVectorFamily and HasNormalFormFunction,
      IsHomogeneousList, IsInt, IsBool ], 0,
    function( fam, components, pos, normal )
        if normal then
            return Objectify( fam!.defaultType, [Immutable(components), pos]);
        else
            return NormalFormFunction(fam)(fam, components, pos);
        fi;
    end );
@ 

The [[Vectorize]] operation takes a GAP list and turns it into a
vector in the module $M$. This is to make it easier for users to
construct module elements, while enforcing only proper operations for
the resulting vector.

<<Declaration of Vectorize>>=
DeclareOperation( "Vectorize", [IsVectorCollection, IsHomogeneousList] );
@ %def Vectorize

We currently implement this operation only for path algebras modules.

<<Implementation of Vectorize>>=
InstallOtherMethod( Vectorize,
    "for path algebra modules and a homogeneous list",
    true,
    [IsPathAlgebraModule, IsHomogeneousList], 0,
    function( M, vector )
        local vecElmFam, modElmFam;

        vecElmFam := FamilyObj(ExtRepOfObj(Zero(M)));
        modElmFam := ElementsFamily(FamilyObj(M));
        return ObjByExtRep(modElmFam, PathAlgebraVector(vecElmFam, vector));
    end );
@ 

\subsection{Path Algebra Vector Arithmetic Operations}

First, we implement the standard operations. We can add two vectors together.

<<Implementation of Addition for path algebra vectors>>=
InstallMethod( \+,
    "for two path algebra vectors",
    IsIdenticalObj,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep,
     IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( u, v )
        local fam, pos, c, i, start, normal;

        c := u![1] + v![1];
        <<Calculate position after addition or subtraction>>
        normal := IsNormalForm(u) and IsNormalForm(v);
       
        return PathAlgebraVectorNC(fam, c, pos, normal);
    end );
@ 

We can also subtract two vectors.

<<Implementation of Subtraction for path algebra vectors>>=
InstallMethod( \-,
    "for two path algebra vectors",
    IsIdenticalObj,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep,
     IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( u, v )
        local fam, pos, c, i, start, normal;

        c := u![1] - v![1];
        <<Calculate position after addition or subtraction>>
        normal := IsNormalForm(u) and IsNormalForm(v);

        return PathAlgebraVectorNC(fam, c, pos, normal);
    end );
@ 

We need to calculate the first non-zero position. The first non-zero
position cannot occur before the minimum non-zero positions of the two
vectors being added. If the positions are equal, and in the range of
the number of components, we check to see if the non-zero position has
become zero as a result of the operation. If the position has become
zero, we perform a linear search starting at the next position to find
the first non-zero component.

<<Calculate position after addition or subtraction>>=
fam := FamilyObj(u);
pos := Minimum(u![2], v![2]);
if pos <= fam!.vectorLen 
   and u![2] = v![2] and IsZero(c[pos])
then
    start := pos;
    pos := fam!.vectorLen+1;
    for i in [start+1..fam!.vectorLen] do
        if not IsZero(c[i]) then
            pos := i;
            break;
        fi;
    od;
fi;
@ 

We can compute the additive inverse of an element by computing the
additive inverse of each component. The non-zero position does not
change as a result of this operation.

<<AdditiveInverseOp for path algebra vectors>>=
InstallMethod( AdditiveInverseOp,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( x )
        return PathAlgebraVectorNC(FamilyObj(x), List(x![1], AdditiveInverse), 
                   x![2], IsNormalForm(x));
    end );
@ 


We can compute the zero element of path algebra vectors. The
zero element is computed once and stored with the family.

<<ZeroOp for path algebra vectors>>=
InstallMethod( ZeroOp,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector], 0,
    function( x )
        return FamilyObj(x)!.zeroVector;
    end );
@ 


The next two operations provide scalar multiplication of right path
algebra vectors.

<<Scalar multiplication for path algebra vectors>>=
InstallOtherMethod( \*,
    "for path algebra vectors and field element",
    true,
    [IsScalar, IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( n, x )
        local pos;

        if IsZero(n) then
            return FamilyObj(x)!.zeroVector;
        else
            pos := x![2];
        fi;
        return PathAlgebraVectorNC(FamilyObj(x), n*x![1], pos,
                                   IsNormalForm(x));
    end );
@ 

<<Scalar multiplication for path algebra vectors>>=
InstallMethod( \*,
    "for path algebra vectors and field element",
    true,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep, IsScalar], 0,
    function( x, n )
        local pos;        
        if IsZero(n) then
            return FamilyObj(x)!.zeroVector;
        else
            pos := x![2];
        fi;
        return PathAlgebraVectorNC(FamilyObj(x), n*x![1], pos,
                                   IsNormalForm(x));
    end );
@ 

\subsection{Displaying Path Algebra Vectors}

\paragraph{Operation}

The [[PrintObj]] operation prints out an element in a nice form.

<<PrintObj for path algebra vectors>>=
InstallMethod( PrintObj,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( x )
        Print( x![1] );
    end );
@ 


\subsection{Access Operations}

The leading term of a path algebra vector
is the leading term of the left-most
non-zero component in the vector,
according to the path algebra ordering.

<<Leading term for path algebra vectors>>=
InstallOtherMethod( LeadingTerm,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( x )
        local pos, lt, elem, zero, fam;

        pos := x![2];
        fam := FamilyObj(x);
        if pos <= fam!.vectorLen then
            lt := LeadingTerm(x![1][pos]);
            zero := Zero(x![1][1]); # of path algebra
            elem := ListWithIdenticalEntries(Length(x![1]), zero);
            elem[pos] := lt;
            return PathAlgebraVectorNC(FamilyObj(x), elem, pos,
                                       IsNormalForm(x));
        else
            return x;
        fi;
    end );

@ 

The leading coefficient can also be accessed.

<<Leading coefficient of path algebra vectors>>=
InstallOtherMethod( LeadingCoefficient,
    "for path algebra vectors",
    true,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( x )
        local pos, fam;

        pos := x![2];
        fam := FamilyObj(x);
        if pos <= fam!.vectorLen then
            return LeadingCoefficient(x![1][pos]);
        else
            return LeadingCoefficient(x![1][1]);
        fi;
    end );
@

In the case of uniform elements, 
accessing source and target vertices
makes sense.
The following operations return the source and target vertices.
\textit{Note: These should be moved.}

<<Declare vertex accessing operations>>=
DeclareSynonym("TargetVertex", TargetOfPath);
DeclareSynonym("SourceVertex", SourceOfPath);
@ %def Target Source

<<Implement vertex accessing operations>>=
InstallOtherMethod( TargetVertex,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        if IsRightUniform(v) then
            if IsZero(v) then
                return FamilyObj(v)!.zeroPath;
            else
                return TargetOfPath(LeadingMonomial(v![1][v![2]]));
            fi;
        fi;
        return fail;
    end );
@

<<Implement vertex accessing operations>>=
InstallOtherMethod( SourceVertex,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        if IsRightUniform(v) then
            if IsZero(v) then
                return FamilyObj(v)!.zeroPath;
            else
                return SourceOfPath(LeadingMonomial(v![1][v![2]]));
            fi;
        fi;
        return fail;
    end );
@

We often want the leading component
of a path algebra vector.

<<Declaration for accessing the leading component of a path algebra vector>>=
DeclareAttribute( "LeadingComponent", IsPathAlgebraVector );
@ %def LeadingComponent

<<Implementation of access to the leading component of a path algebra vector>>=
InstallMethod( LeadingComponent,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        if IsZero(v) then
            return v![1][ 1 ];
        fi;
        return v![1][ v![2] ];
    end );
@

We also often want the leading position of the path algebra vector.

<<Declaration of the leading position in a path algebra vector>>=
DeclareAttribute( "LeadingPosition", IsPathAlgebraVector );
@ %def LeadingPosition

<<Implementation of the leading position in a path algebra vector>>=
InstallMethod( LeadingPosition,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        return v![2];
    end );
@

\subsection{Logical Operations}

Path algebra vectors are ordered by first
ordering the components and then using the order of the underlying
ring. Components are ordered from left to right, with left components
being greater than the right components. The [[<]] operation provides the
ordering functionality.

<<Less than for path algebra vectors>>=
InstallMethod( \<,
    "for path algebra vectors",
    IsIdenticalObj,
    [IsPathAlgebraVector 
         and IsPathAlgebraVectorDefaultRep
         and IsNormalForm,
     IsPathAlgebraVector 
         and IsPathAlgebraVectorDefaultRep
         and IsNormalForm], 0,
    function(x, y)
        local fam;

        fam := FamilyObj(x);
        if x![2] = y![2] then
            return x![1]{[x![2]..fam!.vectorLen]} 
                   < y![1]{[y![2]..fam!.vectorLen]};
        else
            return y![2] < x![2];
        fi;
    end );
@ 

\paragraph{Operation}
The [[=]] operation tests if two elements of a finitely presented right module
are equal.

<<Equals for path algebra vectors>>=
InstallMethod( \=,
    "for path algebra vectors",
    IsIdenticalObj,
    [IsPathAlgebraVector
         and IsPathAlgebraVectorDefaultRep 
         and IsNormalForm,
     IsPathAlgebraVector 
         and IsPathAlgebraVectorDefaultRep 
         and IsNormalForm], 0,
    function(x, y)
        return x![1] = y![1];
    end );
@     

\paragraph{Operation}
The [[IsLeftDivisible]] operation checks to see if the tip of [[x]] is
left divisible by the tip of [[y]]. 

<<Declaration of IsLeftDivisible>>=
DeclareOperation( "IsLeftDivisible",
    [IsPathAlgebraVector, IsPathAlgebraVector]);
@ 

<<Implementation of IsLeftDivisible>>=
InstallMethod( IsLeftDivisible,
    "for path algebra vectors",
    IsIdenticalObj,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep,
     IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( x, y )
        local xTipPos, xLeadingTerm, xCoeff, xMon, xWalk,
              yTipPos, yLeadingTerm, yCoeff, yMon, yWalk;

        xTipPos := x![2];
        xLeadingTerm := LeadingTerm(x)![1][xTipPos];
        xMon := TipMonomial(xLeadingTerm);
        xWalk := WalkOfPath(xMon);
        yTipPos := y![2];
        yLeadingTerm := LeadingTerm(y)![1][yTipPos];
        yMon := TipMonomial(yLeadingTerm);
        yWalk := WalkOfPath(yMon);

        return xTipPos = yTipPos 
               and not IsEmpty(xWalk)
               and PositionSublist(xWalk, yWalk) = 1;
    end );
@ 

We can determine if vectors are left, right, or completely
uniform.

<<Uniformity for path algebra vectors>>=
InstallOtherMethod( IsLeftUniform,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        local s, verts;

        if IsZero(v) then
            return true;
        fi;

        if ForAll(v![1], IsLeftUniform) then
            verts := Filtered( v![1], x -> not IsZero(x) );
            verts := List( verts, function(x)
                if IsPackedElementDefaultRep(x) then
                    return CoefficientsAndMagmaElements(x![1])[1];
                else
                    return CoefficientsAndMagmaElements(x)[1];
                fi;
            end );
            verts := List( verts, x -> SourceOfPath(x) );
            verts := AsSet(verts);
            return Length(verts) = 1;
        fi;

        return false;        
    end );

InstallOtherMethod( IsRightUniform,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        local s, verts;

        if IsZero(v) then
            return true;
        fi;

        if ForAll(v![1], IsRightUniform) then
            verts := Filtered( v![1], x -> not IsZero(x) );
            verts := List( verts, function(x)
                if IsPackedElementDefaultRep(x) then
                    return CoefficientsAndMagmaElements(x![1])[1];
                else
                    return CoefficientsAndMagmaElements(x)[1];
                fi;
            end );
            verts := List( verts, x -> TargetOfPath(x) );
            verts := AsSet(verts);
            return Length(verts) = 1;
        fi;

        return false;        
    end );

InstallOtherMethod( IsUniform,
    "for path algebra vectors",
    true,
    [ IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( v )
        local s, verts;

        if IsZero(v) then
            return true;
        fi;

        return IsLeftUniform(v) and IsRightUniform(v);        
    end );
@

\subsection{Bases for Spaces of Path Algebra Vectors}

In this section,
we add methods 
for handling bases 
of vector spaces generated 
by path algebra vectors.

<<Declaration of Basis of Path Algebra Vector Space>>=
DeclareCategory( "IsBasisOfPathAlgebraVectorSpace", IsBasis );
@ %def IsBasisOfPathAlgebraVectorSpace


The [[NewBasis]] method constructs a basis object
containing the specified basis vectors.

<<Bases for spaces spanned by path algebra vectors>>=
InstallMethod( NewBasis,
    "for a space of path algebra vectors and a homogenous list",
    IsIdenticalObj,
    [ IsFreeLeftModule and IsPathAlgebraVectorCollection,
      IsPathAlgebraVectorCollection and IsList ], 0,
    function( V, vectors )
        local B;  # The basis

        B := Objectify( NewType( FamilyObj( V ),
                                 IsBasis and
                                 IsBasisOfPathAlgebraVectorSpace and
                                 IsAttributeStoringRep ),
                        rec() );
        SetUnderlyingLeftModule( B, V );
        SetBasisVectors( B, vectors );
        return B;
    end );
@

Now, given a list of path algebra vectors,
we find an echelonized basis
and a change of basis for the input list
of vectors.

<<Bases for spaces spanned by path algebra vectors>>=
HOPF_TriangularizePathAlgebraVectorList := function( vectors )
    local basechange, heads, k, head, cf, pos, i, one, testHead,
          b, b1, sort, hpos;

    vectors := Filtered( vectors, x -> not IsZero(x) );

    if Length(vectors) = 0 then
        return rec( echelonbas := vectors, heads := [], basechange := [] );
    fi;

    one := One(LeadingCoefficient(vectors[1]));
    basechange := List( [1..Length(vectors)], x -> [ [x, one] ] );
    SortParallel( vectors, basechange );
    heads := [];
    k := Length(vectors);
    while k > 0 do
        sort := false;
        cf := LeadingCoefficient(vectors[k]);
        vectors[k] := vectors[k]/cf;
        for i in [1..Length(basechange[k])] do
            basechange[k][i][2] := basechange[k][i][2]/cf;
        od;
        head := LeadingTerm(vectors[k]);
        hpos := LeadingPosition(head);
        Add(heads, head);
        for i in Reversed([1..k-1]) do
            pos := LeadingPosition(vectors[i]);
            testHead := LeadingTerm(vectors[i]);
            if pos = hpos and head![1][pos] = testHead![1][pos] then
                sort := true;
                cf := LeadingCoefficient(vectors[i]);
                vectors[i] := vectors[i] - cf*vectors[k];
                for b in basechange[k] do
                    b1 := [ b[1], -cf*b[2] ];
                    pos := PositionSorted(basechange[i], b1,
                               function( x, y ) return x[1] < y[1];
                           end );
                    if Length(basechange[i]) < pos 
                       or basechange[i][pos][1] <> b1[1]
                    then
                        InsertElmList( basechange[i], pos, b1 );
                    else
                        basechange[i][pos][2] := basechange[i][pos][2] + b1[2];
                    fi;
                od;
            fi;
        od;

        if sort then
            # Remove any zeroes and sort the list again
            for i in [1..k-1] do
                if IsZero(vectors[i]) then
                    Unbind(vectors[i]);
                    Unbind(basechange[i]);
                    k := k-1;
                fi;
            od;
            vectors := Filtered(vectors, x -> IsBound(x));
            basechange := Filtered(basechange, x -> IsBound(x));
            SortParallel(vectors, basechange);
        fi; 
        k := k-1;
   od;

    return rec( echelonbas := vectors, 
                heads := Reversed(heads), 
                basechange := basechange );
end;
@

First, the non-checking basis creation is implemented.

<<Bases for spaces spanned by path algebra vectors>>=
InstallMethod( BasisNC,
    "for a space spanned by path alg. vec., and a list of path alg. vec.",
    IsIdenticalObj,
    [ IsFreeLeftModule and IsPathAlgebraVectorCollection,
      IsPathAlgebraVectorCollection and IsList ], 0,
    function( V, vectors )
        local B, info;

        vectors := Filtered(vectors, x -> not IsZero(x));
        info := HOPF_TriangularizePathAlgebraVectorList( vectors );
        if Length(info.echelonbas) <> Length(vectors) then 
            return fail; 
        fi;
        B := NewBasis( V, vectors );
        B!.echelonBasis := info.echelonbas;
        B!.heads := info.heads;
        B!.baseChange := info.basechange;
        return B;
    end );
@

This implementation verifies that the basis vectors
are in the proper vector space.

<<Bases for spaces spanned by path algebra vectors>>=
InstallMethod( Basis,
    "for a space spanned by path alg. vec., and a list of path alg. vec.",
    IsIdenticalObj,
    [ IsFreeLeftModule and IsPathAlgebraVectorCollection,
      IsPathAlgebraVectorCollection and IsList ], NICE_FLAGS+1,
    function( V, vectors )
        if not ForAll( vectors, x -> x in V ) then
            return fail;
        fi;

        return BasisNC(V, vectors);
    end );
@

This implementation uses the generators
of the vector space to create the basis.

<<Bases for spaces spanned by path algebra vectors>>=
InstallMethod( BasisOfDomain,
    "for a space spanned by path alg. vec.",
    true,
    [IsFreeLeftModule and IsPathAlgebraVectorCollection], NICE_FLAGS+1,
    function( V )
        local B, info, vectors;

        vectors := ShallowCopy(GeneratorsOfLeftModule(V));
        info := HOPF_TriangularizePathAlgebraVectorList( vectors );
        B := NewBasis( V, info.echelonbas );
        B!.echelonBasis := info.echelonbas;
        B!.heads := info.heads;
        B!.baseChange := List( [1..Length(info.echelonbas)],
                               x -> [[ x, One(LeftActingDomain(V)) ]] );
        return B;
    end );

InstallMethod( Basis,
    "for a space spanned by path alg. vec.",
    true,
    [IsFreeLeftModule and IsPathAlgebraVectorCollection], NICE_FLAGS+1,
    function( V )
        local B, info, vectors;

        vectors := ShallowCopy(GeneratorsOfLeftModule(V));
        info := HOPF_TriangularizePathAlgebraVectorList( vectors );
        B := NewBasis( V, info.echelonbas );
        B!.echelonBasis := info.echelonbas;
        B!.heads := info.heads;
        B!.baseChange := List( [1..Length(info.echelonbas)],
                               x -> [[ x, One(LeftActingDomain(V)) ]] );
        return B;
    end );
@

For a specified vector $V$  and basis, 
calculate the coefficients
of the basis vectors that 
form a linear combination for $V$.

<<Bases for spaces spanned by path algebra vectors>>=
InstallMethod( Coefficients,
    "for basis of path alg. vec, and path alg. vec.",
    true,
    [IsBasisOfPathAlgebraVectorSpace, 
     IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep], 0,
    function( B, v )
        local w, cf, i, b, c, zero, pos, lm, hlm, hpos;

        w := v;
        zero := Zero(LeadingCoefficient(v));
        cf := List( BasisVectors(B), x -> zero );
        i := Length(B!.heads);
        while i > 0 and not IsZero(w) do
            lm := LeadingMonomial(LeadingComponent(w));
            pos := LeadingPosition(w);
            # find a matching basis vector
            repeat
                hlm := LeadingMonomial(LeadingComponent(B!.heads[i]));
                hpos := LeadingPosition(B!.heads[i]);
                i := i - 1;
            until (hpos = pos and hlm <= lm) or pos < hpos or i = 0;
            # Either no match was found, so we're done or
            # match was found, so we update the coefficients.
            if lm <> hlm then
                return fail;
            else
                # the leading monomials match
                c := LeadingCoefficient(w);
                w := w - c*B!.echelonBasis[i + 1];
                for b in B!.baseChange[i + 1] do
                    cf[b[1]] := cf[b[1]] + b[2]*c;
                od;
            fi;
        od;
        if IsZero(w) then
            return cf;
        fi;
        return fail;
    end );
@

Need to implement our own [in] method
to avoid the braindead slowdown
of the generic finite spaces implementation
in the GAP library.

<<Element membership for spaces generated by path algebra vectors>>=
InstallMethod( \in,
    "for path algebra vector and space generated by path alg. vec.",
    IsElmsColls,
    [IsPathAlgebraVector, 
     IsFreeLeftModule and IsPathAlgebraVectorCollection], NICE_FLAGS+1,
    function( v, V )
        local B, cf;

        B := BasisOfDomain(V);
        cf := Coefficients(B, v);
        return cf <> fail;
    end );
@

\section{Path Algebra Modules}
\label{section:Path Algebra Modules}

Path algebra modules are a special kind
of algebra modules.
We inherit several other properties
of algebra modules such as [[LeftActingAlgebra]],
[[RightActingAlgebra]], etc. as a result.

<<Path Algebra Module Properties>>=
DeclareProperty( "IsPathAlgebraModule", IsAlgebraModule );
@

\subsection{Vertex Projective Modules}

Let $\algebra{A}$ be a path algebra,
and let $v$ be a vertex in the quiver defining $\algebra{A}$.
The set $v\algebra{A}$ is the set of all linear combinations 
of monomials in $\algebra{A}$ with the starting vertex $v$.
Clearly, $v\algebra{A}$ is a right $\algebra{A}$-module.
In general,
direct sums
of modules of the form $v\algebra{A}$
are right $\algebra{A}$-modules,
which we call \defitem{right vertex projective} modules 
over $\algebra{A}$.

We identify vertex projective modules
in GAP with the following property.

<<Path Algebra Module Properties>>=
DeclareProperty( "IsVertexProjectiveModule", IsPathAlgebraModule );
@

The [[RightProjectiveModule]] operation
is used to create these vertex projective modules.
The operation takes a path algebra [[A]]
and a list of vertices [[verts]]
to construct the appropriate vertex projective module.

<<Declaration of RightProjectiveModule>>=
DeclareOperation( "RightProjectiveModule", [IsRing, IsObject] );
@ %def RightProjectiveModule

<<Implementation of RightProjectiveModule>>=
InstallMethod( RightProjectiveModule,
    "for path algebra and list of vertices",
    IsIdenticalObj,
    [ IsPathAlgebra, IsHomogeneousList ], 0,
    function( A, verts )
	local i, fam, zero, gen, gens, M;

        <<Verify the list contains only vertices>>
        <<Construct the family for the vectors>>
        <<Construct the zero vector>>
        <<Construct the module generators>>

        M := RightAlgebraModule( A, \^, gens );
        SetIsPathAlgebraModule( M, true );
        SetIsVertexProjectiveModule( M, true );
        SetIsWholeFamily( M, true );
        fam!.wholeModule := M;
        return M;
    end );
@

The list contains only vertices if each element
is the same as its tip,
the monomial is a vertex in the quiver,
and the coefficient is 1.

<<Verify the list contains only vertices>>=
if not ForAll(verts, function(x)
    return x = Tip(x)
           and IsVertex(TipMonomial(x))
           and One(TipCoefficient(x)) = TipCoefficient(x);
    end )
then
    Error("<verts> should be a list of embedded vertices");
fi;
@

The family for the vectors contains the vector type 
in the field [[defaultType]],
the expected vector length 
in the field [[vectorLen]], 
the vertices (in the quiver, not the path algebra)
for each component
in the [[vertices]] field,
and the family 
for the components
in the [[componentFam]] field.
Since this implementation is only
for path algebras and not their quotients,
vectors are always in normal form.
We indicate that during the construction
of the vector type.

<<Construct the family for the vectors>>=
fam := NewFamily( "IsPathAlgebraVectorFamily", IsPathAlgebraVector );
fam!.defaultType := NewType( fam, IsPathAlgebraVectorDefaultRep
                                  and IsNormalForm );
fam!.vectorLen := Length(verts);
fam!.vertices := Immutable(List(verts, TipMonomial));
fam!.componentFam := FamilyObj(A);
fam!.zeroPath := Zero(QuiverOfPathAlgebra(A));
@

The zero vector is contructed to quickly return for zero operations.

<<Construct the zero vector>>=
zero := Zero(A);
fam!.zeroVector := PathAlgebraVectorNC(fam,
    ListWithIdenticalEntries(fam!.vectorLen, zero),
    fam!.vectorLen + 1, true);
@

We now construct the module generators
by placing each vertex in its component location,
with all other components being zero.

<<Construct the module generators>>=
gens := [];
for i in [1..fam!.vectorLen] do
    gen := ListWithIdenticalEntries(fam!.vectorLen, zero);
    gen[i] := verts[i];
    Add(gens, PathAlgebraVectorNC( fam, gen, i, true));
od;
@

\paragraph{Quotients of Path Algebras}

Vertex projective modules can also be created
over quotients of path algebras.
This is very similar
to the previous implementation,
except that the default type
for vectors may or may not identify vectors
as being in normal form.

<<Implementation of RightProjectiveModule>>=
InstallMethod( RightProjectiveModule,
    "for f.p. path algebras and vertices",
    IsIdenticalObj,
    [ IsSubalgebraFpPathAlgebra, IsHomogeneousList ], 0,
    function( A, verts )
	local i, fam, zero, gen, gens, M;

        <<Verify the list contains only vertices>>
        <<Construct the family for vectors of f.p. path algebra elements>>
        <<Construct the zero vector>>
        <<Construct the module generators>>
        M := RightAlgebraModule( A, \^, gens );
        SetIsPathAlgebraModule( M, true );
        SetIsWholeFamily( M, true );
        SetIsVertexProjectiveModule( M, true );
        fam!.wholeModule := M;
        return M;
    end );
@

The family for f.p. path algebra vectors
denotes that the vectors are in normal form
if the f.p. path algebra has a normal form function.

<<Construct the family for vectors of f.p. path algebra elements>>=
fam := NewFamily( "IsPathAlgebraVectorFamily", IsPathAlgebraVector );
if HasNormalFormFunction(ElementsFamily(FamilyObj(A))) then
    fam!.defaultType := NewType( fam, IsPathAlgebraVectorDefaultRep
                                      and IsNormalForm );
else
    fam!.defaultType := NewType( fam, IsPathAlgebraVectorDefaultRep );
fi;
fam!.vectorLen := Length(verts);
fam!.vertices := Immutable(List(verts, TipMonomial));
fam!.componentFam := FamilyObj(A);
fam!.zeroPath := Zero(QuiverOfPathAlgebra(A));
@


Submodules of path algebra modules can also be created.
We essentially copy the code from the GAP 4.2 library,
but add in the [[Parent]] property
and the fact that a submodule
of a path algebra module is still a path algebra module.

<<Submodules of path algebra modules>>=
InstallMethod( SubAlgebraModule,
    "for path algebra module and a list of submodule generators",
    IsIdenticalObj,
    [ IsFreeLeftModule and IsPathAlgebraModule,
      IsAlgebraModuleElementCollection and IsList], 0,
    function( V, gens )
        local sub;

        sub := Objectify( NewType( FamilyObj( V ),
                          IsLeftModule and IsAttributeStoringRep),
                          rec() );
        SetParent( sub, V );
        SetIsAlgebraModule( sub, true );
        SetIsPathAlgebraModule( sub, true );
        SetLeftActingDomain( sub, LeftActingDomain(V) );
        SetGeneratorsOfAlgebraModule( sub, gens );

        if HasIsFiniteDimensional( V ) and IsFiniteDimensional( V ) then
            SetIsFiniteDimensional( sub, true );
        fi;

        if IsLeftAlgebraModuleElementCollection( V ) then
           SetLeftActingAlgebra( sub, LeftActingAlgebra( V ) );
        fi;

        if IsRightAlgebraModuleElementCollection( V ) then
           SetRightActingAlgebra( sub, RightActingAlgebra( V ) );
        fi;

        return sub;
    end );
@

This implementation accepts a basis for the submodule.

<<Submodules of path algebra modules>>=
InstallOtherMethod( SubAlgebraModule,
    "for path algebra module and a list of submodule generators",
    function(F1,F2,F3) return IsIdenticalObj( F1, F2 ); end,
    [ IsFreeLeftModule and IsPathAlgebraModule,
      IsAlgebraModuleElementCollection and IsList,
      IsString ], 0,
    function( V, gens, str )
        local sub;
        
        if str <> "basis" then
            Error("Usage: SubAlgebraModule( <V>, <gens>, <str> ) where the last argument is string \"basis\"" );
        fi;

        sub := SubAlgebraModule( V, gens );
        SetGeneratorsOfLeftModule( sub, gens );
        SetBasisOfDomain( sub, NewBasis( sub, gens ) );
        SetDimension( sub, Length( gens ) );

        return sub;
    end );
@

\subsection{Algebra Actions}

The [[^]] operation multiplies an element of a finitely presented
right module element by an element in the right acting ring.

<<Right action of algebra elements on path algebra vectors>>=
InstallOtherMethod( \^,
    "for path algebra vectors and path algebra",
    function(x, a)
        return IsIdenticalObj( ElementsFamily(x!.componentFam), a );
    end,
    [IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep, IsRingElement], 0,
    function( x, a )
        local i, fam, components, pos;
        fam := FamilyObj(x);
        components := x![1]*a;
        pos := fam!.vectorLen+1;
        for i in [x![2]..fam!.vectorLen] do
            if not IsZero(components[i]) then
                pos := i;
                break;
            fi;
        od;
        return PathAlgebraVectorNC(FamilyObj(x), components, pos, false);
    end );
@ 

\subsection{Determining Vertex Projectiveness}

A path algebra module is vertex projective
if the appropriate components (vertex in one component and
zeroes in all others)
are contained in the module.

<<Implementation of vertex projective test>>=
InstallMethod( IsVertexProjectiveModule,
    "for a path algebra module",
    true,
    [ IsPathAlgebraModule ], 0,
    function( M )
        local vecFam, A, verts, gen, zero, i, vs;

        A := ActingAlgebra( M );
        zero := Zero(A);
        vecFam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
        verts := vecFam!.vertices;
        for i in [1..vecFam!.vectorLen] do
            gen := ListWithIdenticalEntries(vecFam!.vectorLen, zero);
            gen[i] := verts[i]*One(A);
            gen := PathAlgebraVectorNC(vecFam, gen, i, true);
            vs := UnderlyingLeftModule(Basis(M)!.delegateBasis);
            if not gen in vs then
                return false;
            fi;
        od;
        return true;
    end );
@

\subsection{Bases of Path Algebra Modules}

We implement a canonical basis method 
for path algebra modules that are vertex projective modules.
The canonical basis is formed 
by taking all canonical basis elements
of the acting algebra, filtering
them by starting vertex, and placing
algebra basis elements
in the appropriate components.

<<Bases for path algebra modules>>=
InstallMethod( CanonicalBasis,
    "for vertex projective path algebra modules",
    true,
    [ IsFreeLeftModule 
      and IsPathAlgebraModule 
      and IsVertexProjectiveModule 
      and IsRightAlgebraModuleElementCollection ], NICE_FLAGS+1,
    function(M)
        local A, abv, vecFam, mbv, MB, elem, bv, zero, i;

        A := ActingAlgebra(M);
        zero := Zero(A);
        abv := BasisVectors(CanonicalBasis(A));

        vecFam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
        mbv := []; 
        for i in [1..vecFam!.vectorLen] do
            for elem in abv do
                if not IsZero(vecFam!.vertices[i]*elem) then
                    bv := ListWithIdenticalEntries(vecFam!.vectorLen, zero);
                    bv[i] := elem;
                    Add(mbv, Vectorize(M, bv));
                fi;
            od;
        od;
        Sort(mbv);
        MB := BasisNC(M, mbv);
        SetIsCanonicalBasis( MB, true );
        return MB;
    end );
@
    
<<Bases for path algebra modules>>=
InstallMethod( Basis,
    "for vertex projective path algebra modules",
    true,
    [ IsFreeLeftModule 
      and IsPathAlgebraModule 
      and IsVertexProjectiveModule
      and IsRightAlgebraModuleElementCollection ], NICE_FLAGS+1,
    CanonicalBasis );
@

For path algebra submodules,
we can be a bit more intelligent
about constructing the bases.

<<Bases for path algebra modules>>=
InstallMethod( Basis,
    "for a path algebra module",
    true,
    [ IsFreeLeftModule 
      and IsPathAlgebraModule
      and IsRightAlgebraModuleElementCollection ], NICE_FLAGS+1,
    function( M )
        local fam, gens, gb, W, vecs, newbVecs;

        if not IsPathAlgebra(ActingAlgebra(M)) then
            TryNextMethod();
        fi;

        fam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
        gens := GeneratorsOfAlgebraModule( M );
        gb := RightGroebnerBasisOfModule( M );
        W := fam!.wholeModule;
        vecs := BasisVectors( CanonicalBasis(W) );

        newbVecs := List(vecs, x -> x - CompletelyReduce( gb, x ));
        newbVecs := AsSet(Filtered(newbVecs, x -> not IsZero(x)));

        SetDimension( M, Length(newbVecs) );
        return NewBasis( M, newbVecs );
    end );
@

\subsection{Specialized Generators}

The [[UniformGeneratorsOfModule]] attribute stores the uniform
projection of generators of a path algebra module.

<<Declaration of UniformGeneratorsOfModule>>=
DeclareAttribute( "UniformGeneratorsOfModule", IsPathAlgebraModule );
@ %def UniformGeneratorsOfModule

<<Implementation of UniformGeneratorsOfModule>>=
InstallMethod( UniformGeneratorsOfModule,
    "for path algebra modules",
    true,
    [ IsPathAlgebraModule and 
      IsRightAlgebraModuleElementCollection ], 0,
    function( M )
        local A, Q, uniformGens, v, uniformGen, gen;

        A := RightActingAlgebra(M);
        Q := QuiverOfPathAlgebra(A);
        uniformGens := [];
        for v in VerticesOfQuiver(Q) do
            for gen in GeneratorsOfAlgebraModule(M) do
                uniformGen := gen^(v*One(A));
                if not IsZero(uniformGen) then
                    AddSet(uniformGens, uniformGen);
                fi;
            od;
        od;

        return uniformGens;
    end );
@ 

\subsection{Element Reduction and Normal Forms}

\paragraph{Function}
The [[ReduceRightModuleElement]] function reduces one right module
element by another. The reduced version of the element is returned. No
checks are in place to make sure the reduction makes sense.

<<Implementation of ReduceRightModuleElement>>=
ReduceRightModuleElement := function(x, y)
    local xTipPos, xLeadingTerm, xCoeff, xMon, xWalk,
          yTipPos, yLeadingTerm, yCoeff, yMon, yWalk,
          first, last, path;

    xTipPos := x![2];
    xLeadingTerm := LeadingTerm(x)![1][xTipPos];
    xCoeff := TipCoefficient(xLeadingTerm);
    xMon := TipMonomial(xLeadingTerm);
    xWalk := WalkOfPath(xMon);
    yTipPos := y![2];
    yLeadingTerm := LeadingTerm(y)![1][yTipPos];
    yCoeff := TipCoefficient(yLeadingTerm);
    yMon := TipMonomial(yLeadingTerm);
    yWalk := WalkOfPath(yMon);

    path := One(xLeadingTerm);
    first := Length(yWalk) + 1;
    last := Length(xWalk);
    if first <= last then
        path := path*Product(xWalk{[first..last]});
    fi;
    path := xCoeff/yCoeff * path;
    x := x - y^path;

    return x;
end;
@ 

\paragraph{Function}
The [[NormalizeRightModuleElement]] takes a list of right module
elements forming a tip reduced right \groebner basis and a right
module element and puts the element into normal form.

<<Implementation of NormalizeRightModuleElement>>=
NormalizeRightModuleElement := function(G, x)
    local g, newX, reduced;

    newX := Zero(x);
    while not IsZero(x) do
        reduced := false;
        for g in G do
            if IsLeftDivisible(x, g) then
                x := ReduceRightModuleElement( x, g );
                reduced := true;
                break;
            fi;
        od;
        if not reduced then
            newX := newX + LeadingTerm(x);
            x := x - LeadingTerm(x);
        fi;
    od;
    return newX;
end;
@ 

\subsection{Groebner Bases}

In this section,
we implement \groebner\ bases
for path algebra modules.
At this time,
only right path algebra modules are supported.

<<Declaration of right groebner basis for path algebra modules>>=
DeclareAttribute( "RightGroebnerBasisOfModule", IsPathAlgebraModule );
@ %def RightGroebnerBasisOfModule

All \groebner\ bases for path algebra modules are in the
[[IsPathAlgebraModuleGroebnerBasis]] category.

<<Declarations for path algebra module Groebner bases>>=
DeclareCategory( "IsPathAlgebraModuleGroebnerBasis", IsObject );
@ %def IsPathAlgebraModuleGroebnerBasis

We distinguish between right and left \groebner\ bases.

<<Declarations for path algebra module Groebner bases>>=
DeclareProperty( "IsRightPathAlgebraModuleGroebnerBasis",
                 IsPathAlgebraModuleGroebnerBasis );
DeclareProperty( "IsLeftPathAlgebraModuleGroebnerBasis",
                 IsPathAlgebraModuleGroebnerBasis );
@ 

The underlying module for the path algebra module \groebner basis is
stored in the [[UnderlyingModule]] attribute.

<<Declaration of UnderlyingModule>>=
DeclareAttribute( "UnderlyingModule", IsPathAlgebraModuleGroebnerBasis );
@ %def UnderlyingModule

The default representation for path algebra module \groebner bases is
to store static dictionaries for searching for elements to reduce
quotient module elements and to store the elements of the \groebner
basis.

<<Declaration of IsPathAlgebraModuleGroebnerBasisDefaultRep>>=
DeclareRepresentation( "IsPathAlgebraModuleGroebnerBasisDefaultRep",
    IsAttributeStoringRep, ["staticDictionaries", "gbasisElems"] );
@ %def IsPathAlgebraModuleGroebnerBasisDefaultRep

This implementation constructs the \groebner basis for the module.

<<Implementation of RightGroebnerBasisOfModule>>=
InstallMethod( RightGroebnerBasisOfModule,
    "for a path algebra module",
    true,
    [ IsPathAlgebraModule and 
      IsRightAlgebraModuleElementCollection ], 0,
    function( M )
        local A, Q, uniformGens,
              H, i, j, r, s, reducible, tipPos, toReduce,
              staticDictionaries, gbasisElems, gb, fam;

        A := RightActingAlgebra(M);
        if not IsPathAlgebra(A) then
            Error("The acting domain must be a path algebra");
        fi;
        Q := QuiverOfPathAlgebra(A);
        uniformGens := UniformGeneratorsOfModule( M );
        <<Create a completely reduced set of generators>>
        <<Create static dictionaries for gb elements>>
        gb := Objectify( NewType(FamilyObj(M),
                             IsPathAlgebraModuleGroebnerBasis and
                             IsPathAlgebraModuleGroebnerBasisDefaultRep),
                         rec( gbasisElems := Immutable(gbasisElems),
                              staticDictionaries := 
                                   Immutable(staticDictionaries) ) );
        gbasisElems := List(Flat(gbasisElems), 
                            x -> ObjByExtRep(ElementsFamily(FamilyObj(M)), x));
        SetBasisVectors(gb, gbasisElems);
        SetUnderlyingModule(gb, M);
        SetIsRightPathAlgebraModuleGroebnerBasis(gb, true);
        return gb;
    end );
@ 

This is the bulk of the effort for creating a right \groebner
basis. This loop reduces elements until no more elements can be
reduced. 

<<Create a completely reduced set of generators>>=
H := List(uniformGens, ExtRepOfObj);
repeat
    if IsZero(H[1]) then
        RemoveSet(H, H[1]);
    fi;
    r := Length(H);
    i := 1;
    reducible := [];
    while i <= Length(H) do
        tipPos := H[i]![2]; # Component position of the tip
        j := i + 1;
        while j <= Length(H) and H[j]![2] = tipPos do
            if IsLeftDivisible(H[j], H[i]) then
                AddSet(reducible, H[j]);
                RemoveSet(H, H[j]);
            else
                j := j + 1;
            fi;
        od;
        i := i + 1;
    od;
    s := Length(H);
    for i in [1..Length(reducible)] do
        toReduce := reducible[i];
        toReduce := NormalizeRightModuleElement( H, toReduce );
        reducible[i] := toReduce;
    od;

    UniteSet(H, AsSet(reducible));
until s = r;
H := List(H, x -> Tip(x) + NormalizeRightModuleElement( H, x - Tip(x) ));
@ 

The static dictionaries are created to speed the normalization process
for elements.

<<Create static dictionaries for gb elements>>=
fam := ElementsFamily(FamilyObj(H));
staticDictionaries := [];
gbasisElems := List([1..fam!.vectorLen], x -> []);
for i in H do
    Add(gbasisElems[i![2]], i);
od;
for i in [1..fam!.vectorLen] do
    if not IsEmpty(gbasisElems[i]) then
        staticDictionaries[i] := QuiverStaticDictionary(Q,
            List(gbasisElems[i], 
                 x -> LeadingMonomial(x![1][x![2]])) );
    fi;
od;
@ 


\subsubsection{Displaying Groebner Bases}

The [[ViewObj]] operation prints out the \groebner basis in a nice form.

<<Implementation of ViewObj for Groebner bases of path algebra modules>>=
InstallMethod( ViewObj,
    "for a Groebner basis of a path algebra module",
    true,
    [ IsPathAlgebraModuleGroebnerBasis and HasBasisVectors ],
    0,
    function( B )
        Print( "<Groebner basis of " );
        View( UnderlyingModule( B ) );
        Print(", ");
        View( BasisVectors( B ) );
        Print( " >" );
    end );
@ 

<<Implementation of ViewObj for Groebner bases of path algebra modules>>=
InstallMethod( ViewObj,
    "for a basis of a right module",
    true,
    [ IsPathAlgebraModuleGroebnerBasis ],
    0,
    function( B )
        Print( "<Groebner basis of " );
        View( UnderlyingModule( B ) );
        Print(", ...>");
    end );
@ 


\paragraph{Operation}

The [[CompletelyReduce]] operation reduces an element by a \groebner basis.

<<Implementation of CompletelyReduce for path algebra modules>>=
InstallOtherMethod( CompletelyReduce,
    "for a path algebra module Groebner basis",
    IsCollsElms,
    [ IsRightPathAlgebraModuleGroebnerBasis 
      and IsPathAlgebraModuleGroebnerBasisDefaultRep,
      IsRightAlgebraModuleElement and IsPackedElementDefaultRep ], 0,
    function( gb, v )
        local fam;

        v := ExtRepOfObj(v);
        fam := ElementsFamily(FamilyObj(gb));
        return ObjByExtRep(fam, CompletelyReduce(gb, v));
    end );
@ 

<<Implementation of CompletelyReduce for path algebra modules>>=
InstallOtherMethod( CompletelyReduce,
    "for a path algebra module Groebner basis",
    true,
    [ IsRightPathAlgebraModuleGroebnerBasis 
      and IsPathAlgebraModuleGroebnerBasisDefaultRep,
      IsPathAlgebraVector and IsPathAlgebraVectorDefaultRep ], 0,
    function( gb, v )
        local matches, c, newVec, tipMon, match, redVector, fam;

        if IsZero(v) then
            return v;
        fi;

        newVec := Zero(v);
        repeat
            c := v![2];
            tipMon := LeadingMonomial( v![1][c] );
            if IsBound(gb!.staticDictionaries[c]) then
                matches := PrefixSearch( gb!.staticDictionaries[c], tipMon );
            else
                matches := [];
            fi;
            if not IsEmpty(matches) then
                match := matches[1][2][1];
                redVector := gb!.gbasisElems[c][match];
                v := ReduceRightModuleElement( v, redVector );
            else
                newVec := newVec + LeadingTerm(v);
                v := v - LeadingTerm(v);
            fi;
        until IsZero(v);

        return newVec;
    end );
@

\section{Finitely Presented Path Algebra Modules}

In this section,
we implement finitely presented path algebra modules
via vertex projective presentations.
A user is expected
to create a vertex projective module $M$
and a submodule $N$ of $M$
to create the finitely presented path algebra module.
Finitely presented modules
are encoded
as nontips
of the right \groebner\ basis
for $N$.
We introduce a property
for identifying
finitely presented path algebra modules.

<<Declaration of finitely presented path algebra modules>>=
DeclareProperty( "IsFpPathAlgebraModule", IsAlgebraModule );
@ %def IsFpPathAlgebraModule

\subsection{Finitely Presented Path Algebra Module Elements}

Algebra modules are formed
from underlying vectors.
We identify vectors forming
finitely presented path algebra modules
with a special category.
This allows us
to take advantage
of the operations defined
for path algebra vectors
and to specialize
any methods
for vectors making
up finitely presented path algebra modules.

<<Declarations of finitely presented path algebra module vectors>>=
DeclareCategory( "IsFpPathAlgebraVector", IsPathAlgebraVector );
DeclareCategoryCollections( "IsFpPathAlgebraVector" );
DeclareCategoryFamily( "IsFpPathAlgebraVector" );
@ %def IsFpPathAlgebraVector

\subsubsection{Displaying Vectors}

We implement a special print method for vectors 
in finitely presented path algebra modules.

<<PrintObj for f.p. path algebra vectors>>=
InstallMethod( PrintObj,
    "for f.p. path algebra vectors", 
    true,
    [IsFpPathAlgebraVector 
     and IsPathAlgebraVectorDefaultRep ], 0,
    function( x )
        Print( "[ ", x![1], " ]" );
    end );
@ 


\subsubsection{Vector Creation}

Create vectors from lists of path algebra elements
for f.p. path algebra modules.

<<Implementation of Vectorize for f.p. path algebra modules>>=
InstallOtherMethod( Vectorize,
    "for path algebra modules and a homogeneous list",
    true,
    [IsFpPathAlgebraModule, IsHomogeneousList], 0,
    function( M, vector )
        local vecElmFam, modElmFam;

        vecElmFam := FamilyObj(ExtRepOfObj(Zero(M)));
        modElmFam := ElementsFamily(FamilyObj(M));
        return ObjByExtRep(modElmFam, PathAlgebraVector(vecElmFam, vector));
    end );
@ 

\subsection{Module Lifting}

This method returns
a module that can be used
to construct a right \groebner\ basis
over a path algebra $\K\Gamma$
for representing finitely presented
path algebra modules.

<<Declare module lifting operation>>=
DeclareOperation( "LiftPathAlgebraModule", [IsPathAlgebraModule] );
@ %def LiftPathAlgebraModule

<<Implementation of module lifting operation>>=
InstallMethod( LiftPathAlgebraModule,
    "for a right path algebra module over a f.p. path algebra",
    true,
    [ IsPathAlgebraModule and IsRightAlgebraModuleElementCollection ], 0,
    function( M )
        local A, fpFam, I, gb, vecFam, liftedParent, parentFam, zero,
              rgbElems, gens, gen, i, Lift, KGamma, liftedVerts,
              liftedFam, elem, component, liftedM;

        A := ActingAlgebra( M );
        if not IsSubalgebraFpPathAlgebra( A ) then
            return M;
        fi;

        # Verify that the ideal has a Groebner basis
        fpFam := ElementsFamily(FamilyObj(A));
        I := fpFam!.ideal;
        if not HasGroebnerBasisOfIdeal( I ) then
            TryNextMethod();
        fi;

        # Make sure the Groebner basis is complete
        gb := GroebnerBasisOfIdeal( I );
        if not IsCompleteGroebnerBasis( gb ) then
            TryNextMethod();
        fi;

        <<Lifting function>>
        KGamma := fpFam!.pathAlgebra;
        vecFam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
        liftedVerts := List(vecFam!.vertices, x -> x*One(KGamma));
        liftedParent := RightProjectiveModule(KGamma, liftedVerts);
        parentFam := ElementsFamily(FamilyObj(liftedParent));
        liftedFam := parentFam!.underlyingModuleEltsFam;

        if not IsVertexProjectiveModule(M) then
            gens := List( GeneratorsOfAlgebraModule(M), 
                          x -> ObjByExtRep(parentFam, 
                                   Lift(liftedFam!.defaultType, x![1]) ) );
        else
            gens := [];

        fi;

        rgbElems := Enumerator(RightGroebnerBasis(I));
        zero := Zero(KGamma);
        for i in [1..liftedFam!.vectorLen] do
            for elem in rgbElems do
                component := liftedFam!.vertices[i]*elem;
                if not IsZero(component) then
                    gen := ListWithIdenticalEntries(liftedFam!.vectorLen, zero);
                    gen[i] := component;
                    Add(gens, Vectorize(liftedParent, gen));
                fi;
            od;
        od;

        if not IsEmpty(gens) then
            liftedM := SubAlgebraModule(liftedParent, gens);
            return liftedM;
        else
            return liftedParent;
        fi;
    end );
@

The following function lifts a vector in an $A$-module to
$K\Gamma$-module element.

<<Lifting function>>=
Lift := function(type, x)
    return Objectify(type, [List(x![1], y -> y![1]), x![2]]);
end;
@ 

\subsection{Creation}

To create finitely presented path algebra modules,
the [[NaturalHomomorphismBySubAlgebraModule]]
method must be implemented.
We implement this method where
the parent module $M$
is a vertex projective
module and
for a submodule of $M$.

<<Natural homomorphism for path algebra modules>>=
InstallMethod( NaturalHomomorphismBySubAlgebraModule,
    "for vertex projective path algebra module and path algebra module",
    IsIdenticalObj,
    [ IsPathAlgebraModule and IsVertexProjectiveModule,
      IsPathAlgebraModule ], 0,
    function( M, N )
        local fam, hom, gb, U, A, zero, nontips, B, i, bv, gens, gen;

        if IsLeftAlgebraModuleElementCollection( M ) then
            TryNextMethod();
        fi;

        <<Create the f.p. path algebra module element family>>
        <<Create the normal form function for the family>>
        <<Create the generators of the f.p. path algebra module>>
        <<Construct the f.p. path algebra module>>
        <<Create a basis for the f.p. path algebra module>>
        <<Construct the homomorphism>>

        return hom;   
    end );
@

We begin by creating a family
for the elements in the finitely presented path algebra module.
These elements are right algebra module elements

<<Create the f.p. path algebra module element family>>=
fam := NewFamily( "IsFpPathAlgebraVectorFamily", IsFpPathAlgebraVector );
fam!.defaultType := NewType( fam, IsPathAlgebraVectorDefaultRep );
fam!.preimageFam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
fam!.vectorLen := fam!.preimageFam!.vectorLen;
fam!.vertices := fam!.preimageFam!.vertices;
fam!.componentFam := fam!.preimageFam!.componentFam;
fam!.bottomModule := N;
fam!.needsLift := IsSubalgebraFpPathAlgebra(ActingAlgebra(N));
fam!.zeroPath := Zero(QuiverOfPathAlgebra(ActingAlgebra(N)));
@

Normal forms of elements 
in finitely presented algebra modules
are elements reduced
by an appropriate right \groebner\ basis
of $N$. This might require lifting $N$
to an appropriate $\K\Gamma$ module.

<<Create the normal form function for the family>>=
N := LiftPathAlgebraModule(N);
gb := RightGroebnerBasisOfModule(N);
if gb <> fail then
    if fam!.needsLift then
       fam!.liftedFam := ElementsFamily(FamilyObj(N))!.underlyingModuleEltsFam;
    fi;
    fam!.gb := gb;
    fam!.defaultType := NewType(fam, IsPathAlgebraVectorDefaultRep
                                     and IsNormalForm );
    SetNormalFormFunction(fam, function(fam, components, pos)
        local nf, preVec, fpFam, vecFam;

        if fam!.needsLift then
            fpFam := ElementsFamily(FamilyObj(components));
            vecFam := fam!.liftedFam;
            components := List(components, x -> x![1]);
        else
            vecFam := fam!.preimageFam;
        fi;

        preVec := PathAlgebraVectorNC(vecFam, components, pos, false);
        nf := CompletelyReduce(fam!.gb, preVec);
        
        if fam!.needsLift then
            nf![1] := List(nf![1], x->ElementOfFpPathAlgebra(fpFam, x, true));
        fi;

        return Objectify( fam!.defaultType, [nf![1], nf![2]] );
    end );

    nontips := Filtered(BasisVectors(CanonicalBasis(M)), function(x)
        local er;
        er := ExtRepOfObj(x);
        return er![1] = NormalFormFunction(fam)(fam,er![1],er![2])![1];
    end );
    nontips := List( nontips, function(x)
        local er;
        er := ExtRepOfObj(x);
        return PathAlgebraVectorNC(fam,er![1],er![2],true);
    end );
fi;
@

Now we create the standard generating set
for the finitely presented path algebra module.
This is just each vertex in the appropriate component.

<<Create the generators of the f.p. path algebra module>>=
A := ActingAlgebra(M);
zero := Zero(A);
fam!.zeroVector := PathAlgebraVectorNC(fam, 
                        ListWithIdenticalEntries(fam!.vectorLen, zero),
                        fam!.vectorLen + 1, true );
gens := [];
for i in [1..fam!.vectorLen] do
    gen := ListWithIdenticalEntries(fam!.vectorLen, zero);
    gen[i] := fam!.vertices[i]*One(A);
    Add(gens, PathAlgebraVectorNC( fam, gen, i, true ));
od;
gens := Filtered(gens, x -> not IsZero(x));
@

The algebra module encoding the f.p. path algebra module is now created.
The module contains the whole family of elements.

<<Construct the f.p. path algebra module>>=
U := RightAlgebraModule( A, \^, gens );
SetIsFpPathAlgebraModule( U, true );
SetIsWholeFamily(U, true);
fam!.wholeModule := U;
@

Now construct a basis for [[U]] if possible.

<<Create a basis for the f.p. path algebra module>>=
if IsBound(nontips) then
    Sort(nontips);
    B := NewBasis( U, List(nontips, 
                           x->ObjByExtRep(ElementsFamily(FamilyObj(U)), x) ) );
    SetBasis( U, B );
    SetDimension( U, Length(nontips) );
fi;
@

We now construct the homomorphism.
This is done by mapping the basis
of the top module $M$
to the basis of the quotient module $U$.
Obviously, this will fail 
to work if the modules are not finite dimensional.

<<Construct the homomorphism>>=
bv := BasisVectors(Basis(M));
hom := LeftModuleHomomorphismByImagesNC( M, U, bv,
           List(bv, x -> Vectorize(U, ExtRepOfObj(x)![1]) ) );
SetIsSurjective(hom, true);
@

An operation is also provided
to construct f.p. path algebra modules
from a path algebra
a list of lists 
of path algebra elements,
which forms the map
in the presentation.
This operation checks
to make sure the map
is acceptable,
then constructs
the module.

<<Declaration of vertex projective presentation>>=
DeclareOperation( "VertexProjectivePresentation", 
                  [ IsAlgebra, IsRingElementTable ] );
@ %def VertexProjectivePresentation

<<Vertex projective presentation over path algebras>>=
InstallMethod( VertexProjectivePresentation,
    "For a path algebra and a list of lists of path algebra elements",
    IsElmsColls,
    [ IsAlgebra, IsRingElementTable ], 0,
    function( A, map )
        local gen, len, verts, gVerts, i, P, N;

        if not (IsPathAlgebra(A) or IsSubalgebraFpPathAlgebra(A)) then
            TryNextMethod();
        fi;

        # Make sure generators are not empty
        if IsEmpty(map) then
            Error("Usage: VertexProjectivePresentation( <A>, <map> ) <map> must be nonempty.");
        fi;

        # Make sure all entries are left uniform
        for gen in map do
            if not ForAll(gen, IsLeftUniform) then
                Error("Usage: VertexProjectivePresentation( <A>, <map> ) entries in <map> must be left uniform.");
            fi;
        od;

        # Verify vertices
        verts := List(map[1], x -> SourceVertex(LeadingMonomial(x)));
        for gen in map do
            gVerts := List(gen, x -> SourceVertex(LeadingMonomial(x)));
            for i in [1..Length(verts)] do
                if IsZeroPath(verts[i]) and not IsZeroPath(gVerts[i]) then
                    verts[i] := gVerts[i];
                elif verts[i] <> gVerts[i] and not IsZeroPath(gVerts[i]) then
                    Error("Usage: VertexProjectivePresentation( <A>, <map> ) <map> contains mismatched starting vertices.");
                fi;
            od;
        od;
        if not ForAll(verts, x -> not IsZeroPath(x)) then
            Error("Usage: VertexProjectivePresentation( <A>, <map> ) <map> contains all zeroes in some column.");
        fi;

        # Ok, everything is good, construct the module
        P := RightProjectiveModule( A, List(verts, x -> x*One(A) ) );
        map := List( map, x -> Vectorize(P, x) );
        N := SubAlgebraModule(P, map);

        return P/N;
    end );
@

<<Vertex projective presentation over path algebras>>=
InstallOtherMethod( VertexProjectivePresentation,
    "For a path algebra and a list of lists of path algebra elements",
    function(F1, F2, F3) 
        return IsElmsColls(F1, F2) and IsIdenticalObj(F1,F3); 
    end,
    [ IsAlgebra, IsRingElementTable, IsList ], 0,
    function( A, map, verts )
        local gen, len, gVerts, i, P, N;

        if not (IsPathAlgebra(A) or IsSubalgebraFpPathAlgebra(A)) then
            TryNextMethod();
        fi;

        # Make sure generators are not empty
        if IsEmpty(map) then
            Error("Usage: VertexProjectivePresentation( <A>, <map>, <verts> ) <map> must be nonempty.");
        fi;

        # Make sure generators have the same length
        len := Length(verts);
        if not ForAll(map, x -> Length(x) = len ) then
            Error("Usage: VertexProjectivePresentation( <A>, <map>, <verts> ) rows in <map> and <verts> must have the same length.");
        fi;

        # Make sure all entries are left uniform
        for gen in map do
            if not ForAll(gen, IsLeftUniform) then
                Error("Usage: VertexProjectivePresentation( <A>, <map>, <verts> ) entries in <map> must be left uniform.");
            fi;
        od;

	<<Verify the list contains only vertices>>
        verts := List(verts, TipMonomial);

        # Verify vertices
        for gen in map do
            gVerts := List(gen, x -> SourceVertex(LeadingMonomial(x)));
            for i in [1..Length(verts)] do
                if verts[i] <> gVerts[i] and not IsZeroPath(gVerts[i]) then
                    Error("Usage: VertexProjectivePresentation( <A>, <map>, <verts> ) <map> contain mismatched starting vertices.");
                fi;
            od;
        od;

        # Ok, everything is good, construct the module
        P := RightProjectiveModule( A, List(verts, x -> x*One(A) ) );
        map := List( map, x -> Vectorize(P, x) );
        N := SubAlgebraModule(P, map);

        return P/N;
    end );
@

\subsection{Homomorphism Spaces and Endomorphism Rings}

Before constructing the homomorphism spaces and endomorphism
rings, we introduce a new filter for left module homomorphisms
to denote that they are in fact algebra homomorphisms.

<<Declaration of IsAlgebraModuleHomomorphism filter>>=
DeclareFilter( "IsAlgebraModuleHomomorphism", IsLeftModuleGeneralMapping );
@ %def IsAlgebraModuleHomomorphism

This is an implementation of constructing homomorphism spaces and
endomorphism rings of factor modules over path algebras. Right now,
this does not check to guarantee we are working with a factor module,
so it will break for other path algebra modules. The implementation
here will be described in Struble~\cite{Struble}.

<<Implementation of the Hom computation for f.p. path algebra modules>>=
HOPF_FpPathAlgebraModuleHom := function(A, M, N)
        local B, bv, F, Q, verts, partVec, vec, mon, i, j, k, l, rt,
              arrows, src, tgt, map, maps, Mfam, mapArrows, eqns, uGens,
              rows, cols, currentRow, currentCol, colLabels, cokernel,
              tensElems, Ndim, endo, componentBasis, nf, lc, gens,
              r, s, coeffs, term, ebv, Nfam, mbv, embv, Mdim;

        rt := Runtime();
        Info( InfoPathAlgebraModule, 1, "Starting the computation" );

        F := LeftActingDomain(A);
        Q := QuiverOfPathAlgebra(A);
        B := Basis(N);

	<<Partition basis elements by terminating vertex>>
        <<Build linear maps for arrows>>
        <<Build linear equations>>
        <<Find a basis of the cokernel>>
        <<Interpret the resulting basis (matrices)>>
        <<Construct resulting endomorphisms (matrices)>>
        <<Construct the homomorphism space generators (matrices)>>
end;
@


The first step to constructing the endomorphism ring is to partition
the basis elements by their terminating vertex. This determines the
size of each vector space associated with the corresponding vertex in
the quiver. The [[gen_pos]] component of the vertex is used as an
index into an array for storing the basis elements. We assume that the
nice basis described by Green and Struble is being used. The index of
the basis vector is stored in the [[partVec]] array.

<<Partition basis elements by terminating vertex>>=
Info(InfoPathAlgebraModule, 1, "START: Partitioning vertices: ", Runtime()-rt);
bv := BasisVectors(B);
ebv := List(bv, ExtRepOfObj);
verts := VerticesOfQuiver(Q);
partVec := List(verts, x -> []);
for i in [1..Length(bv)] do
    mon := ExtRepOfObj( TargetVertex( ebv[i] ) )[1];
    Add(partVec[mon], i);
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Partitioning vertices: ", Runtime()-rt);
@ 

Next, we build linear maps describing the action of the arrows on the
basis of the module. The maps assume vectors are encoded as row vectors.

<<Build linear maps for arrows>>=
Info(InfoPathAlgebraModule, 1, "START: Linear maps: ", Runtime()-rt);
arrows := GeneratorsOfAlgebraWithOne(A);
maps := [];
for i in [1..Length(arrows)] do
    src := ExtRepOfObj(SourceOfPath( LeadingMonomial(arrows[i]) ))[1];
    tgt := ExtRepOfObj(TargetOfPath( LeadingMonomial(arrows[i]) ))[1];
    maps[i] := List( bv{partVec[src]}, x ->
               Coefficients(B, x^(arrows[i])){partVec[tgt]} );
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Linear maps: ", Runtime()-rt);
@ 

We now build the system of linear equations to solve for finding $M
\tensor N^*$. To build the system, we transpose each of the uniform
generators of $M$ and map the expressions to the associated linear
maps in $N$. The transposition of the generators is implicitly done in
the code.

<<Build linear equations>>=
Info(InfoPathAlgebraModule, 1, "START: Linear equations: ", Runtime()-rt);
Mfam := ElementsFamily(FamilyObj(M))!.underlyingModuleEltsFam;
Nfam := ElementsFamily(FamilyObj(N))!.underlyingModuleEltsFam;
uGens := UniformGeneratorsOfModule(Mfam!.bottomModule);
cols := List( Mfam!.vertices, x -> Length(partVec[ ExtRepOfObj(x)[1] ]) );
rows := List( uGens, 
    function(x)
        local v;
        v := TargetVertex( ExtRepOfObj(x) );
        return Length(partVec[ ExtRepOfObj(v)[1] ]);
    end );

# rows and cols are reversed because we directly
# construct the transposed eqns matrix to avoid
# unnecessary copying.    
eqns := NullMat( Sum(cols), Sum(rows), F );

currentRow := 1;
for i in [1..Length(uGens)] do
    currentCol := 1;
    for j in [1..Mfam!.vectorLen] do
        term := ExtRepOfObj(uGens[i])![1][j];
        if not IsZero(term) then
            eqns{[currentCol..currentCol+cols[j]-1]}
                {[currentRow..currentRow+rows[i]-1]}:=
                MappedExpression(term, arrows, maps);
        fi;
        currentCol := currentCol + cols[j];
    od;
    currentRow := currentRow + rows[i];
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Linear equations: ", Runtime()-rt);
@ 

The cokernel of the equations is the nullspace of the system
of equations. The cokernel gives a basis for $M \tensor N^*$.

<<Find a basis of the cokernel>>=
Info(InfoPathAlgebraModule, 1, "START: Cokernel: ", Runtime()-rt);
Info(InfoPathAlgebraModule, 2, "Dimensions: ", DimensionsMat(eqns));
cokernel := NullspaceMatDestructive( eqns );
Info(InfoPathAlgebraModule, 1, "FINISH: Cokernel: ", Runtime()-rt);
@ 

The resulting basis [[cokernel]] is transformed into elements of $M
\tensor_\Lambda N^*$. We assume that the generators of the module are
of the form $[v_1, 0, ...]$, $[0, v_2, ...]$, in that order (even
though this is reverse sorted order). The result of this code is each
element (row) in [[cokernel]] is transformed into a list of triples,
consisting of [[ (c, m, d ) ]], where [[c]] is a coefficient, [[m]] is
an index into the standard basis for $M$, and [[d]] is an index into
the dual basis for $N^*$. The triple represents an element-tensor of the form
\begin{displaymath}
\sum_{i=1}^{\mathrm{dim}~M} c_i (b_{m_i} \tensor b^*_{d_i}).
\end{displaymath}
Only the non-zero triples are retained, and stored in [[tensElems]].

<<Interpret the resulting basis>>=
Info(InfoPathAlgebraModule, 1, "START: Interpret basis: ", Runtime()-rt);
mbv := BasisVectors(Basis(M));
componentBasis := List(GeneratorsOfAlgebraModule(M), 
                       x -> PositionSet(mbv, x) );

colLabels := Flat( List( [1..Mfam!.vectorLen], 
    x -> ListWithIdenticalEntries( cols[x], componentBasis[x] ) ) );
colLabels := [colLabels, Flat( List( Mfam!.vertices, 
                                     x -> partVec[ ExtRepOfObj(x)[1] ]))];

Ndim := Dimension(N);
Mdim := Dimension(M);
tensElems := List( [1..Length(cokernel)], x -> [] );
endo := [];
for i in [1..Length(cokernel)] do
    endo[i] := ListWithIdenticalEntries(Mdim, Zero(N));
    for j in [1..Sum(cols)] do
        k := colLabels[1][j];
        l := colLabels[2][j];
        if not IsZero(cokernel[i][j]) then
            Add(tensElems[i], [cokernel[i][j], k, l]);
        fi;
    od;
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Interpret basis: ", Runtime()-rt);
@ 

This is an alternate implementation that encodes homomorphisms
by matrices instead of by element images. To start, we interpret
the basis elements of the solution space for our system
of linear equations.

<<Interpret the resulting basis (matrices)>>=
Info(InfoPathAlgebraModule, 1, "START: Interpret basis: ", Runtime()-rt);
mbv := BasisVectors(Basis(M));
componentBasis := List(GeneratorsOfAlgebraModule(M), 
                       x -> PositionSet(mbv, x) );

colLabels := Flat( List( [1..Mfam!.vectorLen], 
    x -> ListWithIdenticalEntries( cols[x], componentBasis[x] ) ) );
colLabels := [colLabels, Flat( List( Mfam!.vertices, 
                                     x -> partVec[ ExtRepOfObj(x)[1] ]))];

Ndim := Dimension(N);
Mdim := Dimension(M);
tensElems := List( [1..Length(cokernel)], x -> [] );
endo := [];
for i in [1..Length(cokernel)] do
    endo[i] := NullMat(Mdim, Ndim, F);
    for j in [1..Sum(cols)] do
        k := colLabels[1][j];
        l := colLabels[2][j];
        if not IsZero(cokernel[i][j]) then
            Add(tensElems[i], [cokernel[i][j], k, l]);
        fi;
    od;
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Interpret basis: ", Runtime()-rt);
@

The element-tensors are transformed into endomorphism, forming a basis
for the endomorphism ring. The endomorphisms are specificied as linear
vector space maps from $M$ to $N$.  We note that the basis of the
cokernel describes the images of the generators of the module. We then
extend the map to all elements by applying elements of the ring to the
generator and image.

<<Construct resulting endomorphisms>>=
Info(InfoPathAlgebraModule, 1, "START: Homomorphisms: ", Runtime()-rt);
embv := List(mbv, ExtRepOfObj);
for i in [1..Length(cokernel)] do
    for j in [1..Mdim] do
        for k in tensElems[i] do
            if LeadingPosition( embv[j] ) = LeadingPosition( embv[ k[2] ] ) 
            then
                endo[i][j] := endo[i][j] + 
                              k[1]*(bv[ k[3] ]^(LeadingComponent( embv[j] )));
            fi;
        od;    
    od;
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Homomorphisms: ", Runtime()-rt);
@ 

This is an alternate implementation that contructs endomorphisms
as matrices. The intent is that this will be faster, but require
more memory.

<<Construct resulting endomorphisms (matrices)>>=
Info(InfoPathAlgebraModule, 1, "START: Homomorphisms: ", Runtime()-rt);
embv := List(mbv, ExtRepOfObj);
for j in [1..Mdim] do
    map := MappedExpression( LeadingComponent(embv[j]), arrows, maps );
    src := ExtRepOfObj(
               SourceVertex(LeadingMonomial(LeadingComponent(embv[j]))))[1];
    tgt := ExtRepOfObj(
               TargetVertex(LeadingMonomial(LeadingComponent(embv[j]))))[1];
    for i in [1..Length(cokernel)] do
        for k in tensElems[i] do
            if LeadingPosition( embv[j] ) = LeadingPosition( embv[ k[2] ] ) 
               and ExtRepOfObj(TargetVertex( ebv[k[3]] ))[1] = src
            then
                endo[i][j]{partVec[tgt]} := endo[i][j]{partVec[tgt]} + 
                              k[1]*map[PositionSet(partVec[src], k[3])];
            fi;
        od;    
    od;
od;
for map in endo do
    MakeImmutable(map);
    ConvertToMatrixRep(map, F);
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Homomorphisms: ", Runtime()-rt);
@

The final step is to construct the GAP homomorphisms.

<<Construct the homomorphism space generators>>=
Info(InfoPathAlgebraModule, 1, "START: Hom gens: ", Runtime()-rt);
gens := List(endo, img -> LeftModuleHomomorphismByImagesNC(M, N, mbv, img) );
for i in [1..Length(gens)] do
    SetFilterObj(gens[i], IsAlgebraModuleHomomorphism);
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Hom gens: ", Runtime()-rt);
return gens;
@ 

And the matrix version.

<<Construct the homomorphism space generators (matrices)>>=
Info(InfoPathAlgebraModule, 1, "START: Hom gens: ", Runtime()-rt);
gens := List(endo, 
             img -> LeftModuleHomomorphismByMatrix(Basis(M), img, Basis(N)) );
for i in [1..Length(gens)] do
    SetFilterObj(gens[i], IsAlgebraModuleHomomorphism);
od;
Info(InfoPathAlgebraModule, 1, "FINISH: Hom gens: ", Runtime()-rt);
return gens;
@ 


<<Implementation of Hom for f.p. path algebra modules>>=
InstallMethod(Hom,
    "for a path algebra and two f.p. path algebra modules",
    true,
    [ IsRing, IsFpPathAlgebraModule, IsFpPathAlgebraModule ], 0,
    function( A, M, N )
        local F, gens;

        if not IsIdenticalObj(A, ActingAlgebra(M)) then
            Error("The path algebra is not compatible with the module.");
        fi;
 
        F := LeftActingDomain(A);
        gens := HOPF_FpPathAlgebraModuleHom(A, M, N);
        return VectorSpace( F, gens, "basis" );
    end );
@

<<Implementation of End for f.p. path algebra modules>>=
InstallMethod( End,
    "for a path algebra and a path algebra module",
    true,
    [IsRing, IsFpPathAlgebraModule], 0,
    function( A, M )
        local F, gens;

        if not IsIdenticalObj(A, ActingAlgebra(M)) then
            Error("The path algebra is not compatible with the module.");
        fi;
 

        F := LeftActingDomain(A);
        gens := HOPF_FpPathAlgebraModuleHom(A, M, M);
        return AlgebraWithOne( F, gens, "basis" );
    end);
@ 

\subsection{Special Implementations for Algebra Module Homomorphisms}

These implementations are to work around performance problems
with the GAP library, as well as to provide more information
about the images of algebra module homomorphisms.

<<Image source for algebra module homomorphisms>>=
InstallMethod( ImagesSource,
    "for a linear g.m.b.i that is an algebra module homomorphism",
    true,
    [ IsGeneralMapping and IsLinearGeneralMappingByImagesDefaultRep
      and IsAlgebraModuleHomomorphism ],
    function(map)
        if IsBound( map!.basisimage ) then
            return UnderlyingLeftModule( map!.basisimage );
        else
            return SubAlgebraModule(Range(map), map!.genimages);
        fi;
    end );
@

<<Image source for algebra module homomorphisms>>=
InstallMethod( ImagesSource,
    "for a linear g.m.b.i that is an algebra module homomorphism",
    true,
    [ IsGeneralMapping and IsLinearMappingByMatrixDefaultRep
      and IsAlgebraModuleHomomorphism ],
    function(map)
        local images;

        if IsBound( map!.basisimage ) then
            return UnderlyingLeftModule( map!.basisimage );
        else
            images := List( map!.matrix, 
                            row -> LinearCombination( map!.basisrange, row ));
                           
            return SubAlgebraModule(Range(map), images);
        fi;
    end );
@
